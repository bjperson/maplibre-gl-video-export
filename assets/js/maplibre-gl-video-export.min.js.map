{"version":3,"file":"maplibre-gl-video-export.min.js","sources":["../../src/utils.js","../../src/animations.js","../../src/controller.js","../../src/webm-encoder-wrapper.js","../../src/index.js","../../node_modules/mediabunny/dist/modules/src/misc.js","../../node_modules/mediabunny/dist/modules/src/tags.js","../../node_modules/mediabunny/dist/modules/src/codec.js","../../node_modules/mediabunny/dist/modules/src/muxer.js","../../node_modules/mediabunny/dist/modules/src/codec-data.js","../../node_modules/mediabunny/dist/modules/src/custom-coder.js","../../node_modules/mediabunny/dist/modules/src/packet.js","../../node_modules/mediabunny/dist/modules/src/sample.js","../../node_modules/mediabunny/dist/modules/src/matroska/ebml.js","../../node_modules/mediabunny/dist/modules/src/subtitles.js","../../node_modules/mediabunny/dist/modules/src/writer.js","../../node_modules/mediabunny/dist/modules/src/target.js","../../node_modules/mediabunny/dist/modules/src/matroska/matroska-muxer.js","../../node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js","../../node_modules/mediabunny/dist/modules/src/output-format.js","../../node_modules/mediabunny/dist/modules/src/encode.js","../../node_modules/mediabunny/dist/modules/src/media-source.js","../../node_modules/mediabunny/dist/modules/src/output.js","../../src/webcodecs-vp9-encoder.js"],"sourcesContent":["// ============================================================================\n// Geometric and Mathematical Utility Functions\n// ============================================================================\n\n/**\n * Calculate bearing between two points\n * @param {number} lng1 - Longitude of first point\n * @param {number} lat1 - Latitude of first point\n * @param {number} lng2 - Longitude of second point\n * @param {number} lat2 - Latitude of second point\n * @returns {number} Bearing in degrees (0-360)\n */\nexport function calculateBearing(lng1, lat1, lng2, lat2) {\n  const dLng = (lng2 - lng1) * Math.PI / 180;\n  const lat1Rad = lat1 * Math.PI / 180;\n  const lat2Rad = lat2 * Math.PI / 180;\n\n  const y = Math.sin(dLng) * Math.cos(lat2Rad);\n  const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -\n              Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);\n\n  const bearing = Math.atan2(y, x) * 180 / Math.PI;\n  return (bearing + 360) % 360; // Normalize to 0-360\n}\n\n/**\n * Calculate distance between two points using Haversine formula\n * @param {number} lng1 - Longitude of first point\n * @param {number} lat1 - Latitude of first point\n * @param {number} lng2 - Longitude of second point\n * @param {number} lat2 - Latitude of second point\n * @returns {number} Distance in kilometers\n */\nexport function calculateDistance(lng1, lat1, lng2, lat2) {\n  const R = 6371; // Earth's radius in kilometers\n  const dLat = (lat2 - lat1) * Math.PI / 180;\n  const dLng = (lng2 - lng1) * Math.PI / 180;\n\n  const lat1Rad = lat1 * Math.PI / 180;\n  const lat2Rad = lat2 * Math.PI / 180;\n\n  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(lat1Rad) * Math.cos(lat2Rad) *\n              Math.sin(dLng / 2) * Math.sin(dLng / 2);\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c; // Distance in kilometers\n}\n\n/**\n * Calculate a point on a Catmull-Rom spline\n * @param {Array} p0 - Control point 0 [lng, lat]\n * @param {Array} p1 - Control point 1 [lng, lat] (curve starts here)\n * @param {Array} p2 - Control point 2 [lng, lat] (curve ends here)\n * @param {Array} p3 - Control point 3 [lng, lat]\n * @param {number} t - Parameter [0, 1]\n * @param {number} tension - Tension parameter (default 0.5 for standard Catmull-Rom)\n * @returns {Array} Interpolated point [lng, lat]\n */\nexport function catmullRomPoint(p0, p1, p2, p3, t, tension = 0.5) {\n  const t2 = t * t;\n  const t3 = t2 * t;\n\n  const v0 = (p2[0] - p0[0]) * tension;\n  const v1 = (p3[0] - p1[0]) * tension;\n  const lng = (2 * p1[0] - 2 * p2[0] + v0 + v1) * t3 +\n              (-3 * p1[0] + 3 * p2[0] - 2 * v0 - v1) * t2 +\n              v0 * t +\n              p1[0];\n\n  const w0 = (p2[1] - p0[1]) * tension;\n  const w1 = (p3[1] - p1[1]) * tension;\n  const lat = (2 * p1[1] - 2 * p2[1] + w0 + w1) * t3 +\n              (-3 * p1[1] + 3 * p2[1] - 2 * w0 - w1) * t2 +\n              w0 * t +\n              p1[1];\n\n  return [lng, lat];\n}\n\n/**\n * Calculate bounds that contain all waypoints\n * @param {Array} waypoints - Array of waypoint objects with center: [lng, lat]\n * @returns {Array|null} Bounds [[west, south], [east, north]] or null if no waypoints\n */\nexport function getWaypointsBounds(waypoints) {\n  if (!waypoints || waypoints.length === 0) return null;\n\n  let west = Infinity; let south = Infinity; let east = -Infinity; let north = -Infinity;\n\n  waypoints.forEach(wp => {\n    const [lng, lat] = wp.center;\n    west = Math.min(west, lng);\n    east = Math.max(east, lng);\n    south = Math.min(south, lat);\n    north = Math.max(north, lat);\n  });\n\n  // Add 10% padding\n  const padLng = (east - west) * 0.1;\n  const padLat = (north - south) * 0.1;\n\n  return [\n    [west - padLng, south - padLat],\n    [east + padLng, north + padLat]\n  ];\n}\n\n/**\n * Resample a path to have uniformly spaced points\n * This eliminates speed variations caused by irregular point spacing in OSM data\n * @param {Array<[number, number]>} coords - Array of [lng, lat] coordinates\n * @param {number} targetSpacingKm - Desired spacing between points in kilometers (default: 0.01 = 10m)\n * @returns {Array<[number, number]>} Resampled coordinates with uniform spacing\n */\nexport function resamplePath(coords, targetSpacingKm = 0.01) {\n  if (!coords || coords.length < 2) return coords;\n\n  const resampled = [coords[0]]; // Always keep first point\n  let accumulatedDistance = 0;\n\n  for (let i = 1; i < coords.length; i++) {\n    const [lng1, lat1] = coords[i - 1];\n    const [lng2, lat2] = coords[i];\n    const segmentDistance = calculateDistance(lng1, lat1, lng2, lat2);\n\n    accumulatedDistance += segmentDistance;\n\n    // If we've accumulated enough distance, add intermediate points\n    while (accumulatedDistance >= targetSpacingKm) {\n      // Calculate how far along this segment we need to go\n      const overshoot = accumulatedDistance - targetSpacingKm;\n      const t = 1 - (overshoot / segmentDistance); // Interpolation factor [0, 1]\n\n      // Linear interpolation\n      const newLng = lng1 + t * (lng2 - lng1);\n      const newLat = lat1 + t * (lat2 - lat1);\n      resampled.push([newLng, newLat]);\n\n      accumulatedDistance -= targetSpacingKm;\n    }\n  }\n\n  // Always keep last point\n  const lastOriginal = coords[coords.length - 1];\n  const lastResampled = resampled[resampled.length - 1];\n  if (lastOriginal[0] !== lastResampled[0] || lastOriginal[1] !== lastResampled[1]) {\n    resampled.push(lastOriginal);\n  }\n\n  return resampled;\n}\n\n/**\n * Resample path with Catmull-Rom spline interpolation for smooth curves\n * @param {Array} coords - Array of [lng, lat] coordinates\n * @param {number} targetSpacingKm - Target spacing between points in kilometers\n * @param {number} tension - Catmull-Rom tension (0.5 = standard, 0 = linear, 1 = tight curves)\n * @returns {Array} Resampled coordinates with smooth curves\n */\nexport function resamplePathCatmullRom(coords, targetSpacingKm = 0.01, tension = 0.3) {\n  if (!coords || coords.length < 2) return coords;\n  if (coords.length === 2) return resamplePath(coords, targetSpacingKm); // Fallback to linear for 2 points\n\n  // Step 1: Generate smooth curve using Catmull-Rom\n  const smoothCurve = [];\n  const pointsPerSegment = 30; // Generate 30 intermediate points per segment for smoother curves\n\n  for (let i = 0; i < coords.length - 1; i++) {\n    // Get 4 control points for Catmull-Rom\n    const p0 = coords[Math.max(0, i - 1)]; // Previous point (or duplicate first)\n    const p1 = coords[i]; // Current segment start\n    const p2 = coords[i + 1]; // Current segment end\n    const p3 = coords[Math.min(coords.length - 1, i + 2)]; // Next point (or duplicate last)\n\n    // Generate intermediate points along the curve\n    for (let j = 0; j < pointsPerSegment; j++) {\n      const t = j / pointsPerSegment;\n      const point = catmullRomPoint(p0, p1, p2, p3, t, tension);\n      smoothCurve.push(point);\n    }\n  }\n\n  // Always add the last point\n  smoothCurve.push(coords[coords.length - 1]);\n\n  // Step 2: Resample the smooth curve with uniform spacing\n  return resamplePath(smoothCurve, targetSpacingKm);\n}\n\n/**\n * Get optimal center and zoom to show all waypoints\n * Calculates the geographic center and appropriate zoom level to fit all waypoints in view\n * @param {Object} map - MapLibre map instance\n * @param {Object|Array} waypoints - GeoJSON FeatureCollection or Array of waypoint objects\n * @returns {Object|null} {center: [lng, lat], zoom: number} or null if no waypoints\n */\nexport function getOptimalViewForWaypoints(map, waypoints) {\n  if (!waypoints) return null;\n\n  // Handle GeoJSON FeatureCollection format\n  let waypointArray = [];\n  if (waypoints.type === 'FeatureCollection' && waypoints.features) {\n    waypointArray = waypoints.features.map(feature => ({\n      center: feature.geometry.coordinates\n    }));\n  } else if (Array.isArray(waypoints)) {\n    waypointArray = waypoints;\n  } else {\n    return null;\n  }\n\n  if (waypointArray.length === 0) return null;\n\n  // Single waypoint - return its center with current zoom\n  if (waypointArray.length === 1) {\n    return {\n      center: waypointArray[0].center,\n      zoom: map.getZoom()\n    };\n  }\n\n  // Multiple waypoints - calculate bounds\n  let west = Infinity; let south = Infinity; let east = -Infinity; let north = -Infinity;\n\n  waypointArray.forEach(wp => {\n    const [lng, lat] = wp.center;\n    west = Math.min(west, lng);\n    east = Math.max(east, lng);\n    south = Math.min(south, lat);\n    north = Math.max(north, lat);\n  });\n\n  // Calculate center\n  const centerLng = (west + east) / 2;\n  const centerLat = (south + north) / 2;\n\n  // Calculate zoom level to fit all waypoints\n  // Add 15% padding to ensure waypoints aren't at the edge\n  const bounds = [\n    [west, south],\n    [east, north]\n  ];\n\n  const canvas = map.getCanvas();\n  const padding = Math.min(canvas.width, canvas.height) * 0.15;\n\n  // Use MapLibre's cameraForBounds to get optimal zoom\n  const camera = map.cameraForBounds(bounds, {\n    padding: { top: padding, bottom: padding, left: padding, right: padding }\n  });\n\n  return {\n    center: [centerLng, centerLat],\n    zoom: camera ? camera.zoom : map.getZoom()\n  };\n}\n","/**\n * Animations for MapLibre GL\n *\n * Animation system that adapts to map content\n * Detects features like terrain, layers, and bounds to create cinematic sequences\n */\n\n// @ts-check\n/* global maplibregl */\n\n// Import geometric utility functions from utils.js\nimport { calculateBearing, calculateDistance, resamplePath, resamplePathCatmullRom, getOptimalViewForWaypoints } from './utils.js';\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// ============================================================================\n// Road Following Utilities & Constants\n// ============================================================================\n\n/**\n * Standard filter for querying road features from vector tiles\n * Used for vehicle animations that follow roads (car, drone, helicopter, etc.)\n */\nconst ROAD_QUERY_FILTER = [\n  'all',\n  ['==', ['geometry-type'], 'LineString'],\n  ['in', ['get', 'class'], ['literal', [\n    'motorway', 'trunk', 'primary', 'secondary', 'tertiary',\n    'minor', 'service', 'track', 'path'\n  ]]]\n];\n\n/**\n * 8 cardinal directions for road searching and ray casting\n * Used for finding roads in all compass directions from a point\n */\nconst CARDINAL_DIRECTIONS_8 = [\n  { angle: 0, name: 'N' }, // North\n  { angle: 45, name: 'NE' }, // Northeast\n  { angle: 90, name: 'E' }, // East\n  { angle: 135, name: 'SE' }, // Southeast\n  { angle: 180, name: 'S' }, // South\n  { angle: 225, name: 'SW' }, // Southwest\n  { angle: 270, name: 'W' }, // West\n  { angle: 315, name: 'NW' } // Northwest\n];\n\n/**\n * Normalize bearing difference to range [-180, 180]\n * Ensures smallest angular difference is returned\n * @param {number} diff - Bearing difference in degrees\n * @returns {number} Normalized bearing difference in range [-180, 180]\n */\nconst normalizeBearingDiff = (diff) => {\n  while (diff > 180) diff -= 360;\n  while (diff < -180) diff += 360;\n  return diff;\n};\n\n/**\n * Validate that a coordinate is a valid [lng, lat] array with numbers\n * @param {Array} coord - Coordinate to validate\n * @returns {boolean} True if coordinate is valid [number, number] array\n */\nconst isValidCoordinate = (coord) => {\n  return coord &&\n           Array.isArray(coord) &&\n           typeof coord[0] === 'number' &&\n           typeof coord[1] === 'number';\n};\n\n/**\n * Cleanup map2 (helper map) and associated debug layers\n * @param {Object} options - Options object containing map2, div2, etc.\n * @param {Object} map - Main map instance for removing debug layers\n */\nconst cleanupMap2AndDebugLayer = (options, map) => {\n  // Remove helper map\n  if (options.map2) {\n    try { options.map2.remove(); } catch (e) {}\n  }\n\n  // Remove helper div\n  if (options.div2 && options.div2.parentNode) {\n    options.div2.parentNode.removeChild(options.div2);\n  }\n\n  // Remove debug visualization layers\n  try {\n    if (map.getLayer('drone-followed-segments-layer')) {\n      map.removeLayer('drone-followed-segments-layer');\n    }\n    if (map.getSource('drone-followed-segments')) {\n      map.removeSource('drone-followed-segments');\n    }\n  } catch (e) {}\n};\n\n/**\n * Convert degrees to meters (at equator)\n * @param {number} degrees - Distance in degrees\n * @param {number} precision - Decimal places (default: 0)\n * @returns {string} Distance in meters as formatted string\n */\n// eslint-disable-next-line no-unused-vars\nconst degreesToMeters = (degrees, precision = 0) => (degrees * 111000).toFixed(precision);\n\n/**\n * Calculate intersection distance between two line segments\n * Uses parametric line intersection algorithm\n * @param {Array} p1 - First point of first segment [x, y]\n * @param {Array} p2 - Second point of first segment [x, y]\n * @param {Array} p3 - First point of second segment [x, y]\n * @param {Array} p4 - Second point of second segment [x, y]\n * @returns {number|null} Distance from p1 to intersection point, or null if no intersection\n */\nconst segmentIntersection = (p1, p2, p3, p4) => {\n  const x1 = p1[0]; const y1 = p1[1];\n  const x2 = p2[0]; const y2 = p2[1];\n  const x3 = p3[0]; const y3 = p3[1];\n  const x4 = p4[0]; const y4 = p4[1];\n\n  const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n  if (Math.abs(denom) < 1e-10) return null; // Parallel lines\n\n  const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n  const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n  if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n    // Intersection exists - calculate point and distance\n    const ix = x1 + t * (x2 - x1);\n    const iy = y1 + t * (y2 - y1);\n    const dx = ix - x1;\n    const dy = iy - y1;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  return null; // No intersection\n};\n\n/**\n * AnimationConstraints class\n * Manages geographic and zoom constraints for animations\n * Ensures animations stay within specified bounds and zoom levels\n */\nexport class AnimationConstraints {\n  constructor(options = {}) {\n    this.maxBounds = options.maxBounds || null; // [[west, south], [east, north]]\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : null;\n    this.maxZoom = options.maxZoom !== undefined ? options.maxZoom : null;\n    this.strictBounds = options.strictBounds || false;\n  }\n\n  /**\n     * Check if a center point is within bounds\n     * @param {Array|Object} center - [lng, lat] or {lng, lat}\n     * @returns {boolean}\n     */\n  isWithinBounds(center) {\n    if (!this.maxBounds) return true;\n\n    // Handle both array and LngLat object formats\n    const lng = Array.isArray(center) ? center[0] : center.lng;\n    const lat = Array.isArray(center) ? center[1] : center.lat;\n    const [[west, south], [east, north]] = this.maxBounds;\n\n    return lng >= west && lng <= east && lat >= south && lat <= north;\n  }\n\n  /**\n     * Constrain a center point to be within bounds\n     * @param {Array|Object} center - [lng, lat] or {lng, lat}\n     * @returns {Array|Object} Constrained center in same format as input\n     */\n  constrainCenter(center) {\n    if (!this.maxBounds) return center;\n\n    // Handle both array and LngLat object formats\n    const isArray = Array.isArray(center);\n    const lng = isArray ? center[0] : center.lng;\n    const lat = isArray ? center[1] : center.lat;\n    const [[west, south], [east, north]] = this.maxBounds;\n\n    const constrainedLng = Math.max(west, Math.min(east, lng));\n    const constrainedLat = Math.max(south, Math.min(north, lat));\n\n    // Return in the same format as input\n    if (isArray) {\n      return [constrainedLng, constrainedLat];\n    } else {\n      // Return as LngLat-like object\n      return {\n        lng: constrainedLng,\n        lat: constrainedLat,\n        // Preserve other properties if it's a full LngLat object\n        ...(center.toArray ? { toArray: () => [constrainedLng, constrainedLat] } : {})\n      };\n    }\n  }\n\n  /**\n     * Check if a zoom level is within limits\n     * @param {number} zoom\n     * @returns {boolean}\n     */\n  isWithinZoomLimits(zoom) {\n    if (this.minZoom !== null && zoom < this.minZoom) return false;\n    if (this.maxZoom !== null && zoom > this.maxZoom) return false;\n    return true;\n  }\n\n  /**\n     * Constrain a zoom level to be within limits\n     * @param {number} zoom\n     * @returns {number} Constrained zoom\n     */\n  constrainZoom(zoom) {\n    if (this.minZoom !== null && zoom < this.minZoom) return this.minZoom;\n    if (this.maxZoom !== null && zoom > this.maxZoom) return this.maxZoom;\n    return zoom;\n  }\n\n  /**\n     * Apply constraints to camera options (for flyTo, easeTo, etc.)\n     * @param {Object} options - Camera options\n     * @returns {Object} Constrained options\n     */\n  applyCameraConstraints(options) {\n    const constrained = { ...options };\n\n    // Constrain center - handle undefined, null, and various formats\n    if (options.center !== undefined && options.center !== null) {\n      constrained.center = this.constrainCenter(options.center);\n    }\n\n    // Constrain zoom\n    if (options.zoom !== undefined && options.zoom !== null) {\n      constrained.zoom = this.constrainZoom(options.zoom);\n    }\n\n    return constrained;\n  }\n\n  /**\n     * Calculate a safe animation path that respects bounds\n     * @param {Array|Object} fromCenter - Starting [lng, lat] or {lng, lat}\n     * @param {Array|Object} toCenter - Target [lng, lat] or {lng, lat}\n     * @param {number} steps - Number of intermediate steps\n     * @returns {Array} Array of [lng, lat] waypoints\n     */\n  calculateSafePath(fromCenter, toCenter, steps = 10) {\n    const path = [];\n\n    // Handle both array and LngLat object formats\n    const fromLng = Array.isArray(fromCenter) ? fromCenter[0] : fromCenter.lng;\n    const fromLat = Array.isArray(fromCenter) ? fromCenter[1] : fromCenter.lat;\n    const toLng = Array.isArray(toCenter) ? toCenter[0] : toCenter.lng;\n    const toLat = Array.isArray(toCenter) ? toCenter[1] : toCenter.lat;\n\n    for (let i = 0; i <= steps; i++) {\n      const t = i / steps;\n      const lng = fromLng + (toLng - fromLng) * t;\n      const lat = fromLat + (toLat - fromLat) * t;\n\n      if (this.strictBounds) {\n        // In strict mode, constrain every point\n        path.push(this.constrainCenter([lng, lat]));\n      } else {\n        // In non-strict mode, allow the path but warn if outside\n        path.push([lng, lat]);\n      }\n    }\n\n    return path;\n  }\n\n  /**\n     * Check if the current view respects all constraints\n     * @param {Object} map - MapLibre map instance\n     * @returns {Object} {valid: boolean, issues: Array}\n     */\n  validateCurrentView(map) {\n    const issues = [];\n    const center = map.getCenter().toArray();\n    const zoom = map.getZoom();\n\n    if (!this.isWithinBounds(center)) {\n      issues.push(`Center ${center} is outside bounds`);\n    }\n\n    if (!this.isWithinZoomLimits(zoom)) {\n      issues.push(`Zoom ${zoom} is outside limits [${this.minZoom}, ${this.maxZoom}]`);\n    }\n\n    return {\n      valid: issues.length === 0,\n      issues\n    };\n  }\n\n  /**\n     * Get safe bounds for animations, considering current constraints\n     * @param {Object} map - MapLibre map instance\n     * @returns {Object} Safe bounds object\n     */\n  getSafeBounds(map) {\n    if (!this.maxBounds) {\n      // If no constraints, use current viewport\n      return map.getBounds();\n    }\n\n    // Create bounds from constraints\n    const [[west, south], [east, north]] = this.maxBounds;\n\n    // Return as a bounds-like object\n    return {\n      getWest: () => west,\n      getEast: () => east,\n      getSouth: () => south,\n      getNorth: () => north,\n      getCenter: () => [(west + east) / 2, (south + north) / 2]\n    };\n  }\n\n  /**\n     * Wrap an animation function with constraints\n     * @param {Function} animationFn - Original animation function\n     * @returns {Function} Wrapped animation function that respects constraints\n     */\n  wrapAnimation(animationFn) {\n    return async (map, control) => {\n      // Store original methods\n      const originalFlyTo = map.flyTo.bind(map);\n      const originalEaseTo = map.easeTo.bind(map);\n      const originalJumpTo = map.jumpTo.bind(map);\n\n      // Override methods with constrained versions\n      map.flyTo = (options) => originalFlyTo(this.applyCameraConstraints(options));\n      map.easeTo = (options) => originalEaseTo(this.applyCameraConstraints(options));\n      map.jumpTo = (options) => originalJumpTo(this.applyCameraConstraints(options));\n\n      try {\n        // Run the original animation with constrained methods\n        await animationFn(map, control);\n      } finally {\n        // Restore original methods\n        map.flyTo = originalFlyTo;\n        map.easeTo = originalEaseTo;\n        map.jumpTo = originalJumpTo;\n      }\n    };\n  }\n}\n\n/**\n * Waypoint Helper Functions\n */\n\n/**\n * Fly to a waypoint with all its parameters\n * @param {Object} map - MapLibre map instance\n * @param {Object} waypoint - Waypoint object {center, zoom, bearing, pitch, duration, name}\n * @param {number} transitionDuration - Flight duration in milliseconds\n * @param {Object} options - {checkAbort, updateStatus}\n */\nasync function flyToWaypoint(map, waypoint, transitionDuration, { checkAbort, updateStatus } = {}) {\n  const wpName = waypoint.name || 'waypoint';\n\n  if (updateStatus) {\n    updateStatus(`Flying to ${wpName}...`);\n  }\n\n  // Build flyTo options with waypoint parameters\n  const flyToOptions = {\n    center: waypoint.center,\n    duration: transitionDuration,\n    essential: true\n  };\n\n  // Add optional parameters if defined\n  if (waypoint.zoom !== undefined) flyToOptions.zoom = waypoint.zoom;\n  if (waypoint.bearing !== undefined) flyToOptions.bearing = waypoint.bearing;\n  if (waypoint.pitch !== undefined) flyToOptions.pitch = waypoint.pitch;\n\n  // Handle zero duration case - use jumpTo instead of flyTo\n  if (transitionDuration === 0 || transitionDuration < 10) {\n    // Build jumpTo options (only include defined properties)\n    const jumpToOptions = { center: waypoint.center };\n    if (waypoint.zoom !== undefined) jumpToOptions.zoom = waypoint.zoom;\n    if (waypoint.bearing !== undefined) jumpToOptions.bearing = waypoint.bearing;\n    if (waypoint.pitch !== undefined) jumpToOptions.pitch = waypoint.pitch;\n\n    map.jumpTo(jumpToOptions);\n    // No need to wait for moveend with jumpTo - it's synchronous\n  } else {\n    map.flyTo(flyToOptions);\n    await map.once('moveend');\n  }\n\n  if (checkAbort) checkAbort();\n\n  // Pause at waypoint if duration is specified\n  if (waypoint.duration) {\n    if (updateStatus) {\n      updateStatus(`At ${wpName} (pausing ${waypoint.duration}ms)...`);\n    }\n    await sleep(waypoint.duration);\n    if (checkAbort) checkAbort();\n  }\n}\n\n/**\n * Create a tour plan from waypoints with calculated timings\n * Distributes total duration between transitions and pauses\n * @param {Array} waypoints - Array of waypoint objects\n * @param {number} totalDuration - Total duration in milliseconds\n * @returns {Array} Array of {waypoint, transitionDuration}\n */\nfunction createWaypointTour(waypoints, totalDuration) {\n  if (!waypoints || waypoints.length === 0) return [];\n\n  // Calculate total pause time from waypoint durations\n  const totalPauseTime = waypoints.reduce((sum, wp) => sum + (wp.duration || 0), 0);\n\n  // Remaining time for transitions\n  const transitionTime = Math.max(0, totalDuration - totalPauseTime);\n\n  // Time per transition (between waypoints)\n  const timePerTransition = waypoints.length > 0 ? transitionTime / waypoints.length : 0;\n\n  return waypoints.map(wp => ({\n    waypoint: wp,\n    transitionDuration: timePerTransition\n  }));\n}\n\n/**\n * Interpolate waypoints for geometric animations\n * Creates smooth path passing through waypoints\n * @param {Array} waypoints - Array of waypoint objects with center: [lng, lat]\n * @param {number} steps - Total number of points to generate (including waypoints)\n * @returns {Array} Array of [lng, lat] coordinates\n */\n// eslint-disable-next-line no-unused-vars\nfunction interpolateWaypoints(waypoints, steps) {\n  if (!waypoints || waypoints.length === 0) return [];\n  if (waypoints.length === 1) {\n    // Single waypoint, return it multiple times\n    return Array(steps).fill(waypoints[0].center);\n  }\n\n  const points = [];\n  const segmentSteps = Math.floor(steps / waypoints.length);\n\n  for (let i = 0; i < waypoints.length; i++) {\n    const start = waypoints[i].center;\n    const end = waypoints[(i + 1) % waypoints.length].center; // Loop back to first\n\n    for (let j = 0; j < segmentSteps; j++) {\n      const t = j / segmentSteps;\n      const lng = start[0] + (end[0] - start[0]) * t;\n      const lat = start[1] + (end[1] - start[1]) * t;\n      points.push([lng, lat]);\n    }\n  }\n\n  return points;\n}\n\n/**\n * Helper: Incremental 360¬∞ rotation that handles bearing normalization\n * MapLibre normalizes bearing to [-180, 180], so we need incremental steps\n *\n * @param {Object} map - MapLibre map instance\n * @param {number} duration - Total duration in milliseconds\n * @param {Object} options - Configuration options\n * @param {Function} options.checkAbort - Function to check for cancellation\n * @param {Function} options.updateStatus - Optional status update callback\n * @param {number} options.degreesPerStep - Degrees per rotation step (default: 2)\n * @param {number|Object} options.pitch - Pitch configuration:\n *   - number: Fixed pitch during rotation (e.g., 50)\n *   - {from: number, to: number}: Progressive pitch change (e.g., {from: 0, to: 75})\n *   - undefined: Keep current pitch\n * @param {Function} options.onStep - Optional callback(currentBearing, progress) called at each step\n */\n// @ts-ignore - Default empty object is fine, properties are destructured with defaults\nconst rotatePanorama360 = async (map, duration, { checkAbort, degreesPerStep = 2, pitch, onStep } = {}) => {\n  // Helper to increment bearing and handle -180/180 wrap\n  const nextBearing = (current, increment) => {\n    let next = current + increment;\n    if (next > 180) {\n      // Wrap from 180 to -180\n      next = -180 + (next - 180);\n    }\n    return next;\n  };\n\n  const totalSteps = 360 / degreesPerStep; // e.g., 180 steps for 2¬∞ increments\n  const msPerStep = duration / totalSteps;\n  let currentBearing = map.getBearing();\n\n  for (let i = 0; i < totalSteps; i++) {\n    // Check abort periodically\n    if (i % 20 === 0 && checkAbort) checkAbort();\n\n    currentBearing = nextBearing(currentBearing, degreesPerStep);\n\n    // Progress is 0.0 to 1.0\n    const progress = i / totalSteps;\n\n    // Calculate pitch for this step if configured\n    let currentPitch;\n    if (pitch !== undefined) {\n      if (typeof pitch === 'number') {\n        // Fixed pitch\n        currentPitch = pitch;\n      } else if (pitch.from !== undefined && pitch.to !== undefined) {\n        // Progressive pitch\n        currentPitch = pitch.from + (pitch.to - pitch.from) * progress;\n      }\n    }\n\n    // Build easeTo options\n    let easToOptions = {\n      bearing: currentBearing,\n      duration: msPerStep,\n      essential: true,\n      easing: t => t\n    };\n\n    // Add pitch if defined\n    if (currentPitch !== undefined) {\n      easToOptions.pitch = currentPitch;\n    }\n\n    // Call custom onStep callback if provided\n    if (onStep) {\n      const stepResult = onStep(currentBearing, progress);\n      // If onStep returns an object, merge it with easeTo options\n      if (stepResult && typeof stepResult === 'object') {\n        easToOptions = { ...easToOptions, ...stepResult };\n      }\n    }\n\n    map.easeTo(easToOptions);\n    await map.once('moveend');\n  }\n\n  if (checkAbort) checkAbort();\n};\n\n// Cache capabilities per map instance to avoid repeated detection\nconst capabilitiesCache = new WeakMap();\n\nexport class AnimationDirector {\n  constructor(map) {\n    this.map = map;\n    this.capabilities = this._detectCapabilities();\n  }\n\n  /**\n     * Detect what features are available in the current map\n     * Results are cached per map instance\n     * @param {boolean} forceDetect - If true, bypass cache and re-detect\n     */\n  _detectCapabilities(forceDetect = false) {\n    // Check cache first (unless forced)\n    if (!forceDetect && capabilitiesCache.has(this.map)) {\n      return capabilitiesCache.get(this.map);\n    }\n\n    const caps = {\n      // Visual features\n      hasTerrain: false,\n      hasHillshade: false,\n      has3DBuildings: false,\n      hasRasterLayers: false,\n      hasVectorLayers: false,\n\n      // Transportation networks\n      hasRoads: false,\n      hasRailways: false,\n      hasWaterways: false,\n      hasWater: false,\n\n      // Places and labels\n      hasPlaces: false,\n      hasLanduse: false,\n\n      // Resources\n      hasGlyphs: false,\n      hasSprites: false,\n\n      // Metadata\n      bounds: null,\n      center: this.map.getCenter(),\n      zoom: this.map.getZoom(),\n      maxZoomData: 14, // Default conservative value\n      /** @type {string | null} */\n      style: null,\n\n      // Vector source info for helper map (by feature type)\n      vectorSources: {\n        roads: { sourceId: null, sourceLayer: null },\n        railways: { sourceId: null, sourceLayer: null },\n        waterways: { sourceId: null, sourceLayer: null }\n      }\n    };\n\n    // Get style and sources\n    const style = this.map.getStyle();\n    const sources = style?.sources || {};\n\n    // Check for terrain support (raster-dem source)\n    Object.values(sources).forEach(source => {\n      if (source.type === 'raster-dem') {\n        caps.hasTerrain = true;\n      }\n\n      // Get max zoom from sources\n      if (source.maxzoom && source.maxzoom > caps.maxZoomData) {\n        caps.maxZoomData = source.maxzoom;\n      }\n    });\n\n    // Check for glyphs (fonts)\n    if (style?.glyphs) {\n      caps.hasGlyphs = true;\n    }\n\n    // Check for sprites\n    if (style?.sprite) {\n      caps.hasSprites = true;\n    }\n\n    // Collect all source-layers used in the style (especially from OpenMapTiles)\n    const sourceLayers = new Set();\n    const layers = style?.layers || [];\n\n    layers.forEach(layer => {\n      const layerId = layer.id.toLowerCase();\n      const sourceLayer = layer['source-layer'];\n\n      // Collect source-layers for OpenMapTiles detection\n      if (sourceLayer) {\n        sourceLayers.add(sourceLayer.toLowerCase());\n      }\n\n      // Visual features detection (layer-based)\n      if (layerId.includes('hillshad') || layer.type === 'hillshade') {\n        caps.hasHillshade = true;\n      }\n      if (layerId.includes('building') && layer.type === 'fill-extrusion') {\n        caps.has3DBuildings = true;\n      }\n      if (layer.type === 'raster') {\n        caps.hasRasterLayers = true;\n      }\n      if (['fill', 'line', 'symbol', 'circle'].includes(layer.type)) {\n        caps.hasVectorLayers = true;\n      }\n    });\n\n    // Detect capabilities from vector tile source-layers\n    // Supports: OpenMapTiles (https://openmaptiles.org/schema/)\n    //           Mapbox Streets v8+ (https://docs.mapbox.com/data/tilesets/reference/mapbox-streets-v8/)\n    console.log('üó∫Ô∏è Found source-layers:', Array.from(sourceLayers));\n\n    // === TRANSPORTATION (Roads & Railways) ===\n    // OpenMapTiles: 'transportation' contains BOTH roads and railways (differentiated by class)\n    // Mapbox Streets: 'road' contains BOTH roads and railways (class: major_rail, minor_rail, service_rail)\n    if (sourceLayers.has('transportation') || sourceLayers.has('road')) {\n      caps.hasRoads = true;\n      caps.hasRailways = true;\n\n      // Find which vector source contains transportation/road layer\n      for (const layer of layers) {\n        const sourceLayer = layer['source-layer'];\n        if (sourceLayer === 'transportation' || sourceLayer === 'road') {\n          const sourceId = layer.source;\n          const source = sources[sourceId];\n          if (source && source.type === 'vector') {\n            // Roads and railways share the same source in these schemas\n            caps.vectorSources.roads.sourceId = sourceId;\n            caps.vectorSources.roads.sourceLayer = sourceLayer;\n            caps.vectorSources.railways.sourceId = sourceId;\n            caps.vectorSources.railways.sourceLayer = sourceLayer;\n            break;\n          }\n        }\n      }\n    }\n\n    // === WATERWAYS ===\n    // Both schemas: 'waterway' (rivers, canals, streams)\n    if (sourceLayers.has('waterway')) {\n      caps.hasWaterways = true;\n\n      // Find which vector source contains waterway layer\n      for (const layer of layers) {\n        const sourceLayer = layer['source-layer'];\n        if (sourceLayer === 'waterway') {\n          const sourceId = layer.source;\n          const source = sources[sourceId];\n          if (source && source.type === 'vector') {\n            caps.vectorSources.waterways.sourceId = sourceId;\n            caps.vectorSources.waterways.sourceLayer = sourceLayer;\n            break;\n          }\n        }\n      }\n    }\n\n    // === WATER BODIES ===\n    // Both schemas: 'water' (lakes, oceans, reservoirs)\n    if (sourceLayers.has('water')) {\n      caps.hasWater = true;\n    }\n\n    // === PLACES ===\n    // OpenMapTiles: 'place' (cities, towns, villages)\n    // Mapbox Streets: 'place_label' (with _label suffix)\n    if (sourceLayers.has('place') || sourceLayers.has('place_label')) {\n      caps.hasPlaces = true;\n    }\n\n    // === LANDUSE ===\n    // OpenMapTiles: 'landuse' or 'landcover'\n    // Mapbox Streets: 'landuse'\n    if (sourceLayers.has('landuse') || sourceLayers.has('landcover')) {\n      caps.hasLanduse = true;\n    }\n\n    // === BUILDINGS ===\n    // Both schemas: 'building'\n    if (sourceLayers.has('building')) {\n      // Already detected via fill-extrusion above\n    }\n\n    // Get bounds\n    try {\n      caps.bounds = this.map.getBounds();\n    } catch (e) {\n      // Map might not have bounds yet\n    }\n\n    // Detect style type\n    const styleUrl = style?.sprite || '';\n    if (styleUrl.includes('satellite') || styleUrl.includes('aerial')) {\n      caps.style = 'satellite';\n    } else if (styleUrl.includes('outdoors') || styleUrl.includes('terrain')) {\n      caps.style = 'outdoors';\n    } else if (styleUrl.includes('dark')) {\n      caps.style = 'dark';\n    } else {\n      caps.style = 'standard';\n    }\n\n    console.log('üîç Detected capabilities:', caps);\n\n    // Store in cache\n    capabilitiesCache.set(this.map, caps);\n\n    return caps;\n  }\n\n  /**\n     * Position helper map ahead of current position based on bearing and search radius\n     * Uses bbox/fitBounds to ensure ALL tiles in the search area are loaded\n     * @param {Object} map2 - The helper map instance\n     * @param {Array} currentPos - Current [lng, lat] position\n     * @param {number} bearing - Current bearing in degrees\n     * @param {number} searchRadius - Search radius in degrees\n     * @returns {Promise} Resolves after map is repositioned and tiles loaded\n     */\n  static async _positionHelperMapAhead(map2, currentPos, bearing, searchRadius) {\n    try {\n      // Calculate position ahead based on bearing and searchRadius\n      const radians = (bearing * Math.PI) / 180;\n      const aheadLng = currentPos[0] + searchRadius * Math.sin(radians);\n      const aheadLat = currentPos[1] + searchRadius * Math.cos(radians);\n\n      // Create bbox that covers both current position and ahead position\n      // Plus extra margin to ensure we have tiles for nearby/lateral roads at intersections\n      const margin = searchRadius * 0.5; // 50% extra margin to catch adjacent roads\n\n      const minLng = Math.min(currentPos[0], aheadLng) - margin;\n      const maxLng = Math.max(currentPos[0], aheadLng) + margin;\n      const minLat = Math.min(currentPos[1], aheadLat) - margin;\n      const maxLat = Math.max(currentPos[1], aheadLat) + margin;\n\n      // Use fitBounds to ensure ALL tiles in this area are loaded\n      // This is more reliable than jumpTo(center) which might not load all tiles\n      map2.fitBounds([[minLng, minLat], [maxLng, maxLat]], {\n        linear: true, // No animation\n        padding: 0, // No padding needed for invisible map\n        duration: 0 // Instant\n      });\n\n      // Wait for tiles to load and index\n      // This is critical - without this delay, queries may return empty\n      await new Promise(resolve => setTimeout(resolve, 200));\n\n      console.log(`[HelperMap] Positioned map2 with bbox: [${minLng.toFixed(6)}, ${minLat.toFixed(6)}] to [${maxLng.toFixed(6)}, ${maxLat.toFixed(6)}]`);\n    } catch (error) {\n      console.error('[HelperMap] Failed to position helper map:', error);\n    }\n  }\n\n  /**\n     * Find interesting points on the map\n     */\n  async _findInterestingPoints() {\n    const points = [];\n    const bounds = this.map.getBounds();\n\n    if (!bounds) return points;\n\n    const ne = bounds.getNorthEast();\n    const sw = bounds.getSouthWest();\n    const center = bounds.getCenter();\n\n    // Add corners and center\n    points.push(\n      center,\n      ne,\n      sw,\n      [ne.lng, sw.lat],\n      [sw.lng, ne.lat]\n    );\n\n    // If we have terrain, try to find high points\n    if (this.capabilities.hasTerrain) {\n      // Sample points to find elevation variations\n      const samples = 5;\n      for (let i = 0; i < samples; i++) {\n        for (let j = 0; j < samples; j++) {\n          const lng = sw.lng + (ne.lng - sw.lng) * (i / samples);\n          const lat = sw.lat + (ne.lat - sw.lat) * (j / samples);\n          points.push([lng, lat]);\n        }\n      }\n    }\n\n    return points;\n  }\n\n  /**\n     * Generate an adaptive animation based on map content\n     */\n  createAdaptiveAnimation(control, options = {}) {\n    const duration = options.duration || 30000;\n\n    // Return { setup, animation } format like other animations\n    return {\n      setup: null, // No setup needed\n      animation: async (map, control) => {\n        const { updateStatus, checkAbort } = control;\n        console.log('üé¨ Creating adaptive animation for', duration, 'ms');\n\n        const animations = [];\n\n        // 1. Opening shot - establish the scene\n        animations.push(this._createOpeningShot());\n\n        // 2. Feature showcase based on capabilities\n        if (this.capabilities.hasTerrain) {\n          animations.push(this._createTerrainShowcase());\n        }\n\n        if (this.capabilities.has3DBuildings) {\n          animations.push(this._createBuildingFlythrough());\n        }\n\n        // 3. Exploration sequence\n        animations.push(this._createExplorationSequence());\n\n        // 4. Cinematic movements\n        animations.push(this._createCinematicSequence());\n\n        // 5. Closing shot\n        animations.push(this._createClosingShot());\n\n        // Execute animations\n        const timePerAnimation = duration / animations.length;\n\n        for (const animation of animations) {\n          await animation(control, timePerAnimation);\n          checkAbort(); // Check between major animation segments\n        }\n\n        updateStatus('‚úÖ Animation complete!');\n      }\n    };\n  }\n\n  /**\n     * Opening shot - zoom out to show the full area\n     */\n  _createOpeningShot() {\n    return async (control, duration) => {\n      const { updateStatus, checkAbort } = control;\n      updateStatus('üåç Opening shot...');\n\n      const currentZoom = this.map.getZoom();\n      const overviewZoom = Math.max(currentZoom - 4, 1);\n\n      // Reset to neutral position\n      this.map.easeTo({\n        zoom: overviewZoom,\n        pitch: 0,\n        bearing: 0,\n        duration: duration * 0.6,\n        essential: true\n      });\n      await this.map.once('moveend');\n      checkAbort();\n\n      // Gentle zoom in\n      this.map.easeTo({\n        zoom: currentZoom - 2,\n        duration: duration * 0.4,\n        essential: true\n      });\n      await this.map.once('moveend');\n      checkAbort();\n    };\n  }\n\n  /**\n     * Terrain showcase - if terrain is available\n     */\n  _createTerrainShowcase() {\n    return async (control, duration) => {\n      const { updateStatus, checkAbort } = control;\n      updateStatus('üèîÔ∏è Mountain vista...');\n\n      // Enable terrain if not already\n      if (!this.map.getTerrain()) {\n        const sources = this.map.getStyle()?.sources || {};\n        const terrainSource = Object.keys(sources).find(s =>\n          sources[s].type === 'raster-dem'\n        );\n\n        if (terrainSource) {\n          this.map.setTerrain({\n            source: terrainSource,\n            exaggeration: 1.5\n          });\n          await sleep(500);\n          checkAbort();\n        }\n      }\n\n      // Find highest visible area (simplified - just move to corners)\n      const points = await this._findInterestingPoints();\n\n      for (let i = 0; i < Math.min(3, points.length); i++) {\n        this.map.flyTo({\n          center: points[i],\n          zoom: 14,\n          pitch: 75,\n          bearing: i * 120,\n          duration: duration / 3,\n          essential: true\n        });\n        await this.map.once('moveend');\n        checkAbort();\n      }\n    };\n  }\n\n  /**\n     * Building flythrough - for urban areas with 3D buildings\n     */\n  _createBuildingFlythrough() {\n    return async (control, duration) => {\n      const { updateStatus, checkAbort } = control;\n      updateStatus('üè¢ City flythrough...');\n\n      // Tilt for dramatic effect\n      this.map.easeTo({\n        pitch: 60,\n        zoom: this.map.getZoom() + 1,\n        duration: duration * 0.3,\n        essential: true\n      });\n      await this.map.once('moveend');\n      checkAbort();\n\n      // Sweep through the city\n      this.map.easeTo({\n        bearing: this.map.getBearing() + 180,\n        duration: duration * 0.7,\n        essential: true\n      });\n      await this.map.once('moveend');\n      checkAbort();\n    };\n  }\n\n  /**\n     * Exploration sequence - move through interesting points\n     */\n  _createExplorationSequence() {\n    return async (control, duration) => {\n      const { updateStatus, checkAbort } = control;\n      updateStatus('üîç Exploring area...');\n\n      const bounds = this.map.getBounds();\n      if (!bounds) {\n        await sleep(duration);\n        return;\n      }\n\n      const ne = bounds.getNorthEast();\n      const sw = bounds.getSouthWest();\n      const center = bounds.getCenter();\n\n      // Create a path through the map\n      const path = [\n        center,\n        [ne.lng * 0.7 + sw.lng * 0.3, ne.lat * 0.7 + sw.lat * 0.3],\n        [ne.lng * 0.3 + sw.lng * 0.7, ne.lat * 0.3 + sw.lat * 0.7],\n        center\n      ];\n\n      const stepDuration = duration / path.length;\n\n      for (let i = 0; i < path.length; i++) {\n        this.map.flyTo({\n          center: path[i],\n          zoom: this.map.getZoom() + (i % 2 ? 0.5 : -0.5),\n          bearing: i * 45,\n          pitch: 20 + (i * 10),\n          duration: stepDuration,\n          essential: true\n        });\n        await this.map.once('moveend');\n        checkAbort();\n      }\n    };\n  }\n\n  /**\n     * Cinematic sequence - smooth camera movements\n     */\n  _createCinematicSequence() {\n    return async (control, duration) => {\n      const { updateStatus, checkAbort } = control;\n      updateStatus('üé¨ Cinematic view...');\n\n      // Orbit around center\n      const startBearing = this.map.getBearing();\n\n      this.map.easeTo({\n        bearing: startBearing + 360,\n        duration: duration * 0.6,\n        essential: true,\n        easing: t => t * (2 - t) // Smooth easing\n      });\n      await this.map.once('moveend');\n      checkAbort();\n\n      // Tilt shift effect\n      this.map.easeTo({\n        pitch: 45,\n        zoom: this.map.getZoom() + 1,\n        duration: duration * 0.2,\n        essential: true\n      });\n      await this.map.once('moveend');\n      checkAbort();\n\n      this.map.easeTo({\n        pitch: 0,\n        zoom: this.map.getZoom() - 1,\n        duration: duration * 0.2,\n        essential: true\n      });\n      await this.map.once('moveend');\n      checkAbort();\n    };\n  }\n\n  /**\n     * Closing shot - return to a nice overview\n     */\n  _createClosingShot() {\n    return async (control, duration) => {\n      const { updateStatus, checkAbort } = control;\n      updateStatus('üé• Closing shot...');\n\n      const initialState = {\n        center: this.capabilities.center,\n        zoom: this.capabilities.zoom,\n        bearing: 0,\n        pitch: 0\n      };\n\n      // Dramatic pullback\n      this.map.flyTo({\n        ...initialState,\n        zoom: initialState.zoom - 2,\n        pitch: 30,\n        bearing: -30,\n        duration: duration * 0.7,\n        essential: true\n      });\n      await this.map.once('moveend');\n      checkAbort();\n\n      // Final position\n      this.map.easeTo({\n        ...initialState,\n        duration: duration * 0.3,\n        essential: true\n      });\n      await this.map.once('moveend');\n      checkAbort();\n    };\n  }\n}\n\n/**\n * Extract minimal style for secondary query-only map\n * Includes ALL detected vector sources for roads, railways, waterways\n * @param {Object} map - MapLibre map instance\n * @param {boolean} forceDetect - If true, bypass cache and re-detect capabilities\n * @returns {Object|null} { vectorSources, style } or null if not found\n */\nfunction _extractMinimalStyle(map, forceDetect = false) {\n  try {\n    const style = map.getStyle();\n    if (!style) {\n      console.warn('[HelperMap] No style found');\n      return null;\n    }\n\n    // Use cached capabilities to get ALL vector source info\n    let caps = forceDetect ? null : capabilitiesCache.get(map);\n    if (!caps) {\n      // Detect capabilities if not in cache yet or if forced\n      const director = new AnimationDirector(map);\n      if (forceDetect) {\n        caps = director._detectCapabilities(true);\n      } else {\n        caps = director.capabilities;\n      }\n    }\n\n    const sources = style.sources || {};\n\n    // Collect all unique vector sources\n    const uniqueSources = new Set();\n    Object.values(caps.vectorSources).forEach(info => {\n      if (info.sourceId) uniqueSources.add(info.sourceId);\n    });\n\n    if (uniqueSources.size === 0) {\n      console.warn('[HelperMap] No vector sources found for roads/railways/waterways');\n      console.warn('[HelperMap] Available source-layers:', Array.from(new Set(\n        (style.layers || [])\n          .filter(l => l['source-layer'])\n          .map(l => l['source-layer'])\n      )));\n      return null;\n    }\n\n    // Create minimal style with ALL detected vector sources\n    const minimalSources = {};\n    uniqueSources.forEach(sourceId => {\n      const vectorSource = sources[sourceId];\n      if (vectorSource && vectorSource.type === 'vector') {\n        minimalSources[sourceId] = {\n          type: vectorSource.type,\n          ...(vectorSource.tiles && { tiles: vectorSource.tiles }),\n          ...(vectorSource.url && { url: vectorSource.url }),\n          ...(vectorSource.minzoom !== undefined && { minzoom: vectorSource.minzoom }),\n          ...(vectorSource.maxzoom !== undefined && { maxzoom: vectorSource.maxzoom }),\n          ...(vectorSource.attribution && { attribution: vectorSource.attribution }),\n          ...(vectorSource.bounds && { bounds: vectorSource.bounds })\n        };\n      }\n    });\n\n    console.log(`[HelperMap] Created minimal style with ${Object.keys(minimalSources).length} vector source(s):`, Object.keys(minimalSources));\n    console.log('[HelperMap] Available features:', {\n      roads: caps.vectorSources.roads.sourceLayer || 'none',\n      railways: caps.vectorSources.railways.sourceLayer || 'none',\n      waterways: caps.vectorSources.waterways.sourceLayer || 'none'\n    });\n\n    // Create minimal invisible layers to force MapLibre to load features\n    // Without layers, querySourceFeatures returns nothing even if sources are defined!\n    const minimalLayers = [];\n\n    // Add invisible layer for roads/transportation\n    // NOTE: NO visibility:none! MapLibre only loads tiles for visible layers!\n    if (caps.vectorSources.roads.sourceId && caps.vectorSources.roads.sourceLayer) {\n      minimalLayers.push({\n        id: 'helper-roads',\n        type: 'line',\n        source: caps.vectorSources.roads.sourceId,\n        'source-layer': caps.vectorSources.roads.sourceLayer,\n        paint: {\n          'line-opacity': 0,\n          'line-width': 0\n        }\n      });\n    }\n\n    // Add invisible layer for railways\n    if (caps.vectorSources.railways.sourceId && caps.vectorSources.railways.sourceLayer) {\n      minimalLayers.push({\n        id: 'helper-railways',\n        type: 'line',\n        source: caps.vectorSources.railways.sourceId,\n        'source-layer': caps.vectorSources.railways.sourceLayer,\n        paint: {\n          'line-opacity': 0,\n          'line-width': 0\n        }\n      });\n    }\n\n    // Add invisible layer for waterways\n    if (caps.vectorSources.waterways.sourceId && caps.vectorSources.waterways.sourceLayer) {\n      minimalLayers.push({\n        id: 'helper-waterways',\n        type: 'line',\n        source: caps.vectorSources.waterways.sourceId,\n        'source-layer': caps.vectorSources.waterways.sourceLayer,\n        paint: {\n          'line-opacity': 0,\n          'line-width': 0\n        }\n      });\n    }\n\n    console.log(`[HelperMap] Created ${minimalLayers.length} invisible layer(s) to force feature loading`);\n\n    const minimalStyle = {\n      version: 8,\n      sources: minimalSources,\n      layers: minimalLayers, // Minimal invisible layers to force feature loading\n      glyphs: style.glyphs,\n      sprite: style.sprite,\n      id: style.id || 'helper-map'\n    };\n\n    console.log('[HelperMap] Minimal style.json:', minimalStyle);\n\n    return {\n      vectorSources: caps.vectorSources, // Return all source/layer mappings\n      style: minimalStyle\n    };\n  } catch (error) {\n    console.error('[HelperMap] Failed to extract minimal style:', error);\n    return null;\n  }\n}\n\n/**\n * Find a nearby road when no connected segment is found\n * Searches in 8 cardinal directions (N, NE, E, SE, S, SW, W, NW)\n * @param {Array} fromPoint - [lng, lat] current endpoint\n * @param {number} currentBearing - Current direction of travel\n * @param {Set} usedSegmentIds - Already used road IDs\n * @param {Array} roads2 - Available roads to search from map2\n * @param {Object} options - Search options\n * @param {string|Array} options.prefer - Road class(es) to prefer (e.g., 'motorway', ['motorway', 'trunk', 'primary'])\n * @param {number} options.searchRadius - Search radius in degrees (default: 0.002 ‚âà 200m)\n * @returns {Object|null} Best road found or null\n */\nfunction _findNearbyRoadInCardinalDirections(fromPoint, currentBearing, usedSegmentIds, roads2, options = {}) {\n  const { prefer = null, searchRadius = 0.002 } = options;\n  const preferredClasses = prefer ? (Array.isArray(prefer) ? prefer : [prefer]) : [];\n\n  console.log('[RoadSearch] Searching nearby roads in cardinal directions...' +\n        (preferredClasses.length ? ` (prefer: ${preferredClasses.join(', ')})` : ''));\n\n  // Search in 8 cardinal directions (N, NE, E, SE, S, SW, W, NW)\n  const searchDirections = CARDINAL_DIRECTIONS_8.map(d => d.angle);\n\n  // Convert searchRadius from degrees to km for distance comparison\n  // At equator: 1 degree ‚âà 111 km\n  const searchRadiusKm = searchRadius * 111;\n\n  let bestRoad = null;\n  let bestScore = Infinity;\n\n  for (const direction of searchDirections) {\n    // Calculate search point in this direction\n    const radians = (direction * Math.PI) / 180;\n    const searchLng = fromPoint[0] + searchRadius * Math.sin(radians);\n    const searchLat = fromPoint[1] + searchRadius * Math.cos(radians);\n\n    // Find closest road to this search point\n    for (const road of roads2) {\n      if (!road.geometry || !road.geometry.coordinates) continue;\n      if (usedSegmentIds.has(road.id)) continue;\n\n      const roadStart = road.geometry.coordinates[0];\n      const roadEnd = road.geometry.coordinates[road.geometry.coordinates.length - 1];\n\n      // Calculate distance from ACTUAL position (fromPoint), not from search point\n      // This gives us the real distance we'll jump\n      const distStartFromActual = calculateDistance(fromPoint[0], fromPoint[1], roadStart[0], roadStart[1]);\n      const distEndFromActual = calculateDistance(fromPoint[0], fromPoint[1], roadEnd[0], roadEnd[1]);\n      const actualDist = Math.min(distStartFromActual, distEndFromActual);\n\n      // Also calculate distance from search point for scoring\n      const distStart = calculateDistance(searchLng, searchLat, roadStart[0], roadStart[1]);\n      const distEnd = calculateDistance(searchLng, searchLat, roadEnd[0], roadEnd[1]);\n      const minDist = Math.min(distStart, distEnd);\n\n      if (minDist > searchRadiusKm) continue; // Too far from search point\n\n      // Prefer roads in forward direction\n      const bearingDiff = Math.abs(normalizeBearingDiff(direction - currentBearing));\n\n      // Base score = distance + bearing penalty\n      let score = minDist + (bearingDiff / 180) * 0.001;\n\n      // Bonus if this road class is preferred\n      const roadClass = road.properties?.class || 'unknown';\n      if (preferredClasses.length > 0 && preferredClasses.includes(roadClass)) {\n        score *= 0.5; // 50% bonus for preferred road types\n        console.log(`[RoadSearch]   ‚ú® Found preferred ${roadClass} at ${direction}¬∞ (bonus applied)`);\n      }\n\n      if (score < bestScore) {\n        bestScore = score;\n        const shouldReverse = distEndFromActual < distStartFromActual;\n        bestRoad = {\n          road,\n          coords: shouldReverse ? [...road.geometry.coordinates].reverse() : road.geometry.coordinates,\n          reversed: shouldReverse,\n          distance: actualDist, // Store ACTUAL distance from current position\n          direction,\n          bearingDiff\n        };\n      }\n    }\n  }\n\n  // Safety check: reject roads that are too far away to avoid huge jumps\n  // Maximum 250m jump for road following (allows rural roads while preventing huge jumps)\n  // Using actualDist which is calculated from fromPoint\n  const maxJumpDistanceKm = 0.250; // 250m maximum (allows sparse rural roads)\n  if (bestRoad && bestRoad.distance > maxJumpDistanceKm) {\n    console.log(`[RoadSearch] ‚ö†Ô∏è Found road but too far (${(bestRoad.distance * 1000).toFixed(0)}m > 250m) - rejecting to avoid huge jump`);\n    bestRoad = null;\n  }\n\n  if (bestRoad) {\n    const roadClass = bestRoad.road.properties?.class || 'unknown';\n    const isPreferred = preferredClasses.includes(roadClass);\n    // bestRoad.distance is in km, convert to meters for display\n    console.log(`[RoadSearch] üîç Found ${isPreferred ? '‚ú® preferred ' : ''}${roadClass} at ${bestRoad.direction}¬∞ ` +\n            `(${(bestRoad.distance * 1000).toFixed(0)}m away, bearing Œî${bestRoad.bearingDiff.toFixed(1)}¬∞)`);\n  } else {\n    // searchRadiusKm is in km, convert to meters for display\n    console.log(`[RoadSearch] No roads found within ${(searchRadiusKm * 1000).toFixed(0)}m in any direction`);\n  }\n\n  return bestRoad;\n}\n\n/**\n * Preset animations that work on any map\n */\nexport const PresetAnimations = {\n  /**\n     * Simple 360 orbit\n     */\n  orbit360: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 10000;\n    const waypoints = options.waypoints || null;\n\n    // If waypoints exist, position map to show all of them\n    if (waypoints) {\n      const optimalView = getOptimalViewForWaypoints(map, waypoints);\n      if (optimalView) {\n        updateStatus('üîÑ Positioning to show all waypoints...');\n        map.jumpTo({\n          center: optimalView.center,\n          zoom: optimalView.zoom\n        });\n        await sleep(500); // Brief pause for map to settle\n      }\n    }\n\n    updateStatus('üîÑ 360¬∞ orbit...');\n    const startBearing = map.getBearing();\n\n    map.easeTo({\n      bearing: startBearing + 360,\n      duration,\n      essential: true,\n      easing: t => t // Linear\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Zoom pulse\n     */\n  zoomPulse: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 5000;\n    const waypoints = options.waypoints || null;\n\n    // If waypoints exist, position map to show all of them\n    if (waypoints) {\n      const optimalView = getOptimalViewForWaypoints(map, waypoints);\n      if (optimalView) {\n        updateStatus('üîç Positioning to show all waypoints...');\n        map.jumpTo({\n          center: optimalView.center,\n          zoom: optimalView.zoom\n        });\n        await sleep(500);\n      }\n    }\n\n    updateStatus('üîç Zoom pulse...');\n    const startZoom = map.getZoom();\n\n    map.easeTo({\n      zoom: startZoom + 2,\n      duration: duration / 2,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    map.easeTo({\n      zoom: startZoom,\n      duration: duration / 2,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Figure-8 movement\n     */\n  figure8: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 15000;\n    const waypoints = options.waypoints || null;\n\n    // If waypoints exist, position map to show all of them\n    if (waypoints) {\n      const optimalView = getOptimalViewForWaypoints(map, waypoints);\n      if (optimalView) {\n        updateStatus('‚àû Positioning to show all waypoints...');\n        map.jumpTo({\n          center: optimalView.center,\n          zoom: optimalView.zoom\n        });\n        await sleep(500);\n      }\n    }\n\n    updateStatus('‚àû Figure-8 pattern...');\n    const center = map.getCenter();\n    const bounds = map.getBounds();\n\n    if (!bounds) return;\n\n    const ne = bounds.getNorthEast();\n    const sw = bounds.getSouthWest();\n    const width = ne.lng - sw.lng;\n    const height = ne.lat - sw.lat;\n\n    const points = [\n      [center.lng + width * 0.2, center.lat],\n      [center.lng + width * 0.2, center.lat + height * 0.2],\n      [center.lng, center.lat],\n      [center.lng - width * 0.2, center.lat - height * 0.2],\n      [center.lng - width * 0.2, center.lat],\n      [center.lng, center.lat]\n    ];\n\n    for (const point of points) {\n      map.flyTo({\n        center: point,\n        duration: duration / points.length,\n        essential: true\n      });\n      await map.once('moveend');\n      checkAbort();\n    }\n  },\n\n  /**\n     * Spiral zoom\n     */\n  spiralZoom: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 12000;\n\n    updateStatus('üåÄ Spiral zoom...');\n    const steps = 8;\n    const startZoom = map.getZoom();\n\n    for (let i = 0; i < steps; i++) {\n      map.easeTo({\n        bearing: map.getBearing() + 45,\n        zoom: startZoom + (i / steps) * 2,\n        pitch: (i / steps) * 45,\n        duration: duration / steps,\n        essential: true\n      });\n      await map.once('moveend');\n      checkAbort();\n    }\n\n    // Return to start\n    map.flyTo({\n      zoom: startZoom,\n      bearing: 0,\n      pitch: 0,\n      duration: duration / 4,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Neighborhood exploration - Perfect for real estate use cases\n     * Shows the immediate area, nearby amenities, and context\n     */\n  neighborhood: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 25000;\n\n    updateStatus('üèòÔ∏è Exploring neighborhood...');\n    const center = map.getCenter();\n    const startZoom = map.getZoom();\n    const startBearing = map.getBearing();\n    const startPitch = map.getPitch();\n\n    // 1. Wide context view - show the broader area\n    updateStatus('üó∫Ô∏è Showing area context...');\n    map.flyTo({\n      center,\n      zoom: Math.max(startZoom - 3, 10),\n      bearing: 0,\n      pitch: 0,\n      duration: duration * 0.15,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // 2. Zoom to neighborhood level with rotation\n    updateStatus('üèòÔ∏è Neighborhood overview...');\n    map.flyTo({\n      center,\n      zoom: Math.min(startZoom, 14),\n      bearing: 0,\n      pitch: 35,\n      duration: duration * 0.15,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // 3. 360¬∞ rotation to show all around\n    updateStatus('üîÑ Scanning surroundings...');\n    map.easeTo({\n      bearing: 360,\n      duration: duration * 0.25,\n      essential: true,\n      easing: t => t // Linear rotation\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // 4. Closer view of immediate vicinity\n    updateStatus('üîç Examining nearby area...');\n    map.flyTo({\n      zoom: Math.min(startZoom + 1, 16),\n      bearing: 0,\n      pitch: 45,\n      duration: duration * 0.15,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // 5. Smooth 180¬∞ pan to show both sides\n    map.easeTo({\n      bearing: 180,\n      duration: duration * 0.15,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // 6. Return to original view\n    updateStatus('üìç Returning to property...');\n    map.flyTo({\n      center,\n      zoom: startZoom,\n      bearing: startBearing,\n      pitch: startPitch,\n      duration: duration * 0.15,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Property showcase - Focused presentation of a specific location\n     */\n  propertyShowcase: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 20000;\n\n    updateStatus('üè° Property showcase...');\n    const center = map.getCenter();\n    const startZoom = map.getZoom();\n\n    // 1. Dramatic reveal from above\n    updateStatus('üé¨ Opening shot...');\n    map.flyTo({\n      center,\n      zoom: startZoom - 2,\n      bearing: 0,\n      pitch: 60,\n      duration: duration * 0.2,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // 2. Zoom to property level\n    updateStatus('üè† Focusing on property...');\n    map.flyTo({\n      zoom: Math.min(startZoom + 1, 17),\n      bearing: -45,\n      pitch: 55,\n      duration: duration * 0.2,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // 3. Orbit around the property (4 angles)\n    updateStatus('üì∏ Viewing from all angles...');\n    const angles = [0, 90, 180, 270];\n    for (const angle of angles) {\n      map.easeTo({\n        bearing: angle,\n        duration: duration * 0.12,\n        essential: true\n      });\n      await map.once('moveend');\n      checkAbort();\n    }\n\n    // 4. Final wide shot\n    updateStatus('üåÖ Final view...');\n    map.flyTo({\n      zoom: startZoom,\n      bearing: 0,\n      pitch: 30,\n      duration: duration * 0.16,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Panoramic sweep - Smooth cinematic panorama\n     */\n  panorama: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 15000;\n    updateStatus('üì∑ Panoramic view...');\n    const startPitch = map.getPitch();\n\n    // 360¬∞ panorama with bell-curve pitch: tilt up, rotate, tilt back down\n    updateStatus('üé• Sweeping panorama...');\n    // @ts-ignore - degreesPerStep and pitch have defaults\n    await rotatePanorama360(map, duration, {\n      checkAbort,\n      updateStatus,\n      onStep: (currentBearing, progress) => {\n        // Create a smooth up-then-down pitch curve (bell curve)\n        // Peak at 50% progress (50¬∞), then return to startPitch at 100%\n        const pitchCurve = progress < 0.5\n          ? startPitch + (50 - startPitch) * (progress * 2) // 0‚Üí0.5: rise to 50¬∞\n          : 50 - (50 - startPitch) * ((progress - 0.5) * 2); // 0.5‚Üí1.0: back to start\n\n        return { pitch: pitchCurve };\n      }\n    });\n  },\n\n  /**\n     * Explore around - Radial exploration pattern\n     */\n  exploreAround: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 20000;\n    updateStatus('üß≠ Exploring surroundings...');\n    const center = map.getCenter();\n    const bounds = map.getBounds();\n\n    if (!bounds) return;\n\n    const ne = bounds.getNorthEast();\n    const sw = bounds.getSouthWest();\n    const offsetLng = (ne.lng - sw.lng) * 0.25;\n    const offsetLat = (ne.lat - sw.lat) * 0.25;\n\n    // Define cardinal directions\n    const points = [\n      { pos: [center.lng, center.lat + offsetLat], name: 'North' },\n      { pos: [center.lng + offsetLng, center.lat], name: 'East' },\n      { pos: [center.lng, center.lat - offsetLat], name: 'South' },\n      { pos: [center.lng - offsetLng, center.lat], name: 'West' }\n    ];\n\n    const stepDuration = duration / (points.length + 1);\n\n    // Visit each direction\n    for (const point of points) {\n      updateStatus(`üß≠ Checking ${point.name}...`);\n      map.flyTo({\n        center: point.pos,\n        duration: stepDuration * 0.8,\n        essential: true\n      });\n      await map.once('moveend');\n      checkAbort();\n      await sleep(stepDuration * 0.2); // Brief pause\n      checkAbort();\n    }\n\n    // Return to center\n    updateStatus('üéØ Returning to center...');\n    map.flyTo({\n      center,\n      duration: stepDuration,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Aerial Sweep - Seamless looping aerial view\n     * 1. Vertical rise, 2. Tilt to 85¬∞, 3. 360¬∞ panorama, 4. Final 15%: descend + level\n     * Perfect for hero headers (loops seamlessly)\n     */\n  aerialSweep: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 15000;\n    updateStatus('üöÅ Aerial sweep...');\n\n    // Save initial state for perfect loop\n    const initialZoom = map.getZoom();\n    const initialPitch = map.getPitch();\n\n    // Terrain-aware zoom calculation\n    // If 3D terrain is loaded, adjust zoom to avoid mountain collisions\n    let terrainSafeZoom = 3; // Default minimum zoom\n\n    if (map.getTerrain && map.getTerrain()) {\n      // Sample terrain elevation at multiple points around the view\n      // This prevents collisions during 360¬∞ rotations over mountains\n      const center = map.getCenter();\n      const bounds = map.getBounds();\n      const latSpan = bounds.getNorth() - bounds.getSouth();\n      const lngSpan = bounds.getEast() - bounds.getWest();\n\n      // Sample 9 points in a grid (center + 8 around it)\n      const samplePoints = [\n        center, // Center\n        { lng: center.lng, lat: center.lat + latSpan * 0.3 }, // North\n        { lng: center.lng, lat: center.lat - latSpan * 0.3 }, // South\n        { lng: center.lng + lngSpan * 0.3, lat: center.lat }, // East\n        { lng: center.lng - lngSpan * 0.3, lat: center.lat }, // West\n        { lng: center.lng + lngSpan * 0.25, lat: center.lat + latSpan * 0.25 }, // NE\n        { lng: center.lng - lngSpan * 0.25, lat: center.lat + latSpan * 0.25 }, // NW\n        { lng: center.lng + lngSpan * 0.25, lat: center.lat - latSpan * 0.25 }, // SE\n        { lng: center.lng - lngSpan * 0.25, lat: center.lat - latSpan * 0.25 } // SW\n      ];\n\n      // Find maximum elevation among all sample points\n      let maxElevation = 0;\n      for (const point of samplePoints) {\n        const elevation = map.queryTerrainElevation(point);\n        if (elevation !== null && elevation > maxElevation) {\n          maxElevation = elevation;\n        }\n      }\n\n      if (maxElevation > 0) {\n        // Heuristic: Higher elevation needs higher zoom level to stay above terrain\n        // At pitch 75¬∞, we need more clearance\n        // Rough formula: elevation in meters ‚Üí minimum zoom adjustment\n        const elevationKm = maxElevation / 1000;\n        const safetyMargin = 2.0; // Increased safety margin (was 1.5)\n        terrainSafeZoom = Math.max(3, Math.log2(elevationKm + 1) * 2 + safetyMargin);\n        console.log(`üèîÔ∏è Terrain detected: max elevation ${maxElevation.toFixed(0)}m ‚Üí safe zoom ${terrainSafeZoom.toFixed(1)}`);\n      }\n    }\n\n    // Phase 1 (15%): Vertical zoom out (keep current pitch)\n    updateStatus('‚¨ÜÔ∏è Rising...');\n    const zoomOutLevel = Math.max(initialZoom - 4, terrainSafeZoom);\n    map.easeTo({\n      zoom: zoomOutLevel,\n      duration: duration * 0.15,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // Phase 2 (10%): Tilt to 75¬∞ pitch\n    updateStatus('üìê Tilting view...');\n    map.easeTo({\n      pitch: 75,\n      duration: duration * 0.10,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // Phase 3 (75%): 360¬∞ panoramic sweep\n    // First 85% at fixed pitch 75¬∞, final 15% descends back to initial state\n    updateStatus('üåç 360¬∞ panorama...');\n    // @ts-ignore - degreesPerStep has default\n    await rotatePanorama360(map, duration * 0.75, {\n      checkAbort,\n      updateStatus,\n      pitch: 75, // Fixed pitch during first 85% of rotation\n      onStep: (currentBearing, progress) => {\n        // After 85% of panorama, start descending and leveling\n        if (progress >= 0.85) {\n          // Map 0.85-1.0 progress to 0.0-1.0 descent progress\n          const descentProgress = (progress - 0.85) / 0.15;\n\n          // Interpolate zoom back to initial\n          const currentZoom = zoomOutLevel + (initialZoom - zoomOutLevel) * descentProgress;\n\n          // Interpolate pitch back to initial\n          const currentPitch = 75 + (initialPitch - 75) * descentProgress;\n\n          // Update status when descent starts\n          if (descentProgress > 0.1) {\n            updateStatus('üåÄ Descending spiral...');\n          }\n\n          // Override pitch from default and add zoom\n          return {\n            zoom: currentZoom,\n            pitch: currentPitch\n          };\n        }\n        // First 85%: pitch is handled by the pitch parameter above\n      }\n    });\n  },\n\n  /**\n     * Drone Shot - Realistic drone flight simulation\n     * Spiraling ascent, 360¬∞ survey, spiraling descent\n     */\n  droneShot: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 20000;\n    updateStatus('üõ∏ Drone takeoff...');\n\n    const initialZoom = map.getZoom();\n    const initialPitch = map.getPitch();\n    const initialBearing = map.getBearing();\n\n    // Phase 1 (30%): Spiral ascent - rise while rotating\n    updateStatus('üìà Ascending spiral...');\n    const ascentSteps = 90; // Quarter rotation during ascent\n    const ascentDuration = duration * 0.30;\n    const msPerAscentStep = ascentDuration / ascentSteps;\n    const zoomOutLevel = Math.max(initialZoom - 5, 2);\n\n    for (let i = 0; i < ascentSteps; i++) {\n      if (i % 15 === 0) checkAbort();\n\n      const progress = i / ascentSteps;\n      const currentZoom = initialZoom - (initialZoom - zoomOutLevel) * progress;\n      const currentPitch = initialPitch + (65 - initialPitch) * progress;\n      const bearingIncrement = 90 * progress;\n\n      map.easeTo({\n        zoom: currentZoom,\n        pitch: currentPitch,\n        bearing: initialBearing + bearingIncrement,\n        duration: msPerAscentStep,\n        essential: true,\n        easing: t => t\n      });\n\n      await map.once('moveend');\n    }\n    checkAbort();\n\n    // Phase 2 (40%): High-altitude 360¬∞ survey\n    updateStatus('üåç 360¬∞ survey...');\n    // @ts-ignore - degreesPerStep and onStep have defaults\n    await rotatePanorama360(map, duration * 0.40, {\n      checkAbort,\n      updateStatus,\n      pitch: 65\n    });\n\n    // Phase 3 (30%): Spiral descent - descend while rotating back\n    updateStatus('üìâ Landing approach...');\n    const descentSteps = 90;\n    const descentDuration = duration * 0.30;\n    const msPerDescentStep = descentDuration / descentSteps;\n    const currentBearing = map.getBearing();\n\n    for (let i = 0; i < descentSteps; i++) {\n      if (i % 15 === 0) checkAbort();\n\n      const progress = i / descentSteps;\n      const currentZoom = zoomOutLevel + (initialZoom - zoomOutLevel) * progress;\n      const currentPitch = 65 - (65 - initialPitch) * progress;\n      const bearingProgress = currentBearing - 90 * progress;\n\n      map.easeTo({\n        zoom: currentZoom,\n        pitch: currentPitch,\n        bearing: bearingProgress,\n        duration: msPerDescentStep,\n        essential: true,\n        easing: t => t\n      });\n\n      await map.once('moveend');\n    }\n    checkAbort();\n  },\n\n  /**\n     * Orbit Zoom - Rotate while progressively zooming in\n     * Creates a vortex/spiral effect focusing on center\n     */\n  orbitZoom: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 15000;\n    updateStatus('üåÄ Orbit zoom...');\n\n    const initialZoom = map.getZoom();\n    const targetZoom = Math.min(initialZoom + 4, 18);\n\n    // @ts-ignore - degreesPerStep has default\n    await rotatePanorama360(map, duration, {\n      checkAbort,\n      updateStatus,\n      pitch: 45, // Moderate tilt for dramatic effect\n      onStep: (bearing, progress) => {\n        // Zoom in progressively during rotation\n        const currentZoom = initialZoom + (targetZoom - initialZoom) * progress;\n        return { zoom: currentZoom };\n      }\n    });\n  },\n\n  /**\n     * Wave Motion - Rotation with oscillating pitch like ocean waves\n     * Creates hypnotic, fluid movement\n     */\n  waveMotion: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 18000;\n    updateStatus('üåä Wave motion...');\n\n    const basePitch = map.getPitch();\n    const waveFrequency = 3; // Number of wave cycles during rotation\n\n    // @ts-ignore - degreesPerStep and pitch have defaults\n    await rotatePanorama360(map, duration, {\n      checkAbort,\n      updateStatus,\n      onStep: (bearing, progress) => {\n        // Sine wave: oscillates between basePitch and basePitch+60\n        const waveProgress = progress * waveFrequency * Math.PI * 2;\n        const pitchWave = basePitch + 30 + Math.sin(waveProgress) * 30;\n        return { pitch: pitchWave };\n      }\n    });\n  },\n\n  /**\n     * Pendulum - Swinging back and forth with variable pitch\n     * Like a pendulum slowing at the extremes\n     */\n  pendulum: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 15000;\n    updateStatus('‚è±Ô∏è Pendulum motion...');\n\n    const initialBearing = map.getBearing();\n    const initialPitch = map.getPitch();\n    const swingAngle = 120; // Total swing arc (¬±60¬∞)\n    const swings = 3; // Number of back-and-forth cycles\n\n    for (let swing = 0; swing < swings; swing++) {\n      checkAbort();\n\n      // Swing right\n      updateStatus(`‚è±Ô∏è Swing ${swing + 1}/${swings}...`);\n      map.easeTo({\n        bearing: initialBearing + swingAngle / 2,\n        pitch: 55, // Higher pitch at extremes\n        duration: duration / (swings * 2),\n        essential: true,\n        easing: t => 1 - Math.cos(t * Math.PI / 2) // Ease out (slower at end)\n      });\n      await map.once('moveend');\n      checkAbort();\n\n      // Brief pause at extreme\n      await sleep(200);\n\n      // Swing left\n      map.easeTo({\n        bearing: initialBearing - swingAngle / 2,\n        pitch: 55,\n        duration: duration / (swings * 2),\n        essential: true,\n        easing: t => 1 - Math.cos(t * Math.PI / 2)\n      });\n      await map.once('moveend');\n      checkAbort();\n\n      // Brief pause at extreme\n      await sleep(200);\n    }\n\n    // Return to center\n    updateStatus('‚è±Ô∏è Settling...');\n    map.easeTo({\n      bearing: initialBearing,\n      pitch: initialPitch,\n      duration: duration * 0.15,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Spotlight Scan - Rotation with rhythmic zoom pulse\n     * Like a radar or searchlight scanning the area\n     */\n  spotlightScan: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 15000;\n    updateStatus('üî¶ Spotlight scan...');\n\n    const initialZoom = map.getZoom();\n    const pulseFrequency = 4; // Number of zoom pulses during rotation\n    const pulseIntensity = 1.5; // Zoom variation amplitude\n\n    // @ts-ignore - degreesPerStep has default\n    await rotatePanorama360(map, duration, {\n      checkAbort,\n      updateStatus,\n      pitch: 50,\n      onStep: (bearing, progress) => {\n        // Pulse zoom in/out rhythmically\n        const pulseProgress = progress * pulseFrequency * Math.PI * 2;\n        const zoomPulse = initialZoom + Math.sin(pulseProgress) * pulseIntensity;\n        return { zoom: zoomPulse };\n      }\n    });\n  },\n\n  /**\n     * Butterfly (Figure-8 3D) - Enhanced figure-8 with pitch variation\n     * Creates a smooth, flowing 3D path\n     */\n  butterfly: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 20000;\n    updateStatus('ü¶ã Butterfly pattern...');\n\n    const center = map.getCenter();\n    const bounds = map.getBounds();\n\n    if (!bounds) return;\n\n    const ne = bounds.getNorthEast();\n    const sw = bounds.getSouthWest();\n    const width = ne.lng - sw.lng;\n    const height = ne.lat - sw.lat;\n\n    // Define figure-8 path with 16 points for smooth curve\n    const points = [];\n    for (let i = 0; i < 16; i++) {\n      const t = (i / 16) * Math.PI * 2;\n      // Lissajous curve (figure-8): x = sin(t), y = sin(2t)/2\n      const x = Math.sin(t) * width * 0.25;\n      const y = Math.sin(2 * t) / 2 * height * 0.25;\n\n      points.push({\n        pos: [center.lng + x, center.lat + y],\n        // Pitch varies with vertical position (higher y = higher pitch)\n        pitch: 20 + Math.abs(y / (height * 0.25)) * 40,\n        // Bearing follows the curve direction\n        bearing: (t * 180 / Math.PI) % 360\n      });\n    }\n\n    const stepDuration = duration / points.length;\n\n    for (const point of points) {\n      map.flyTo({\n        center: point.pos,\n        pitch: point.pitch,\n        bearing: point.bearing,\n        duration: stepDuration * 0.9,\n        essential: true,\n        easing: t => t // Linear for smooth continuous motion\n      });\n      await map.once('moveend');\n      checkAbort();\n    }\n\n    // Return to center\n    updateStatus('ü¶ã Returning...');\n    map.flyTo({\n      center,\n      pitch: map.getPitch(),\n      bearing: 0,\n      duration: stepDuration * 2,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Waypoint Tour - Visit each waypoint sequentially\n     * Perfect for guided tours and storytelling\n     */\n  waypointTour: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 30000;\n    const waypoints = options.waypoints || null;\n\n    // Extract waypoint array from GeoJSON if needed\n    let waypointArray = [];\n    if (waypoints) {\n      if (waypoints.type === 'FeatureCollection' && waypoints.features) {\n        waypointArray = waypoints.features.map(feature => ({\n          center: feature.geometry.coordinates,\n          zoom: feature.properties.zoom,\n          bearing: feature.properties.bearing,\n          pitch: feature.properties.pitch,\n          duration: feature.properties.duration,\n          name: feature.properties.name\n        }));\n      } else if (Array.isArray(waypoints)) {\n        waypointArray = waypoints;\n      }\n    }\n\n    if (waypointArray.length === 0) {\n      updateStatus('‚ö†Ô∏è No waypoints defined for tour');\n      await sleep(2000);\n      return;\n    }\n\n    updateStatus(`üéØ Starting tour of ${waypointArray.length} waypoints...`);\n\n    // Create tour plan with timing\n    const tour = createWaypointTour(waypointArray, duration);\n\n    // Visit each waypoint\n    for (let i = 0; i < tour.length; i++) {\n      const { waypoint, transitionDuration } = tour[i];\n\n      await flyToWaypoint(map, waypoint, transitionDuration, {\n        checkAbort,\n        updateStatus: (msg) => updateStatus(`üìç ${i + 1}/${tour.length}: ${msg}`)\n      });\n    }\n\n    updateStatus('‚úÖ Tour complete!');\n  },\n\n  /**\n     * Terrain Following - Low-altitude flight following terrain contours\n     * Maintains constant height above ground while rotating 360¬∞\n     * Perfect for mountainous areas with 3D terrain\n     */\n  terrainFollowing: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 20000;\n    updateStatus('üöÅ Terrain following flight...');\n\n    // Check if terrain is available\n    if (!map.getTerrain || !map.getTerrain()) {\n      updateStatus('‚ö†Ô∏è No 3D terrain - using standard rotation');\n      // Fallback to simple rotation\n      await PresetAnimations.orbit360(map, { updateStatus, checkAbort }, options);\n      return;\n    }\n\n    const initialBearing = map.getBearing();\n    const initialPitch = map.getPitch();\n    const center = map.getCenter();\n\n    // Set cinematic pitch for terrain following\n    const targetPitch = 60;\n    updateStatus('üìê Setting terrain view angle...');\n    map.easeTo({\n      pitch: targetPitch,\n      duration: 1000,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n\n    // Configuration\n    const steps = 120; // 3¬∞ per step for smooth motion\n    const degreesPerStep = 360 / steps;\n    const msPerStep = (duration * 0.95) / steps; // 95% for rotation, 5% for return\n\n    // Smoothing buffer for zoom values\n    const zoomBuffer = [];\n    const bufferSize = 5;\n\n    updateStatus('üèîÔ∏è Following terrain contours...');\n\n    // Main rotation loop with terrain following\n    for (let step = 0; step < steps; step++) {\n      if (step % 20 === 0) checkAbort();\n\n      const progress = step / steps;\n      const currentBearing = initialBearing + (degreesPerStep * step);\n\n      // Sample terrain elevation at current position and ahead\n\n      // Sample terrain directly AT the center point (where camera is positioned)\n      // Not ahead - the center IS the camera position\n      const centerElevation = map.queryTerrainElevation(center);\n\n      // Calculate target zoom based on terrain elevation AT camera position\n      let targetZoom = map.getZoom();\n      if (centerElevation !== null && centerElevation >= 0) {\n        // LOW-ALTITUDE FLIGHT: We want to stay VERY close to the ground\n        // Zoom 14 = ~1km altitude, Zoom 15 = ~500m, Zoom 16 = ~250m, Zoom 17 = ~125m\n        // Formula: Higher zoom = closer to ground\n        // We add terrain elevation to maintain constant height above ground\n\n        const elevationKm = centerElevation / 1000;\n\n        // Base zoom for very low flight, then adjust down based on terrain elevation\n        // Higher terrain = lower zoom (zoom out) to maintain clearance\n        const baseZoom = 17; // Very close to ground\n        const elevationAdjustment = elevationKm * 1.5; // Zoom out ~1.5 levels per km of elevation\n\n        targetZoom = Math.max(10, baseZoom - elevationAdjustment);\n      }\n\n      // Add to smoothing buffer\n      zoomBuffer.push(targetZoom);\n      if (zoomBuffer.length > bufferSize) {\n        zoomBuffer.shift();\n      }\n\n      // Use smoothed zoom (average of buffer)\n      const smoothedZoom = zoomBuffer.reduce((a, b) => a + b, 0) / zoomBuffer.length;\n\n      // Update camera\n      map.easeTo({\n        bearing: currentBearing,\n        zoom: smoothedZoom,\n        pitch: targetPitch,\n        duration: msPerStep,\n        essential: true,\n        easing: t => t // Linear for smooth continuous motion\n      });\n\n      await map.once('moveend');\n\n      // Update status every 25%\n      if (step % 30 === 0) {\n        const percent = Math.round(progress * 100);\n        updateStatus(`üèîÔ∏è Terrain following: ${percent}%`);\n      }\n    }\n\n    // Return to initial state smoothly\n    updateStatus('üéØ Returning to start...');\n    map.easeTo({\n      bearing: initialBearing,\n      pitch: initialPitch,\n      duration: duration * 0.05,\n      essential: true\n    });\n    await map.once('moveend');\n    checkAbort();\n  },\n\n  /**\n     * Setup function for road following - returns { setup, animation }\n     * This allows setup (positioning) to run before recording starts\n     */\n  _followPathWithVehicleSetup: (map, control, options = {}, vehicleProfile) => {\n    // Default transport classes (roads) if not specified\n    const transportClasses = vehicleProfile.transportClasses || [\n      'motorway', 'trunk', 'primary', 'secondary', 'tertiary',\n      'minor', 'service', 'track', 'path'\n    ];\n\n    // Variables shared between setup and animation phases\n    let map2 = null;\n    let div2 = null;\n    let sourceId2 = 'openmaptiles'; // Default fallback\n    let sourceLayer2 = 'transportation'; // Default fallback\n    const debugFeatures = []; // Track followed segments for visualization\n\n    return {\n      setup: async (map, control, { updateStatus, checkAbort }) => {\n        // This is the setup phase - runs BEFORE recording starts\n        // 1. Create helper map for queries (invisible, positioned ahead)\n        // 2. Find nearest path (road/rail/etc) at current position\n        // 3. Position camera at start\n\n        // Try to create helper map for better road queries\n        console.log('[HelperMap] Creating invisible query map...');\n        try {\n          // Extract minimal style from main map\n          const styleInfo = _extractMinimalStyle(map);\n\n          if (styleInfo && styleInfo.vectorSources.roads.sourceId) {\n            // Use roads source for vehicle navigation\n            sourceId2 = styleInfo.vectorSources.roads.sourceId;\n            sourceLayer2 = styleInfo.vectorSources.roads.sourceLayer;\n\n            // Remove any existing helper div\n            const existingDiv = document.getElementById('maplibre-query-helper');\n            if (existingDiv && existingDiv.parentNode) {\n              existingDiv.parentNode.removeChild(existingDiv);\n            }\n\n            // Create invisible div with SAME dimensions as main map\n            const mainContainer = map.getContainer();\n            const width = mainContainer.offsetWidth;\n            const height = mainContainer.offsetHeight;\n\n            div2 = document.createElement('div');\n            div2.id = 'maplibre-query-helper';\n            div2.style.cssText = `\n                            position: absolute;\n                            top: -9999px;\n                            left: -9999px;\n                            width: ${width}px;\n                            height: ${height}px;\n                            visibility: hidden;\n                            pointer-events: none;\n                        `;\n            document.body.appendChild(div2);\n\n            console.log('styleInfo', styleInfo);\n\n            // Create helper map with minimal style\n            map2 = new maplibregl.Map({\n              container: div2,\n              style: styleInfo.style,\n              center: map.getCenter(),\n              zoom: 15, // Optimal zoom for vector tile data (14-18 range)\n              bearing: map.getBearing(),\n              pitch: 0,\n              preserveDrawingBuffer: false,\n              interactive: false\n            });\n\n            // Wait for helper map to load\n            await new Promise(resolve => map2.once('load', resolve));\n            console.log('[HelperMap] Helper map ready for queries');\n          } else {\n            console.warn('[HelperMap] Could not extract style, will use main map');\n          }\n        } catch (error) {\n          console.error('[HelperMap] Failed to create helper map:', error);\n          // Cleanup on error\n          if (map2) {\n            try { map2.remove(); } catch (e) {}\n            map2 = null;\n          }\n          if (div2 && div2.parentNode) {\n            div2.parentNode.removeChild(div2);\n            div2 = null;\n          }\n        }\n\n        const pathType = vehicleProfile.transportClasses ? 'path' : 'road';\n        updateStatus(`üõ£Ô∏è Finding nearest ${pathType}...`);\n\n        // Check if helper map is available\n        if (!map2) {\n          console.error('[Setup] Helper map not available - cannot query roads');\n          return;\n        }\n\n        // Check if source exists\n        const source = map.getSource(sourceId2);\n        if (!source) {\n          console.log(`[Setup] No vector source '${sourceId2}' found - skipping path positioning`);\n          return;\n        }\n\n        const initialBearing = map.getBearing();\n        const center = map.getCenter();\n\n        // Use map2 for all road queries\n        // Query roads around current position at current zoom\n        const availableRoads2 = map2.querySourceFeatures(sourceId2, {\n          sourceLayer: sourceLayer2,\n          filter: [\n            'all',\n            ['==', ['geometry-type'], 'LineString'],\n            ['in', ['get', 'class'], ['literal', transportClasses]]\n          ]\n        });\n\n        console.log(`[Setup] Found ${availableRoads2 ? availableRoads2.length : 0} road segments nearby`);\n\n        if (!availableRoads2 || availableRoads2.length === 0) {\n          console.log('[Setup] No roads found');\n          return;\n        }\n\n        // Find closest road using directional ray intersection\n        // Create 8 virtual rays in cardinal directions from center\n        updateStatus('üîç Detecting road by intersection...');\n\n        const rayLength = 0.002; // ~200m at equator\n\n        let closestIntersection = null;\n        let minIntersectionDistance = Infinity;\n\n        // Test each ray direction\n        for (const dir of CARDINAL_DIRECTIONS_8) {\n          const angleRad = (dir.angle * Math.PI) / 180;\n          const rayEnd = [\n            center.lng + rayLength * Math.sin(angleRad),\n            center.lat + rayLength * Math.cos(angleRad)\n          ];\n          const rayStart = [center.lng, center.lat];\n\n          // Check intersection with all road segments\n          for (const road of availableRoads2) {\n            if (!road.geometry || !road.geometry.coordinates) continue;\n            const coords = road.geometry.coordinates;\n\n            for (let i = 1; i < coords.length; i++) {\n              const roadSegStart = coords[i - 1];\n              const roadSegEnd = coords[i];\n\n              const dist = segmentIntersection(rayStart, rayEnd, roadSegStart, roadSegEnd);\n              if (dist !== null && dist < minIntersectionDistance) {\n                minIntersectionDistance = dist;\n                closestIntersection = {\n                  road,\n                  direction: dir.name,\n                  distance: dist,\n                  roadClass: road.properties?.class || 'unknown'\n                };\n              }\n            }\n          }\n        }\n\n        if (!closestIntersection) {\n          console.log('[Setup] No road intersection found with rays - falling back to closest point');\n          // Fallback: simple closest point search\n          let closestRoad = null;\n          let minDistance = Infinity;\n          for (const road of availableRoads2) {\n            if (!road.geometry || !road.geometry.coordinates) continue;\n            for (const coord of road.geometry.coordinates) {\n              const [lng, lat] = coord;\n              const dx = lng - center.lng;\n              const dy = lat - center.lat;\n              const distance = Math.sqrt(dx * dx + dy * dy);\n              if (distance < minDistance) {\n                minDistance = distance;\n                closestRoad = road;\n              }\n            }\n          }\n          if (!closestRoad) {\n            console.log('[Setup] No valid road found');\n            return;\n          }\n          closestIntersection = {\n            road: closestRoad,\n            direction: 'fallback',\n            distance: minDistance,\n            roadClass: closestRoad.properties?.class || 'unknown'\n          };\n        }\n\n        const closestRoad = closestIntersection.road;\n        const detectedClass = closestIntersection.roadClass;\n\n        console.log(`[Setup] Found road by intersection: ${detectedClass} at ${(closestIntersection.distance * 111000).toFixed(1)}m (direction: ${closestIntersection.direction})`);\n\n        // Keep ALL road classes for fluid exploration in dense areas\n        // This allows transitions between minor ‚Üí primary ‚Üí tertiary etc.\n        console.log(`[Setup] Keeping all ${availableRoads2.length} road segments (all classes) for fluid exploration`);\n\n        let roadCoords = closestRoad.geometry.coordinates;\n\n        // Determine road direction based on user's view\n        if (roadCoords.length >= 2) {\n          const [firstLng, firstLat] = roadCoords[0];\n          const [lastLng, lastLat] = roadCoords[roadCoords.length - 1];\n          const roadBearing = calculateBearing(firstLng, firstLat, lastLng, lastLat);\n          const bearingDiff = normalizeBearingDiff(roadBearing - initialBearing);\n          if (Math.abs(bearingDiff) > 90) {\n            roadCoords = [...roadCoords].reverse();\n          }\n        }\n\n        // No longer need to simulate path - segments will be loaded dynamically during animation\n\n        // Position camera at road start\n        updateStatus(`${vehicleProfile.icon} Positioning at road start...`);\n\n        const targetPitch = vehicleProfile.pitch;\n        map.easeTo({ pitch: targetPitch, duration: 1000, essential: true });\n        await map.once('moveend');\n        checkAbort();\n\n        const [firstLng, firstLat] = roadCoords[0];\n        const firstPoint = { lng: firstLng, lat: firstLat };\n\n        let initialPositionBearing = initialBearing;\n        if (roadCoords.length >= 2) {\n          const [secondLng, secondLat] = roadCoords[1];\n          initialPositionBearing = calculateBearing(firstLng, firstLat, secondLng, secondLat);\n        }\n\n        const vehicleAltitude = vehicleProfile.altitude || 10;\n        const cameraZoom = vehicleProfile.zoom || Math.max(10, Math.min(22, 22 - Math.log2(vehicleAltitude)));\n\n        map.easeTo({\n          center: firstPoint,\n          bearing: initialPositionBearing,\n          zoom: cameraZoom,\n          pitch: targetPitch,\n          duration: 2000,\n          essential: true,\n          easing: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\n          noMoveStart: true,\n          delayEndEvents: 0\n        });\n        await map.once('moveend');\n        checkAbort();\n\n        // Wait for map to be completely idle (all rendering finished)\n        await map.once('idle');\n        checkAbort();\n\n        console.log('[Setup] Initial position set, ready to record');\n      },\n      animation: async (map, control) => {\n        // This is the actual animation - runs AFTER recording starts\n        // Segments will be loaded dynamically during animation\n        // Pass helper map and source info via options\n        const animOptions = {\n          ...options,\n          map2,\n          div2,\n          sourceId2,\n          sourceLayer2,\n          debugFeatures\n        };\n        await PresetAnimations._followPathWithVehicle(map, control, animOptions, vehicleProfile);\n      },\n      supportsExploration: vehicleProfile.supportsExploration\n    };\n  },\n\n  /**\n     * Generic road following with vehicle profile\n     * Used by all vehicle-specific animations (car, plane, helicopter, drone, bird)\n     * Segments are loaded dynamically during animation at current zoom level\n     */\n  _followPathWithVehicle: async (map, { updateStatus, checkAbort }, options = {}, vehicleProfile) => {\n    const duration = options.duration || 20000;\n    updateStatus('üõ£Ô∏è Finding nearest road...');\n\n    // Debug: Check state of options.map2\n    console.log('[HelperMap] Debug - options.map2:', options.map2);\n    console.log('[HelperMap] Debug - typeof options.map2:', typeof options.map2);\n\n    // Create helper map if not already created (for Explore mode)\n    if (!options.map2) {\n      console.log('[HelperMap] Creating invisible query map...');\n      try {\n        const styleInfo = _extractMinimalStyle(map);\n\n        if (!styleInfo) {\n          console.error('[HelperMap] Failed to extract style info from main map');\n        } else if (!styleInfo.vectorSources.roads.sourceId) {\n          console.error('[HelperMap] No roads source found in style');\n          console.error('[HelperMap] Available sources:', styleInfo.vectorSources);\n        }\n\n        if (styleInfo && styleInfo.vectorSources.roads.sourceId) {\n          options.sourceId2 = styleInfo.vectorSources.roads.sourceId;\n          options.sourceLayer2 = styleInfo.vectorSources.roads.sourceLayer;\n\n          // Remove any existing helper div\n          const existingDiv = document.getElementById('maplibre-query-helper');\n          if (existingDiv && existingDiv.parentNode) {\n            existingDiv.parentNode.removeChild(existingDiv);\n          }\n\n          // Create invisible div\n          const mainContainer = map.getContainer();\n          const width = mainContainer.offsetWidth;\n          const height = mainContainer.offsetHeight;\n\n          options.div2 = document.createElement('div');\n          options.div2.id = 'maplibre-query-helper';\n          options.div2.style.cssText = `\n                        position: absolute;\n                        top: -9999px;\n                        left: -9999px;\n                        width: ${width}px;\n                        height: ${height}px;\n                        visibility: hidden;\n                        pointer-events: none;\n                    `;\n          document.body.appendChild(options.div2);\n\n          // Create helper map\n          options.map2 = new maplibregl.Map({\n            container: options.div2,\n            style: styleInfo.style,\n            center: map.getCenter(),\n            zoom: 18,\n            bearing: map.getBearing(),\n            pitch: 0,\n            interactive: false\n          });\n\n          await new Promise(resolve => options.map2.once('load', resolve));\n          console.log('[HelperMap] Helper map ready for queries');\n\n          // Create GeoJSON visualization layer\n          console.log('[Debug] Creating visualization layer for followed segments...');\n          try {\n            const debugSourceId = 'drone-followed-segments';\n            const debugLayerId = 'drone-followed-segments-layer';\n\n            // Remove existing source/layer if any\n            if (map.getLayer(debugLayerId)) {\n              map.removeLayer(debugLayerId);\n            }\n            if (map.getSource(debugSourceId)) {\n              map.removeSource(debugSourceId);\n            }\n\n            // Add empty GeoJSON source\n            map.addSource(debugSourceId, {\n              type: 'geojson',\n              data: {\n                type: 'FeatureCollection',\n                features: []\n              }\n            });\n\n            // Add line layer (magenta, 4px wide)\n            map.addLayer({\n              id: debugLayerId,\n              type: 'line',\n              source: debugSourceId,\n              layout: {\n                'line-join': 'round',\n                'line-cap': 'round'\n              },\n              paint: {\n                'line-color': '#FF00FF', // Magenta\n                'line-width': 4,\n                'line-opacity': 0.8\n              }\n            });\n\n            console.log('[Debug] Visualization layer created successfully');\n          } catch (layerError) {\n            console.warn('[Debug] Could not create visualization layer:', layerError);\n          }\n        }\n      } catch (error) {\n        console.error('[HelperMap] Failed to create helper map:', error);\n      }\n    }\n\n    // Initialize debug features array if not exists\n    if (!options.debugFeatures) {\n      options.debugFeatures = [];\n    }\n\n    // Extract map2 and source info from options\n    const map2 = options.map2;\n    const sourceId2 = options.sourceId2 || 'openmaptiles';\n    const sourceLayer2 = options.sourceLayer2 || 'transportation';\n\n    // Check if map2 exists\n    if (!map2) {\n      console.error('[Animation] map2 is not available - cannot query roads');\n      updateStatus('‚ö†Ô∏è Helper map not available - using terrain following');\n      await PresetAnimations.terrainFollowing(map, { updateStatus, checkAbort }, options);\n      return;\n    }\n\n    // Check if source exists\n    const source = map.getSource(sourceId2);\n    if (!source) {\n      updateStatus('‚ö†Ô∏è No vector source - using terrain following');\n      // Cleanup helper map and debug layer before fallback\n      cleanupMap2AndDebugLayer(options, map);\n      await PresetAnimations.terrainFollowing(map, { updateStatus, checkAbort }, options);\n      return;\n    }\n\n    const initialBearing = map.getBearing();\n    const center = map.getCenter();\n\n    // Query roads around current position to find initial segment\n    const roads2 = map2.querySourceFeatures(sourceId2, {\n      sourceLayer: sourceLayer2,\n      filter: ROAD_QUERY_FILTER\n    });\n\n    if (!roads2 || roads2.length === 0) {\n      updateStatus('‚ö†Ô∏è No roads found - using terrain following');\n      // Cleanup helper map and debug layer before fallback\n      cleanupMap2AndDebugLayer(options, map);\n      await PresetAnimations.terrainFollowing(map, { updateStatus, checkAbort }, options);\n      return;\n    }\n\n    // Find closest road to center\n    let closestRoad = null;\n    let minDistance = Infinity;\n\n    for (const road of roads2) {\n      if (!road.geometry || !road.geometry.coordinates) continue;\n\n      // Check distance to first point of each road segment\n      for (const coord of road.geometry.coordinates) {\n        const [lng, lat] = coord;\n        const dx = lng - center.lng;\n        const dy = lat - center.lat;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestRoad = road;\n        }\n      }\n    }\n\n    if (!closestRoad) {\n      updateStatus('‚ö†Ô∏è No valid road found - using terrain following');\n      // Cleanup helper map and debug layer before fallback\n      cleanupMap2AndDebugLayer(options, map);\n      await PresetAnimations.terrainFollowing(map, { updateStatus, checkAbort }, options);\n      return;\n    }\n\n    let roadCoords = closestRoad.geometry.coordinates;\n    const roadClass = closestRoad.properties?.class || 'road';\n\n    // Determine road direction based on user's initial map orientation\n    // If the road naturally goes in the opposite direction to where the user is looking,\n    // reverse it so the animation follows the user's intended direction\n    if (roadCoords.length >= 2) {\n      const [firstLng, firstLat] = roadCoords[0];\n      const [lastLng, lastLat] = roadCoords[roadCoords.length - 1];\n      const roadBearing = calculateBearing(firstLng, firstLat, lastLng, lastLat);\n\n      // Calculate the angular difference between road direction and user's view\n      // Normalize to [-180, 180] range\n      const bearingDiff = normalizeBearingDiff(roadBearing - initialBearing);\n\n      // If the difference is > 90¬∞ or < -90¬∞, the road goes in the opposite direction\n      // Reverse the coordinates to follow the road in the user's intended direction\n      if (Math.abs(bearingDiff) > 90) {\n        roadCoords = [...roadCoords].reverse();\n        console.log(`[RoadFollow] Reversed road direction to match user's view (bearingDiff: ${bearingDiff.toFixed(1)}¬∞)`);\n      } else {\n        console.log(`[RoadFollow] Following road in natural direction (bearingDiff: ${bearingDiff.toFixed(1)}¬∞)`);\n      }\n    }\n\n    // Helper function to find next connected segment\n    // Returns null if no valid connection found\n    // Queries roads dynamically around current position at animation zoom level\n    const findNextSegment = async (lastPoint, secondLastPoint, usedIds) => {\n      const currentBearing = calculateBearing(\n        secondLastPoint[0], secondLastPoint[1],\n        lastPoint[0], lastPoint[1]\n      );\n\n      // Get current road properties for continuity scoring\n      const currentRoadName = currentSegmentCoords.roadName;\n      const currentRoadRef = currentSegmentCoords.roadRef;\n      const currentRoadClass = currentSegmentCoords.roadClass;\n\n      // If using helper map, position it ahead before querying\n      if (options.map2 && vehicleProfile.searchRadius) {\n        await AnimationDirector._positionHelperMapAhead(\n          options.map2,\n          lastPoint,\n          currentBearing,\n          vehicleProfile.searchRadius\n        );\n      }\n\n      // Query roads dynamically around current position\n      // Uses animation zoom level (18.5 for drone) = ultra-detailed geometry with all tiny segments\n      const currentRoads2 = map2.querySourceFeatures(sourceId2, {\n        sourceLayer: sourceLayer2,\n        filter: ROAD_QUERY_FILTER\n      });\n\n      let bestNextSegment = null;\n      let bestScore = Infinity; // Lower score is better\n      let candidateCount = 0; // Track how many candidates we evaluate\n\n      // Connection threshold: back to 50m to avoid jumping between roads\n      const connectionThreshold = 0.0005;\n\n      console.log(`[RoadChain] Searching for next segment from ${currentRoadClass}${currentRoadName ? ' (' + currentRoadName + ')' : ''}${currentRoadRef ? ' [' + currentRoadRef + ']' : ''}, bearing: ${currentBearing.toFixed(1)}¬∞`);\n      console.log(`[RoadChain] Total segments in cache: ${currentRoads2.length}`);\n      console.log(`[RoadChain] Connection threshold: ${(connectionThreshold * 111000).toFixed(0)}m`);\n\n      for (const road of currentRoads2) {\n        if (!road.geometry || !road.geometry.coordinates) {\n          continue;\n        }\n\n        if (usedIds.has(road.id)) {\n          continue;\n        }\n\n        const roadStart = road.geometry.coordinates[0];\n        const roadEnd = road.geometry.coordinates[road.geometry.coordinates.length - 1];\n\n        // Check if this segment starts near our current endpoint\n        const dxStart = roadStart[0] - lastPoint[0];\n        const dyStart = roadStart[1] - lastPoint[1];\n        const distanceToStart = Math.sqrt(dxStart * dxStart + dyStart * dyStart);\n\n        // Check if segment end is near our endpoint (for reversed connection)\n        const dxEnd = roadEnd[0] - lastPoint[0];\n        const dyEnd = roadEnd[1] - lastPoint[1];\n        const distanceToEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd);\n\n        const minDist = Math.min(distanceToStart, distanceToEnd);\n\n        if (minDist >= connectionThreshold) {\n          continue; // Too far\n        }\n\n        // Within threshold - evaluate this segment as a candidate\n        // Determine if we need to reverse this segment\n        const shouldReverse = distanceToEnd < distanceToStart;\n        const effectiveCoords = shouldReverse ? [...road.geometry.coordinates].reverse() : road.geometry.coordinates;\n\n        // Need at least 2 points to calculate bearing\n        if (effectiveCoords.length < 2) continue;\n\n        const effectiveStart = effectiveCoords[0];\n        const effectiveSecond = effectiveCoords[1];\n\n        // Validate coordinates are valid numbers\n        if (!isValidCoordinate(effectiveStart) || !isValidCoordinate(effectiveSecond)) {\n          console.warn(`[RoadChain] Invalid coordinates for road ${road.id}, skipping`);\n          continue;\n        }\n\n        // Calculate bearing of this potential next segment\n        const nextSegmentBearing = calculateBearing(\n          effectiveStart[0], effectiveStart[1],\n          effectiveSecond[0], effectiveSecond[1]\n        );\n\n        // Skip if bearing calculation failed (NaN)\n        if (isNaN(nextSegmentBearing)) {\n          console.warn(`[RoadChain] NaN bearing for road ${road.id}, skipping`);\n          continue;\n        }\n\n        // Calculate angular difference (prefer segments that continue in similar direction)\n        const bearingDiff = Math.abs(normalizeBearingDiff(nextSegmentBearing - currentBearing));\n\n        // Skip if bearingDiff is NaN\n        if (isNaN(bearingDiff)) {\n          console.warn(`[RoadChain] NaN bearingDiff for road ${road.id}, skipping`);\n          continue;\n        }\n\n        // Reject U-turns (> 150¬∞) completely - never acceptable\n        if (bearingDiff > 150) continue;\n\n        const distance = Math.min(distanceToStart, distanceToEnd);\n\n        // === HIERARCHICAL PRIORITY SYSTEM ===\n        // Priority order: roadRef > roadName > roadClass > position\n        // Lower score = better choice\n\n        const roadName = road.properties?.name;\n        const roadRef = road.properties?.ref;\n        const roadClass = road.properties?.class;\n\n        const isSameRef = roadRef && currentRoadRef && roadRef === currentRoadRef;\n        const isSameName = roadName && currentRoadName && roadName === currentRoadName;\n        const isSameClass = roadClass && currentRoadClass && roadClass === currentRoadClass;\n\n        let score = 0;\n\n        // PRIORITY 1: Same roadRef (D123, A1, etc.) ‚Üí ALWAYS WIN\n        if (isSameRef) {\n          score = 0 + distance * 10 + bearingDiff * 0.01; // Range: 0-10\n        } else if (isSameName) {\n          // PRIORITY 2: Same roadName (Rue Gambetta, etc.) ‚Üí ALMOST ALWAYS WIN\n          score = 100 + distance * 10 + bearingDiff * 0.01; // Range: 100-110\n        } else if (isSameClass) {\n          // PRIORITY 3: Same roadClass (no name) ‚Üí STRONGLY PREFER STRAIGHT\n          score = 1000 + distance * 10 + bearingDiff * 50; // bearingDiff is KEY!\n          // 5¬∞ vs 90¬∞ = 1250 vs 5500 ‚Üí 4x better score for going straight\n        } else {\n          // PRIORITY 4: Different road ‚Üí VERY STRONGLY PREFER STRAIGHT\n          score = 10000 + distance * 100 + bearingDiff * 200;\n          // bearingDiff CRITICAL - strongly favor continuing straight\n        }\n\n        candidateCount++;\n\n        // Log every candidate segment for debugging\n        const candidateLabel = roadRef ? `[${roadRef}]` : (roadName || roadClass);\n        const priorityLabel = isSameRef ? 'P1-SameRef' : (isSameName ? 'P2-SameName' : (isSameClass ? 'P3-SameClass' : 'P4-Different'));\n        console.log(`[RoadChain]   Candidate #${candidateCount}: ${candidateLabel} (${priorityLabel}) bearing Œî${bearingDiff.toFixed(1)}¬∞, dist ${(distance * 111000).toFixed(1)}m, score ${score.toFixed(1)}`);\n\n        if (score < bestScore) {\n          bestScore = score;\n          bestNextSegment = {\n            road,\n            coords: effectiveCoords,\n            reversed: shouldReverse,\n            bearingDiff,\n            distance,\n            score, // For debugging\n            roadName, // Store for logging\n            roadRef\n          };\n        }\n      }\n\n      console.log(`[RoadChain] Evaluated ${candidateCount} candidate segments, best score: ${bestScore === Infinity ? 'none found' : bestScore.toFixed(1)}`);\n\n      // If no segment found and we have a helper map, try adjusting zoom\n      if (!bestNextSegment && options.map2 && vehicleProfile.searchRadius) {\n        const currentZoom2 = options.map2.getZoom();\n        // Vector tile data is typically in zoom 14-18, try different levels\n        const zoomsToTry = currentZoom2 === 18 ? [16, 17] : []; // Try wider views\n\n        for (const zoomLevel of zoomsToTry) {\n          console.log(`[RoadChain] No segment found at zoom ${currentZoom2.toFixed(1)}, retrying at zoom ${zoomLevel}...`);\n\n          // Adjust helper map zoom\n          options.map2.setZoom(zoomLevel);\n          await new Promise(resolve => setTimeout(resolve, 200)); // Wait for tiles to load\n\n          // Re-query with new zoom\n          const retryRoads2 = map2.querySourceFeatures(sourceId2, {\n            sourceLayer: sourceLayer2,\n            filter: ROAD_QUERY_FILTER\n          });\n\n          console.log(`[RoadChain] Retry found ${retryRoads2.length} segments at zoom ${zoomLevel}`);\n\n          // Re-run scoring logic (simplified - just find ANY connected segment)\n          for (const road of retryRoads2) {\n            if (!road.geometry || !road.geometry.coordinates) continue;\n            if (usedIds.has(road.id)) continue;\n\n            const roadStart = road.geometry.coordinates[0];\n            const roadEnd = road.geometry.coordinates[road.geometry.coordinates.length - 1];\n\n            const dxStart = roadStart[0] - lastPoint[0];\n            const dyStart = roadStart[1] - lastPoint[1];\n            const distanceToStart = Math.sqrt(dxStart * dxStart + dyStart * dyStart);\n\n            const dxEnd = roadEnd[0] - lastPoint[0];\n            const dyEnd = roadEnd[1] - lastPoint[1];\n            const distanceToEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd);\n\n            const minDist = Math.min(distanceToStart, distanceToEnd);\n\n            if (minDist < connectionThreshold) {\n              // Found a connected segment!\n              const shouldReverse = distanceToEnd < distanceToStart;\n              const effectiveCoords = shouldReverse ? [...road.geometry.coordinates].reverse() : road.geometry.coordinates;\n\n              if (effectiveCoords.length >= 2) {\n                const effectiveStart = effectiveCoords[0];\n                const effectiveSecond = effectiveCoords[1];\n                const nextSegmentBearing = calculateBearing(\n                  effectiveStart[0], effectiveStart[1],\n                  effectiveSecond[0], effectiveSecond[1]\n                );\n                const bearingDiff = Math.abs(normalizeBearingDiff(nextSegmentBearing - currentBearing));\n\n                if (bearingDiff <= 150) { // Not a U-turn\n                  console.log(`[RoadChain] ‚úÖ Found segment at zoom ${zoomLevel}: bearingDiff ${bearingDiff.toFixed(1)}¬∞`);\n                  bestNextSegment = {\n                    road,\n                    coords: effectiveCoords,\n                    reversed: shouldReverse,\n                    bearingDiff,\n                    distance: minDist,\n                    score: 1000 + bearingDiff * 50, // Simple score\n                    roadName: road.properties?.name,\n                    roadRef: road.properties?.ref\n                  };\n                  break;\n                }\n              }\n            }\n          }\n\n          if (bestNextSegment) {\n            // Restore original zoom\n            options.map2.setZoom(18);\n            break;\n          }\n        }\n\n        // Restore original zoom if we didn't find anything\n        if (!bestNextSegment && options.map2) {\n          options.map2.setZoom(18);\n        }\n      }\n\n      return bestNextSegment;\n    };\n\n    console.log(`[RoadChain] Starting with ${roadClass}: ${roadCoords.length} points`);\n\n    updateStatus(`${vehicleProfile.icon} Following ${roadClass} (${roadCoords.length} points)...`);\n\n    // Set pitch from vehicle profile\n    const targetPitch = vehicleProfile.pitch;\n    map.easeTo({ pitch: targetPitch, duration: 1000, essential: true });\n    await map.once('moveend');\n    checkAbort();\n\n    // Configuration from vehicle profile\n    // Define realistic speed in km/h (will be used to calculate duration based on distance)\n    const vehicleSpeedKmh = vehicleProfile.speedKmh || 30; // Default: 30 km/h\n    const maxSegments = 10000; // Very high limit just to prevent infinite loops in case of bugs\n\n    console.log(`[RoadFollow] Vehicle speed: ${vehicleSpeedKmh} km/h`);\n\n    // NOTE: Initial positioning is now done in the setup phase (before recording starts)\n    // This function only handles the actual road following animation\n\n    // Track animation state (works in both test and recording modes)\n    // Use maplibregl.now() which returns virtual time when frozen, real time otherwise\n    // @ts-ignore - timeControl API may not exist in older versions\n    const startTime = maplibregl.now();\n\n    // Resample initial segment for uniform point spacing (smoother speed)\n    // Use Catmull-Rom spline if smoothPath is enabled for natural curves\n    let currentSegmentCoords = vehicleProfile.smoothPath\n      ? resamplePathCatmullRom(roadCoords, 0.01) // Smooth curves with Catmull-Rom\n      : resamplePath(roadCoords, 0.01); // Linear interpolation (10m spacing)\n\n    // Store initial road properties for continuity tracking\n    currentSegmentCoords.roadClass = closestRoad.properties?.class;\n    currentSegmentCoords.roadName = closestRoad.properties?.name;\n    currentSegmentCoords.roadRef = closestRoad.properties?.ref;\n\n    // Smoothing buffer for zoom\n    const zoomBuffer = [];\n    const bufferSize = vehicleProfile.smoothing;\n\n    updateStatus(`${vehicleProfile.icon} Following road network...`);\n\n    // Main animation loop: follow points and chain segments dynamically\n    const usedSegmentIds = new Set([closestRoad.id]);\n    let currentSegmentIndex = 1; // Start at second point since camera is already at first point\n    let segmentCount = 1;\n    let totalPointsVisited = 1; // We've already visited the first point\n\n    try {\n      while (true) {\n        checkAbort();\n\n        // Calculate elapsed time (works with both real and virtual time)\n        // @ts-ignore - timeControl API may not exist in older versions\n        const elapsed = maplibregl.now() - startTime;\n\n        // Check duration only if time is NOT frozen (test mode)\n        // During recording, time is frozen and the recording system manages duration\n        if (!maplibregl.isTimeFrozen || !maplibregl.isTimeFrozen()) {\n          if (elapsed >= duration) {\n            console.log(`[RoadChain] Animation complete: ${(elapsed / 1000).toFixed(1)}s, ${totalPointsVisited} points, ${segmentCount} segments`);\n            break;\n          }\n        }\n\n        // Check if we've reached the end of the current segment\n        if (currentSegmentIndex >= currentSegmentCoords.length) {\n          console.log(`[RoadChain] End of segment #${segmentCount} reached (index ${currentSegmentIndex} >= ${currentSegmentCoords.length} points)`);\n\n          // Try to find the next connecting segment\n          if (segmentCount >= maxSegments) {\n            console.log(`[RoadChain] Max segments (${maxSegments}) reached`);\n            break;\n          }\n\n          const lastPoint = currentSegmentCoords[currentSegmentCoords.length - 1];\n          const secondLastPoint = currentSegmentCoords[currentSegmentCoords.length - 2];\n\n          // Safety check: we need at least 2 points for bearing calculation\n          if (!secondLastPoint) {\n            console.error('[RoadChain] ‚ùå ERROR: Segment has only 1 point, cannot calculate bearing!');\n            console.error(`[RoadChain] currentSegmentCoords.length = ${currentSegmentCoords.length}`);\n            console.error('[RoadChain] This is a bug - segments should always have ‚â•2 points');\n            break;\n          }\n\n          console.log(`[RoadChain] Searching for segment #${segmentCount + 1} from point [${lastPoint[0].toFixed(6)}, ${lastPoint[1].toFixed(6)}]`);\n\n          // Segments are loaded dynamically in findNextSegment\n          let nextSegment = await findNextSegment(lastPoint, secondLastPoint, usedSegmentIds);\n          console.log(`[RoadChain] Search result: ${nextSegment ? 'FOUND' : 'NOT FOUND'}`);\n\n          // If STILL no connected segment, search in cardinal directions for nearby roads\n          if (!nextSegment) {\n            const currentBearing = calculateBearing(\n              secondLastPoint[0], secondLastPoint[1],\n              lastPoint[0], lastPoint[1]\n            );\n\n            // Determine preferred road class based on current segment\n            const currentClass = currentSegmentCoords.roadClass || closestRoad.properties?.class;\n            const prefer = currentClass ? [currentClass] : []; // Prefer same road type\n\n            // Use smaller searchRadius for cardinal search (200m max instead of vehicle's searchRadius)\n            // This prevents huge jumps when no road is directly connected\n            const cardinalSearchRadius = Math.min(0.002, vehicleProfile.searchRadius || 0.002); // Max 200m\n            nextSegment = _findNearbyRoadInCardinalDirections(\n              lastPoint,\n              currentBearing,\n              usedSegmentIds,\n              roads2,\n              { prefer, searchRadius: cardinalSearchRadius }\n            );\n\n            if (nextSegment) {\n              console.log('[RoadChain] Cardinal search: FOUND road in direction');\n              updateStatus(`${vehicleProfile.icon} Jumping to nearby road...`);\n            } else {\n              console.log('[RoadChain] Cardinal search: NOT FOUND');\n            }\n          }\n\n          // If STILL no segment found AND in Explore mode, continue forward to find next road\n          if (!nextSegment && vehicleProfile.supportsExploration) {\n            console.log('[RoadSearch] Explore mode: searching forward for next road...');\n\n            const currentBearing = calculateBearing(\n              secondLastPoint[0], secondLastPoint[1],\n              lastPoint[0], lastPoint[1]\n            );\n\n            const stepDistance = 0.0005; // ~50m per step\n            const maxSteps = 4; // Search only 200m forward (reduced from 1km to avoid huge jumps)\n            let foundRoad = null;\n\n            for (let step = 1; step <= maxSteps && !foundRoad; step++) {\n              // Calculate search point at this distance\n              const radians = (currentBearing * Math.PI) / 180;\n              const searchLng = lastPoint[0] + (stepDistance * step) * Math.sin(radians);\n              const searchLat = lastPoint[1] + (stepDistance * step) * Math.cos(radians);\n\n              // Search for road at this point\n              const currentClass = currentSegmentCoords.roadClass || closestRoad.properties?.class;\n              foundRoad = _findNearbyRoadInCardinalDirections(\n                [searchLng, searchLat],\n                currentBearing,\n                usedSegmentIds,\n                roads2,\n                {\n                  prefer: currentClass ? [currentClass] : [],\n                  searchRadius: (vehicleProfile.searchRadius || 0.002) * 0.5 // Half radius for exploration mode\n                }\n              );\n\n              if (foundRoad) {\n                console.log(`[RoadSearch] ‚úÖ Found road after ${step} steps (${(step * 50).toFixed(0)}m forward)`);\n\n                // Create intermediate points for smooth transition\n                const intermediatePoints = [];\n                for (let i = 1; i <= step; i++) {\n                  const lng = lastPoint[0] + (stepDistance * i) * Math.sin(radians);\n                  const lat = lastPoint[1] + (stepDistance * i) * Math.cos(radians);\n                  intermediatePoints.push([lng, lat]);\n                }\n\n                // Combine transition points + new road\n                nextSegment = {\n                  ...foundRoad,\n                  coords: [...intermediatePoints, ...foundRoad.coords]\n                };\n\n                updateStatus(`${vehicleProfile.icon} Crossing terrain to next road...`);\n              }\n            }\n\n            if (!foundRoad) {\n              console.log('[RoadSearch] No road found within 200m forward - generating synthetic segment to continue');\n\n              // Plan B: Generate straight-line path to continue exploration\n              // This prevents getting stuck when roads are sparse or disconnected\n              const straightAheadDistance = stepDistance * maxSteps; // Continue same distance we searched\n              const radians = (currentBearing * Math.PI) / 180;\n\n              // Create a synthetic path with intermediate points for smooth movement\n              const intermediateSteps = 10;\n              const syntheticCoords = [];\n              for (let i = 1; i <= intermediateSteps; i++) {\n                const progress = i / intermediateSteps;\n                const lng = lastPoint[0] + straightAheadDistance * progress * Math.sin(radians);\n                const lat = lastPoint[1] + straightAheadDistance * progress * Math.cos(radians);\n                syntheticCoords.push([lng, lat]);\n              }\n\n              nextSegment = {\n                road: { id: `synthetic-${segmentCount}`, properties: { class: 'aerial' } },\n                coords: syntheticCoords,\n                reversed: false,\n                bearingDiff: 0,\n                distance: 0,\n                synthetic: true // Mark as synthetic for debugging\n              };\n\n              updateStatus(`${vehicleProfile.icon} Flying over terrain (no roads)...`);\n            }\n          }\n\n          if (nextSegment) {\n            // Chain to the next segment\n            // Resample segment for uniform point spacing (smoother speed)\n            // Skip first point (already at it) ONLY if we have more than 2 points\n            // We need at least 2 points to calculate bearing for the NEXT segment\n            if (nextSegment.coords.length > 2) {\n              currentSegmentCoords = vehicleProfile.smoothPath\n                ? resamplePathCatmullRom(nextSegment.coords.slice(1), 0.01) // Smooth curves\n                : resamplePath(nextSegment.coords.slice(1), 0.01); // Linear (10m spacing)\n            } else {\n              // Keep all points if segment is very short (2 points)\n              // This ensures we always have at least 2 points for bearing calculation\n              currentSegmentCoords = vehicleProfile.smoothPath\n                ? resamplePathCatmullRom(nextSegment.coords, 0.01) // Smooth curves\n                : resamplePath(nextSegment.coords, 0.01); // Linear (10m spacing)\n              console.log(`[RoadChain] Short segment - keeping all ${nextSegment.coords.length} points for bearing calc`);\n            }\n            // Store road properties for continuity tracking\n            currentSegmentCoords.roadClass = nextSegment.road.properties?.class;\n            currentSegmentCoords.roadName = nextSegment.road.properties?.name;\n            currentSegmentCoords.roadRef = nextSegment.road.properties?.ref;\n\n            currentSegmentIndex = 0;\n            segmentCount++;\n            usedSegmentIds.add(nextSegment.road.id);\n\n            const segmentClass = nextSegment.road.properties?.class || 'road';\n            const segmentName = nextSegment.road.properties?.name;\n            const segmentRef = nextSegment.road.properties?.ref;\n            const roadIdentity = segmentRef || segmentName || segmentClass;\n\n            // nextSegment.distance is in km (from calculateDistance), convert to meters\n            const distanceM = nextSegment.distance ? (nextSegment.distance * 1000).toFixed(1) : '0.0';\n            console.log(`[RoadChain] ‚úÖ Segment #${segmentCount}: ${roadIdentity} ` +\n                        `(${nextSegment.coords.length} pts, ${nextSegment.reversed ? 'reversed' : 'forward'}, ` +\n                        `bearing Œî${nextSegment.bearingDiff.toFixed(1)}¬∞, ${distanceM}m)` +\n                        (nextSegment.score ? `, score: ${nextSegment.score.toFixed(1)}` : ''));\n            console.log(`[RoadChain] After processing: ${currentSegmentCoords.length} points remaining for animation`);\n\n            // Add segment to visualization\n            if (options.debugFeatures) {\n              try {\n                // @ts-ignore - timeControl API may not exist in older versions\n                const elapsedMs = maplibregl.now() - startTime;\n\n                options.debugFeatures.push({\n                  type: 'Feature',\n                  properties: {\n                    name: segmentName || 'unnamed',\n                    ref: segmentRef || '',\n                    class: segmentClass,\n                    segmentNum: segmentCount,\n                    reversed: nextSegment.reversed,\n                    bearingDiff: parseFloat(nextSegment.bearingDiff.toFixed(1)),\n                    distanceM: parseFloat(distanceM),\n                    score: nextSegment.score ? parseFloat(nextSegment.score.toFixed(1)) : null,\n                    numPoints: nextSegment.coords.length,\n                    roadId: nextSegment.road.id,\n                    timestampMs: Math.round(elapsedMs),\n                    zoom2: options.map2 ? parseFloat(options.map2.getZoom().toFixed(1)) : null\n                  },\n                  geometry: {\n                    type: 'LineString',\n                    coordinates: nextSegment.coords\n                  }\n                });\n\n                // Update GeoJSON source\n                const debugSource = map.getSource('drone-followed-segments');\n                if (debugSource) {\n                  debugSource.setData({\n                    type: 'FeatureCollection',\n                    features: options.debugFeatures\n                  });\n                  console.log(`[Debug] Added segment #${segmentCount} to visualization (total: ${options.debugFeatures.length} segments)`);\n                }\n              } catch (error) {\n                console.error('[Debug] Failed to update visualization:', error);\n              }\n            }\n\n            updateStatus(`${vehicleProfile.icon} Following ${roadIdentity} (segment ${segmentCount})...`);\n          } else {\n            // Really no roads found anywhere nearby\n            console.error(`[RoadChain] ‚ùå STOPPING: No roads found in any direction after ${segmentCount} segments`);\n            console.error('[RoadChain] This should NEVER happen in exploration mode with synthetic segments!');\n            console.error(`[RoadChain] Last position: [${lastPoint[0].toFixed(6)}, ${lastPoint[1].toFixed(6)}]`);\n            console.error(`[RoadChain] supportsExploration: ${vehicleProfile.supportsExploration}`);\n            usedSegmentIds.clear(); // Reset cache for next exploration\n            break;\n          }\n        }\n\n        // Follow the current point\n        const [lng, lat] = currentSegmentCoords[currentSegmentIndex];\n        const currentPoint = { lng, lat };\n\n        // Calculate distance to next point and duration based on vehicle speed\n        let moveDuration = 100; // Default fallback\n        let bearing = initialBearing;\n\n        if (currentSegmentIndex < currentSegmentCoords.length - 1) {\n          const [nextLng, nextLat] = currentSegmentCoords[currentSegmentIndex + 1];\n          bearing = calculateBearing(lng, lat, nextLng, nextLat);\n\n          // Calculate actual distance using Haversine formula\n          const distanceKm = calculateDistance(lng, lat, nextLng, nextLat);\n\n          // Calculate duration: time = distance / speed (in hours), then convert to ms\n          // duration (ms) = (distance_km / speed_kmh) * 3600 * 1000\n          moveDuration = (distanceKm / vehicleSpeedKmh) * 3600 * 1000;\n\n          // Only clamp minimum to avoid render issues with extremely close points\n          // No maximum clamp - respect the actual physics for constant speed\n          moveDuration = Math.max(20, moveDuration);\n        } else if (currentSegmentIndex > 0) {\n          // Use bearing from previous point if we're at the end\n          const [prevLng, prevLat] = currentSegmentCoords[currentSegmentIndex - 1];\n          bearing = calculateBearing(prevLng, prevLat, lng, lat);\n        }\n\n        // Sample terrain elevation at current road point\n        const elevation = map.queryTerrainElevation(currentPoint);\n        let targetZoom = vehicleProfile.zoom;\n\n        if (elevation !== null && elevation >= 0) {\n          const elevationKm = elevation / 1000;\n          const baseZoom = vehicleProfile.zoom;\n          const elevationAdjustment = elevationKm * 1.5;\n          targetZoom = Math.max(10, baseZoom - elevationAdjustment);\n        }\n\n        // Smoothing\n        zoomBuffer.push(targetZoom);\n        if (zoomBuffer.length > bufferSize) {\n          zoomBuffer.shift();\n        }\n        const smoothedZoom = zoomBuffer.reduce((a, b) => a + b, 0) / zoomBuffer.length;\n\n        // Move camera to road point with duration based on actual distance\n        map.easeTo({\n          center: currentPoint,\n          bearing,\n          zoom: smoothedZoom,\n          pitch: targetPitch,\n          duration: moveDuration,\n          essential: true,\n          easing: t => t, // Linear for smooth continuous motion\n          noMoveStart: true, // Don't trigger movestart event for smoother transitions\n          delayEndEvents: 0 // Don't delay end events\n        });\n\n        await map.once('moveend');\n\n        currentSegmentIndex++;\n        totalPointsVisited++;\n\n        // Update status every ~1 second\n        if (totalPointsVisited % 30 === 0) {\n          const percent = Math.min(99, Math.round((elapsed / duration) * 100));\n          updateStatus(`${vehicleProfile.icon} Following road network: ${percent}% (${segmentCount} segments)`);\n        }\n      }\n\n      updateStatus(`‚úÖ ${vehicleProfile.name} complete!`);\n    } finally {\n      // Log final GeoJSON for debugging/export (always executed, even on abort)\n      if (options.debugFeatures && options.debugFeatures.length > 0) {\n        const finalGeoJSON = {\n          type: 'FeatureCollection',\n          features: options.debugFeatures\n        };\n        console.log('[Debug] Final followed path GeoJSON (' + options.debugFeatures.length + ' segments):');\n        console.log(JSON.stringify(finalGeoJSON, null, 2));\n      }\n\n      // Cleanup helper map if it exists\n      console.log('[HelperMap] Cleaning up helper map...');\n      cleanupMap2AndDebugLayer(options, map);\n\n      // Cleanup debug visualization layer\n      console.log('[Debug] Cleaning up visualization layer...');\n      try {\n        const debugLayerId = 'drone-followed-segments-layer';\n        const debugSourceId = 'drone-followed-segments';\n\n        if (map.getLayer(debugLayerId)) {\n          map.removeLayer(debugLayerId);\n        }\n        if (map.getSource(debugSourceId)) {\n          map.removeSource(debugSourceId);\n        }\n        console.log('[Debug] Visualization layer cleaned up');\n      } catch (error) {\n        console.error('[Debug] Error cleaning up visualization layer:', error);\n      }\n    }\n  },\n\n  /**\n     * üöú Tractor Road Trip - Follow roads at tractor pace\n     * Close zoom for slow rural driving, follows small roads\n     */\n  tractorRoadTrip: (map, control, options = {}) => {\n    const profile = {\n      altitude: 8,\n      zoom: 20, // Very close for slow speed\n      pitch: 60,\n      smoothing: 5,\n      speedKmh: 30, // Slow tractor speed\n      searchRadius: 0.002, // 200m search radius for ground vehicle\n      preloadDistance: 0.002, // 200m preload for slow vehicle\n      icon: 'üöú',\n      name: 'Tractor Road Trip',\n      supportsExploration: true, // Road-aware animation\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  /**\n     * üöó Car Road Trip - Follow roads at car dashcam level\n     * Medium zoom for realistic highway driving\n     */\n  carRoadTrip: (map, control, options = {}) => {\n    const profile = {\n      altitude: 15,\n      zoom: 19, // Medium distance for car speed\n      pitch: 60,\n      smoothing: 5,\n      speedKmh: 70, // Highway driving speed\n      searchRadius: 0.002, // 200m search radius for ground vehicle\n      preloadDistance: 0.005, // 500m preload for car speed\n      icon: 'üöó',\n      name: 'Car Road Trip',\n      supportsExploration: true, // Road-aware animation\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  /**\n     * üèéÔ∏è Sports Car - Follow roads at racing speed\n     * Higher zoom for high-speed driving, wider view ahead\n     */\n  sportsCarRace: (map, control, options = {}) => {\n    const profile = {\n      altitude: 25,\n      zoom: 17.5, // Higher up to see further ahead at high speed\n      pitch: 60,\n      smoothing: 5,\n      speedKmh: 130, // Sports car racing speed\n      searchRadius: 0.003, // 300m search radius for fast vehicle\n      preloadDistance: 0.010, // 1km preload for high speed\n      icon: 'üèéÔ∏è',\n      name: 'Sports Car Race',\n      supportsExploration: true, // Road-aware animation\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  /**\n     * ‚úàÔ∏è Plane Flight - Follow roads at plane altitude\n     * High altitude (200m), wide view for aerial perspective\n     */\n  planeFlight: (map, control, options = {}) => {\n    const profile = {\n      altitude: 200,\n      zoom: 15,\n      pitch: 45,\n      smoothing: 8,\n      speedKmh: 200, // Plane cruising speed\n      searchRadius: 0.01, // 1km search radius for high altitude\n      preloadDistance: 0.015, // 1.5km preload for plane speed\n      icon: '‚úàÔ∏è',\n      name: 'Plane Flight',\n      supportsExploration: true, // Road-aware animation\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  /**\n     * üöÅ Helicopter Tour - Follow roads at helicopter altitude\n     * Medium altitude (50m), dynamic view with steep pitch\n     */\n  helicopterTour: (map, control, options = {}) => {\n    const profile = {\n      altitude: 50,\n      zoom: 17.5,\n      pitch: 70,\n      smoothing: 6,\n      speedKmh: 60, // Helicopter touring speed\n      searchRadius: 0.005, // 500m search radius for medium altitude\n      preloadDistance: 0.005, // 500m preload for helicopter\n      icon: 'üöÅ',\n      name: 'Helicopter Tour',\n      supportsExploration: true, // Road-aware animation\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  /**\n     * üõ∏ Drone Follow - Follow roads at drone altitude\n     * Low altitude (30m), cinematic view with responsive movements\n     */\n  droneFollow: (map, control, options = {}) => {\n    const profile = {\n      altitude: 30,\n      zoom: 18.5,\n      pitch: 65,\n      smoothing: 4,\n      speedKmh: 60, // Drone filming speed (increased for better pacing)\n      searchRadius: 0.005, // 500m search radius for drone (larger than ground vehicles)\n      preloadDistance: 0.004, // 400m preload for drone\n      icon: 'üõ∏',\n      name: 'Drone Follow',\n      supportsExploration: true, // Road-aware animation\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  /**\n     * ü¶Ö Bird's Eye Road - Follow roads from bird's perspective\n     * High altitude (100m), natural bird flight view\n     */\n  birdsEyeRoad: (map, control, options = {}) => {\n    const profile = {\n      altitude: 100,\n      zoom: 16,\n      pitch: 40,\n      smoothing: 7,\n      speedKmh: 50, // Bird flight speed\n      searchRadius: 0.01, // 1km search radius for high altitude flight\n      preloadDistance: 0.004, // 400m preload for bird\n      icon: 'ü¶Ö',\n      name: \"Bird's Eye Road\",\n      supportsExploration: true, // Road-aware animation\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  /**\n     * üöÇ Train Ride - Follow railway tracks at train speed\n     * Low altitude, steady camera movement, smooth ride\n     */\n  trainRide: (map, control, options = {}) => {\n    const profile = {\n      altitude: 12,\n      zoom: 19,\n      pitch: 55,\n      smoothing: 8, // Trains are very smooth and stable\n      speedKmh: 70, // Moderate train speed\n      searchRadius: 0.002, // 200m search radius for ground transport\n      preloadDistance: 0.005, // 500m preload for train\n      icon: 'üöÇ',\n      name: 'Train Ride',\n      supportsExploration: true, // Path-aware animation\n      transportClasses: ['rail', 'transit'], // Follow railway tracks instead of roads\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  speedboat: (map, control, options = {}) => {\n    const profile = {\n      altitude: 8,\n      zoom: 18,\n      pitch: 55,\n      smoothing: 4, // Agile and responsive\n      speedKmh: 90, // Fast speedboat\n      searchRadius: 0.005, // 500m search radius for fast watercraft\n      preloadDistance: 0.007, // 700m preload for speedboat\n      icon: 'üö§',\n      name: 'Speedboat',\n      supportsExploration: true, // Path-aware animation\n      transportClasses: ['river', 'canal', 'stream'], // Follow all waterways\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  sailboat: (map, control, options = {}) => {\n    const profile = {\n      altitude: 10,\n      zoom: 17,\n      pitch: 55,\n      smoothing: 7, // Stable but not too rigid\n      speedKmh: 28, // Moderate sailing speed\n      searchRadius: 0.004, // 400m search radius for waterways\n      preloadDistance: 0.002, // 200m preload for sailboat\n      icon: '‚õµ',\n      name: 'Sailboat',\n      supportsExploration: true, // Path-aware animation\n      transportClasses: ['river', 'canal'], // Follow rivers and canals (not small streams)\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  cruiseShip: (map, control, options = {}) => {\n    const profile = {\n      altitude: 18,\n      zoom: 15,\n      pitch: 45,\n      smoothing: 11, // Very smooth and stable\n      speedKmh: 22, // Slow cruise ship\n      searchRadius: 0.004, // 400m search radius for waterways\n      preloadDistance: 0.002, // 200m preload for cruise ship\n      icon: 'üõ•Ô∏è',\n      name: 'Cruise Ship',\n      supportsExploration: true, // Path-aware animation\n      transportClasses: ['river', 'canal'], // Follow major waterways only\n      smoothPath: true // Smooth Catmull-Rom curves\n    };\n    return PresetAnimations._followPathWithVehicleSetup(map, control, options, profile);\n  },\n\n  /**\n     * ‚úàÔ∏è Free Flight - Straight cruise with natural variations\n     * No road following, just flies in current direction with subtle changes\n     * Perfect for landscape overview, ocean crossing, or zen mode\n     */\n  freeFlight: async (map, { updateStatus, checkAbort }, options = {}) => {\n    const duration = options.duration || 60000;\n    const speedKmh = options.speedKmh || 80; // 80 km/h cruise speed\n    const pitch = options.pitch || 50;\n\n    updateStatus('‚úàÔ∏è Free flight - cruising forward...');\n\n    // @ts-ignore\n    const startTime = maplibregl.now();\n    const initialBearing = map.getBearing();\n    const initialCenter = map.getCenter();\n\n    // Gently ease to flight altitude and pitch\n    map.easeTo({ pitch, duration: 2000, essential: true });\n    await map.once('moveend');\n    checkAbort();\n\n    // Calculate distance per step based on speed\n    const speedMs = speedKmh * 1000 / 3600; // km/h to m/s\n    const stepInterval = 100; // Update every 100ms for smooth motion\n    const distancePerStep = speedMs * (stepInterval / 1000); // meters per step\n    const degreesPerStep = distancePerStep / 111000; // roughly 111km per degree\n\n    let currentLng = initialCenter.lng;\n    let currentLat = initialCenter.lat;\n    let currentBearing = initialBearing;\n\n    // Natural variation parameters\n    let bearingDrift = 0;\n\n    updateStatus('‚úàÔ∏è Cruising...');\n\n    while (true) {\n      checkAbort();\n\n      // @ts-ignore\n      const elapsed = maplibregl.now() - startTime;\n      // @ts-ignore\n      if (!maplibregl.isTimeFrozen || !maplibregl.isTimeFrozen()) {\n        if (elapsed >= duration) {\n          console.log(`[FreeFlight] Cruise complete: ${(elapsed / 1000).toFixed(1)}s`);\n          break;\n        }\n      }\n\n      // Add natural bearing variations (gentle sine wave + noise)\n      const t = elapsed / 1000;\n      bearingDrift += (Math.sin(t * 0.1) * 0.02) + (Math.random() - 0.5) * 0.05;\n      bearingDrift = Math.max(-5, Math.min(5, bearingDrift)); // ¬±5¬∞ max drift\n\n      currentBearing = initialBearing + bearingDrift;\n\n      // Move forward in current bearing direction\n      const radians = (currentBearing * Math.PI) / 180;\n      currentLng += degreesPerStep * Math.sin(radians);\n      currentLat += degreesPerStep * Math.cos(radians);\n\n      // Smooth camera movement\n      map.easeTo({\n        center: [currentLng, currentLat],\n        bearing: currentBearing,\n        duration: stepInterval,\n        essential: true\n      });\n\n      await sleep(stepInterval);\n    }\n\n    updateStatus('‚úàÔ∏è Free flight complete');\n  }\n};\n","/**\n * Animation Controller\n *\n * Clean and modern animation control system using AbortController\n * Handles cancellation, state management, and position restoration\n */\n\nexport class AnimationController {\n  constructor() {\n    this.abortController = null;\n    this.isRunning = false;\n    this.initialPosition = null;\n  }\n\n  /**\n     * Run an animation with cancellation support\n     * @param {Object} map - MapLibre GL map instance\n     * @param {Function} animation - Animation function to run\n     * @param {Object} options - Options including updateStatus callback\n     * @returns {Promise<{success?: boolean, cancelled?: boolean}>}\n     */\n  async run(map, animation, options = {}) {\n    // If already running, cancel current animation\n    if (this.isRunning) {\n      this.cancel(map);\n      return { cancelled: true };\n    }\n\n    // Initialize animation state\n    this.isRunning = true;\n    this.abortController = new AbortController();\n    this.initialPosition = this._capturePosition(map);\n\n    // Capture the signal reference to avoid context issues\n    const signal = this.abortController.signal;\n\n    try {\n      // Run animation with abort signal\n      await animation(map, {\n        signal,\n        updateStatus: options.updateStatus || (() => {}),\n        checkAbort: () => {\n          if (signal.aborted) {\n            throw new DOMException('Animation aborted', 'AbortError');\n          }\n        }\n      });\n\n      return { success: true };\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        return { cancelled: true };\n      }\n      throw error;\n    } finally {\n      this.cleanup();\n    }\n  }\n\n  /**\n     * Cancel the current animation and restore initial position\n     */\n  cancel(map) {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n\n    // Restore initial position if map is provided\n    if (map && this.initialPosition) {\n      map.jumpTo(this.initialPosition);\n    }\n\n    this.cleanup();\n  }\n\n  /**\n     * Stop the current animation without restoring position\n     * (useful after recording completes)\n     */\n  stop() {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n\n    this.cleanup();\n  }\n\n  /**\n     * Check if animation is currently running\n     */\n  get running() {\n    return this.isRunning;\n  }\n\n  /**\n     * Check if the animation has been aborted\n     */\n  get aborted() {\n    return this.abortController?.signal.aborted ?? false;\n  }\n\n  /**\n     * Clean up internal state\n     */\n  cleanup() {\n    this.isRunning = false;\n    this.abortController = null;\n    this.initialPosition = null;\n  }\n\n  /**\n     * Capture current map position\n     */\n  _capturePosition(map) {\n    return {\n      center: map.getCenter(),\n      zoom: map.getZoom(),\n      bearing: map.getBearing(),\n      pitch: map.getPitch()\n    };\n  }\n\n  /**\n     * Create a helper for animations to check abort status between steps\n     * Returns a function that throws AbortError if cancelled\n     */\n  createAbortChecker() {\n    // Capture the signal reference when the checker is created\n    const signal = this.abortController ? this.abortController.signal : null;\n    return () => {\n      if (signal && signal.aborted) {\n        throw new DOMException('Animation aborted', 'AbortError');\n      }\n    };\n  }\n\n  /**\n     * Helper to wait for map movement with abort support\n     * Automatically checks for abort after movement completes\n     */\n  async waitForMove(map, movePromise) {\n    await movePromise;\n    await map.once('moveend');\n\n    // Check for abort after movement\n    const signal = this.abortController ? this.abortController.signal : null;\n    if (signal && signal.aborted) {\n      throw new DOMException('Animation aborted', 'AbortError');\n    }\n  }\n}\n","/**\n * Wrapper for webm-wasm encoder that provides a unified API\n * similar to mp4-h264 encoder\n *\n * This wrapper encapsulates the complexity of the Web Worker-based\n * webm-wasm encoder and exposes a Promise-based API that matches\n * the synchronous mp4-h264 encoder API.\n *\n * IMPORTANT: Requires local webm-wasm files (vendor/webm/) to be deployed\n * alongside the plugin. Does NOT support CDN loading.\n */\nexport class WebmEncoderWrapper {\n  constructor() {\n    this.worker = null;\n    this.resolveEnd = null;\n    this.videoChunks = []; // Collect chunks (realtime) or single final video (non-realtime)\n    this.frameCount = 0;\n    this.realtimeMode = false; // Track encoding mode\n  }\n\n  /**\n     * Create and initialize the encoder\n     * @param {Object} options - Configuration object\n     * @param {number} options.width - Video width in pixels\n     * @param {number} options.height - Video height in pixels\n     * @param {number} options.fps - Frames per second\n     * @param {number} options.bitrate - Bitrate in kbps\n     * @param {string} options.wasmUrl - URL to webm-wasm.wasm file (must be local/same-origin)\n     * @param {string} options.workerUrl - URL to webm-worker.js file (must be local/same-origin)\n     * @param {boolean} options.realtime - Enable realtime mode for faster encoding (default: false)\n     * @returns {Promise<WebmEncoderWrapper>} This instance\n     */\n  async create(options) {\n    const { width, height, fps, bitrate, wasmUrl, workerUrl, realtime = false } = options;\n\n    // Store realtime mode for later\n    this.realtimeMode = realtime;\n\n    console.log('[WebM Encoder] Initializing with:', {\n      width,\n      height,\n      fps,\n      bitrate: `${bitrate} kbps`,\n      realtime: realtime ? 'enabled (fast)' : 'disabled (high quality)',\n      wasmUrl,\n      workerUrl\n    });\n\n    // Validate worker URL before creating Worker (security: prevent code injection)\n    let validatedWorkerUrl;\n    try {\n      const workerUrlObj = new URL(workerUrl, window.location.href);\n\n      // Security check: Worker must be same-origin\n      if (workerUrlObj.origin !== window.location.origin) {\n        throw new Error(\n          `Worker URL must be same-origin. Expected: ${window.location.origin}, Got: ${workerUrlObj.origin}`\n        );\n      }\n\n      // Security check: Worker URL must end with expected filename\n      if (!workerUrlObj.pathname.endsWith('webm-worker.js')) {\n        throw new Error(\n          `Invalid worker URL pattern. Expected path ending with 'webm-worker.js', Got: ${workerUrlObj.pathname}`\n        );\n      }\n\n      validatedWorkerUrl = workerUrlObj.href;\n    } catch (error) {\n      throw new Error(\n        `Worker URL validation failed: ${error.message}\\n` +\n                `Provided URL: ${workerUrl}`\n      );\n    }\n\n    // Create worker from wrapper file (provides CommonJS shim)\n    // The wrapper loads webm-worker.js with importScripts() after setting up exports/module\n    const wrapperUrl = validatedWorkerUrl.replace('webm-worker.js', 'webm-worker-wrapper.js');\n    try {\n      console.log('[WebM Encoder] Creating worker from wrapper:', wrapperUrl);\n      this.worker = new Worker(wrapperUrl);\n    } catch (error) {\n      throw new Error(\n        'Failed to create WebM worker. Make sure vendor/webm/ files are deployed alongside the plugin.\\n' +\n                `Worker URL: ${wrapperUrl}\\n` +\n                `Error: ${error.message}`\n      );\n    }\n\n    // Setup message handler\n    this.worker.onmessage = (e) => {\n      // Log what we receive (less verbose for chunks)\n      if (e.data instanceof ArrayBuffer) {\n        console.log(`[WebM Encoder] Chunk received: ${e.data.byteLength} bytes (total: ${this.videoChunks.length + 1})`);\n      } else {\n        console.log('[WebM Encoder] Worker message:',\n          typeof e.data === 'object' ? JSON.stringify(e.data) : e.data);\n      }\n\n      if (e.data instanceof ArrayBuffer) {\n        // Realtime mode: multiple chunks sent progressively\n        // Non-realtime mode: single complete video sent at end\n        this.videoChunks.push(e.data);\n        console.log(`[WebM Encoder] Collected chunk ${this.videoChunks.length}: ${e.data.byteLength} bytes`);\n\n        // In non-realtime mode, this single ArrayBuffer is the complete video\n        // Resolve immediately if we're waiting in end()\n        if (!this.realtimeMode && this.resolveEnd) {\n          console.log('[WebM Encoder] Non-realtime mode: received final video');\n          this.resolveEnd(e.data);\n          this.resolveEnd = null;\n        }\n      } else if (e.data === 'ready' || e.data === 'READY') {\n        console.log('[WebM Encoder] Worker ready');\n        // Call ready callback if set (during initialization)\n        if (this.resolveReady) {\n          this.resolveReady();\n          this.resolveReady = null;\n        }\n      } else if (e.data === null || e.data === undefined) {\n        // Realtime mode: null signals end of encoding, concatenate all chunks\n        console.log('[WebM Encoder] End signal (null) received - finalizing video');\n\n        // If we're waiting in end(), resolve now\n        if (this.resolveEnd) {\n          console.log(`[WebM Encoder] Realtime mode: concatenating ${this.videoChunks.length} chunks...`);\n\n          // Calculate total size\n          const totalSize = this.videoChunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);\n          console.log(`[WebM Encoder] Total size: ${totalSize} bytes`);\n\n          // Concatenate all chunks into final video\n          const finalVideo = new Uint8Array(totalSize);\n          let offset = 0;\n          for (const chunk of this.videoChunks) {\n            finalVideo.set(new Uint8Array(chunk), offset);\n            offset += chunk.byteLength;\n          }\n\n          console.log(`[WebM Encoder] Video finalized: ${finalVideo.byteLength} bytes`);\n          this.resolveEnd(finalVideo.buffer);\n          this.resolveEnd = null;\n        }\n      } else if (typeof e.data === 'object' && e.data.error) {\n        console.error('[WebM Encoder] Worker error:', e.data.error);\n        if (this.resolveEnd) {\n          this.resolveEnd(null);\n          this.resolveEnd = null;\n        }\n      } else {\n        console.log('[WebM Encoder] Unexpected worker message:', e.data);\n      }\n    };\n\n    // Setup error handler\n    this.worker.onerror = (error) => {\n      console.error('[WebM Encoder] Worker error:', error);\n      if (this.resolveEnd) {\n        this.resolveEnd(null); // Signal error\n        this.resolveEnd = null;\n      }\n    };\n\n    // Send WASM path to worker\n    console.log('[WebM Encoder] Sending WASM path to worker');\n    this.worker.postMessage(wasmUrl);\n\n    // Wait for worker to be ready\n    await new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.resolveReady = null;\n        reject(new Error(\n          'WebM worker initialization timeout. ' +\n                    'Make sure vendor/webm/ files are correctly deployed.'\n        ));\n      }, 30000); // 30 seconds timeout\n\n      // Set the callback that will be called when 'ready' message is received\n      this.resolveReady = () => {\n        clearTimeout(timeout);\n        resolve();\n      };\n    });\n\n    // Send encoder configuration (webm-wasm expects exactly: width, height, bitrate, realtime)\n    console.log('[WebM Encoder] Configuring encoder');\n    const config = {\n      width,\n      height,\n      bitrate, // bitrate in kbps\n      realtime // Realtime mode: false = high quality (slower), true = fast encoding\n    };\n    console.log('[WebM Encoder] Configuration:', config);\n    this.worker.postMessage(config);\n\n    // Wait a bit for the worker to process the configuration\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    console.log('[WebM Encoder] Initialization complete, ready to receive frames');\n    return this;\n  }\n\n  /**\n     * Add an RGBA frame to the video\n     * @param {Uint8Array} rgbaBuffer - RGBA pixel data (width * height * 4 bytes)\n     */\n  addFrame(rgbaBuffer) {\n    this.frameCount++;\n    if (this.frameCount % 30 === 0) {\n      console.log(`[WebM Encoder] Encoding frame ${this.frameCount}`);\n    }\n\n    // Debug first frame\n    if (this.frameCount === 1) {\n      console.log(`[WebM Encoder] First frame - buffer size: ${rgbaBuffer.byteLength} bytes`);\n    }\n\n    // IMPORTANT: webm-wasm expects ArrayBuffer, not Uint8Array\n    // AND it needs to be transferred properly\n    // Create a new ArrayBuffer and copy the data\n    const buffer = new ArrayBuffer(rgbaBuffer.byteLength);\n    const view = new Uint8Array(buffer);\n    view.set(rgbaBuffer);\n\n    // Send the ArrayBuffer WITHOUT transfer (copy instead)\n    // This avoids potential issues with worker message queue blocking\n    this.worker.postMessage(buffer);\n  }\n\n  /**\n     * Finalize encoding and get the WebM file\n     * @returns {Promise<ArrayBuffer>} The complete WebM video data\n     */\n  async end() {\n    console.log(`[WebM Encoder] Finalizing encoding (${this.frameCount} total frames, ${this.videoChunks.length} chunks collected so far)`);\n\n    // Signal end of stream to worker\n    console.log('[WebM Encoder] Sending null to signal end of stream');\n    try {\n      this.worker.postMessage(null);\n    } catch (error) {\n      console.error('[WebM Encoder] Error sending null:', error);\n      return Promise.reject(new Error('Failed to signal end of stream'));\n    }\n\n    // Wait for worker to send the final null signal\n    return new Promise((resolve, reject) => {\n      // Set timeout - give more time for large videos\n      const timeout = setTimeout(() => {\n        console.error('[WebM Encoder] Timeout waiting for end signal from worker');\n        console.error(`[WebM Encoder] Chunks collected: ${this.videoChunks.length}`);\n        reject(new Error('WebM encoding failed - timeout waiting for end signal'));\n      }, 30000); // 30 seconds timeout for large videos\n\n      // Set the resolver that will be called when null is received\n      this.resolveEnd = (videoData) => {\n        clearTimeout(timeout);\n        if (videoData) {\n          console.log(`[WebM Encoder] Successfully finalized video: ${videoData.byteLength} bytes`);\n          resolve(videoData);\n        } else {\n          reject(new Error('WebM encoding failed - no video data'));\n        }\n      };\n    });\n  }\n\n  /**\n     * Cleanup and terminate the worker\n     */\n  destroy() {\n    console.log('[WebM Encoder] Destroying encoder');\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n    this.videoChunks = [];\n    this.resolveEnd = null;\n    this.frameCount = 0;\n  }\n}\n","/**\n * MapLibre GL Video Export Plugin\n *\n * Main entry point for the video export control\n */\n\n// @ts-check - Enable TypeScript checking for this file\n/* global maplibregl, __VERSION__ */\n\n/**\n * @callback AnimationFunction\n * @param {any} map - MapLibre map instance\n * @param {any} control - VideoExportControl instance\n * @param {VideoExportOptions} options - Export options\n * @param {any} [director] - AnimationDirector instance (optional)\n * @returns {Promise<any>}\n */\n\n/**\n * @callback AnimationWithSetup\n * @param {any} map - MapLibre map instance\n * @param {any} control - VideoExportControl instance\n * @param {VideoExportOptions} options - Export options\n * @returns {{ setup: Function, animation: Function, supportsExploration: boolean }}\n */\n\n/**\n * Helper to cast EventTarget to HTMLInputElement\n * @param {EventTarget | null} target\n * @returns {HTMLInputElement | null}\n */\n/**\n * @typedef {Object} VideoExportOptions\n * @property {Object|null} [resolution] - Video resolution\n * @property {number} [fps] - Frames per second\n * @property {number} [bitrate] - Video bitrate\n * @property {number} [speedMultiplier] - Animation speed multiplier\n * @property {boolean} [waitForTiles] - Wait for tiles to load\n * @property {string} [position] - Control position on map\n * @property {boolean} [collapsed] - Start collapsed\n * @property {string} [compactPosition] - Compact mode position\n * @property {string|Function} [animation] - Animation type or function\n * @property {number} [duration] - Animation duration in ms\n * @property {boolean|string} [loop] - Loop mode\n * @property {boolean} [explorationLimitEnabled] - Enable exploration duration limit\n * @property {number} [explorationMaxDuration] - Maximum exploration duration in ms\n * @property {any[]|null} [maxBounds] - Geographic bounds\n * @property {number|null} [minZoom] - Minimum zoom level\n * @property {number|null} [maxZoom] - Maximum zoom level\n * @property {boolean} [strictBounds] - Strict bounds enforcement\n * @property {boolean} [showBoundsOverlay] - Show bounds overlay\n * @property {any} [waypoints] - Animation waypoints (GeoJSON FeatureCollection)\n * @property {string} [format] - Video format (webm/mp4)\n * @property {string} [encoderPath] - Path to encoder\n * @property {string} [encoderCdn] - CDN URL for encoder\n * @property {Function} [onStart] - Start callback\n * @property {Function} [onProgress] - Progress callback\n * @property {Function} [onComplete] - Complete callback\n * @property {Function} [onError] - Error callback\n */\n\n// Import modules\nimport { AnimationConstraints, AnimationDirector, PresetAnimations } from './animations.js';\nimport { AnimationController } from './controller.js';\nimport { WebmEncoderWrapper } from './webm-encoder-wrapper.js';\n\nconst asInput = (target) => /** @type {HTMLInputElement | null} */(target);\n\n/**\n * Helper to cast EventTarget to HTMLSelectElement\n * @param {EventTarget | null} target\n * @returns {HTMLSelectElement | null}\n */\nconst asSelect = (target) => /** @type {HTMLSelectElement | null} */(target);\n\n/**\n * Helper to cast Element to HTMLElement\n * @param {Element | null} element\n * @returns {HTMLElement | null}\n */\nconst asHTMLElement = (element) => /** @type {HTMLElement | null} */(element);\n\n/**\n * Helper to cast Element to HTMLButtonElement\n * @param {Element | null} element\n * @returns {HTMLButtonElement | null}\n */\nconst asButton = (element) => /** @type {HTMLButtonElement | null} */(element);\n\n// ============================================================================\n\n// CDN URLs for dependencies (using jsDelivr for better CORS support)\nconst MP4_ENCODER_CDN = 'https://unpkg.com/mp4-h264@1.0.7/build/';\nconst WASM_FEATURE_DETECT_URL = 'https://unpkg.com/wasm-feature-detect?module';\n\n// Auto-detect plugin directory from import.meta.url\n// e.g. if plugin is at /js/video-export/index.js, pluginDir will be /js/video-export/\nconst getPluginDirectory = () => {\n  try {\n    const url = new URL(import.meta.url);\n    const path = url.pathname;\n    return path.substring(0, path.lastIndexOf('/') + 1);\n  } catch (e) {\n    return null;\n  }\n};\n\n// Detect if VP9 is supported in this browser\nconst isVP9Supported = () => {\n  return typeof VideoEncoder !== 'undefined' &&\n           typeof VideoFrame !== 'undefined';\n};\n\n// Get default format based on browser capabilities\nconst getDefaultFormat = () => {\n  if (isVP9Supported()) {\n    console.log('‚úì VP9 supported - using VP9 as default format (better quality/compression)');\n    return 'webm-vp9';\n  }\n  console.log('‚úì VP9 not available - using VP8 as default format');\n  return 'webm-vp8';\n};\n\n/**\n * Animation profiles with metadata\n * Structure: { key: { label, supportsExploration, group, requires, func } }\n *\n * requires: Array of capability names that this animation needs to work properly\n * Optional capabilities can be prefixed with '?' to indicate they enhance but aren't required\n */\nconst ANIMATION_PROFILES = {\n  // üß† Auto\n  smart: {\n    label: 'üß† Smart (Try to auto-detect map features)',\n    description: 'Animation that adapts to your map. Visits all waypoints if present, otherwise creates a dynamic tour based on detected features (roads, water, terrain).',\n    supportsExploration: false,\n    group: 'auto',\n    requires: [], // Smart adapts to whatever is available\n    /** @type {AnimationFunction} */\n    func: (map, control, options, director) => director.createAdaptiveAnimation(control, options)\n  },\n\n  // ‚ü≥ Seamless Loops ready\n  orbit: {\n    label: 'üîÑ 360¬∞ Orbit',\n    description: 'Smooth circular rotation around the center point. Perfect for creating seamless looping videos of a location from all angles.',\n    supportsExploration: false,\n    group: 'loops',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({\n      animation: async (m, callbacks, opts) => PresetAnimations.orbit360(m, callbacks, opts)\n    })\n  },\n  pulse: {\n    label: 'üíì Zoom Pulse',\n    description: 'Rhythmic zoom in and out from the center. Creates a breathing effect that draws attention to a specific area.',\n    supportsExploration: false,\n    group: 'loops',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({\n      animation: async (m, callbacks, opts) => PresetAnimations.zoomPulse(m, callbacks, opts)\n    })\n  },\n  orbitZoom: {\n    label: 'üåç Orbit Zoom',\n    description: 'Combines orbital rotation with gradual zoom. Reveals the location from wide view to close-up while circling around.',\n    supportsExploration: false,\n    group: 'loops',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({\n      animation: async (m, callbacks, opts) => PresetAnimations.orbitZoom(m, callbacks, opts)\n    })\n  },\n  waveMotion: {\n    label: 'üåä Wave Motion',\n    description: 'Flowing side-to-side motion with smooth camera movement. Especially effective for coastal areas and waterways.',\n    supportsExploration: false,\n    group: 'loops',\n    requires: ['?hasWater'], // Better with water\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({\n      animation: async (m, callbacks, opts) => PresetAnimations.waveMotion(m, callbacks, opts)\n    })\n  },\n  pendulum: {\n    label: '‚è±Ô∏è Pendulum',\n    description: 'Gentle swing motion back and forth. Creates a contemplative, hypnotic effect ideal for atmospheric backgrounds.',\n    supportsExploration: false,\n    group: 'loops',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({\n      animation: async (m, callbacks, opts) => PresetAnimations.pendulum(m, callbacks, opts)\n    })\n  },\n\n  // üé¨ Cinematic & POI\n  neighborhood: {\n    label: 'üèòÔ∏è Neighborhood Explorer',\n    description: 'Explores a neighborhood area with multiple perspectives and angles. Ideal for showcasing residential areas, community spaces, and local amenities.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: ['?hasPlaces', '?hasRoads'], // Better with places and roads\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.neighborhood(m, callbacks, opts) })\n  },\n  property: {\n    label: 'üè° Property Showcase',\n    description: 'Professional real estate presentation that circles around a property with strategic viewpoints. Perfect for property listings and architectural showcases.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: ['?has3DBuildings'], // Better with 3D buildings\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.propertyShowcase(m, callbacks, opts) })\n  },\n  explore: {\n    label: 'üß≠ Explore Around',\n    description: 'Dynamic exploration that moves through and around the area in all directions. Great for discovering locations and showing spatial relationships.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.exploreAround(m, callbacks, opts) })\n  },\n  panorama: {\n    label: 'üì∑ Panoramic Sweep',\n    description: 'Smooth horizontal sweep across the landscape. Captures wide vistas and creates a cinematic establishing shot effect.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.panorama(m, callbacks, opts) })\n  },\n  aerial: {\n    label: 'üöÅ Aerial Sweep',\n    description: 'High-altitude sweep with bird\\'s eye perspective. Excellent for showing large areas, urban layouts, and geographic context.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.aerialSweep(m, callbacks, opts) })\n  },\n  droneShot: {\n    label: 'üõ∏ Drone Shot',\n    description: 'Simulates professional drone cinematography with ascending and descending movements. Creates dramatic reveals and dynamic perspectives.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.droneShot(m, callbacks, opts) })\n  },\n  terrainFollowing: {\n    label: 'üèîÔ∏è Terrain Following',\n    description: 'Follows the natural contours of the landscape at low altitude. Spectacular for mountainous regions, valleys, and dramatic topography.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: ['?hasTerrain', '?hasHillshade'], // Better with terrain\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.terrainFollowing(m, callbacks, opts) })\n  },\n  spotlightScan: {\n    label: 'üî¶ Spotlight Scan',\n    description: 'Systematic scanning movement that reveals the area section by section. Perfect for methodical exploration and attention-grabbing presentations.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.spotlightScan(m, callbacks, opts) })\n  },\n  butterfly: {\n    label: 'ü¶ã Butterfly',\n    description: 'Graceful figure-8 pattern with smooth flowing movements. Creates an elegant, organic feel ideal for natural landscapes and parks.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.butterfly(m, callbacks, opts) })\n  },\n  figure8: {\n    label: '‚àû Figure-8',\n    description: 'Classic infinity-shaped path around two focal points. Versatile pattern that works well for comparing two areas or showing connections.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.figure8(m, callbacks, opts) })\n  },\n  spiral: {\n    label: 'üåÄ Spiral Zoom',\n    description: 'Spiraling motion while zooming in or out. Creates hypnotic, attention-drawing effect perfect for dramatic openings or closings.',\n    supportsExploration: false,\n    group: 'cinematic',\n    requires: [],\n    /** @type {AnimationFunction} */\n    func: (_map, _control, _options) => ({ animation: async (m, callbacks, opts) => PresetAnimations.spiralZoom(m, callbacks, opts) })\n  },\n\n  // üõ£Ô∏è Road Following (exploration-capable)\n  tractorRoadTrip: {\n    label: 'üöú Tractor Road Trip',\n    description: 'Leisurely journey along roads at tractor speed with smooth curves. Perfect for rural routes, countryside tours, and relaxed explorations.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasRoads'], // REQUIRES roads\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.tractorRoadTrip(map, control, options)\n  },\n  carRoadTrip: {\n    label: 'üöó Car Road Trip',\n    description: 'Moderate-speed road journey that follows streets and highways naturally. Great for urban navigation and everyday road perspectives.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasRoads'], // REQUIRES roads\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.carRoadTrip(map, control, options)\n  },\n  sportsCarRace: {\n    label: 'üèéÔ∏è Sports Car Race',\n    description: 'High-speed chase along roads with dynamic banking angles. Thrilling and fast-paced for action-oriented presentations.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasRoads'], // REQUIRES roads\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.sportsCarRace(map, control, options)\n  },\n  trainRide: {\n    label: 'üöÇ Train Ride',\n    description: 'Follows railway tracks at steady train speed with authentic rail perspective. Requires railways on the map.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasRailways'], // REQUIRES railways\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.trainRide(map, control, options)\n  },\n  speedboat: {\n    label: 'üö§ Speedboat',\n    description: 'Fast-paced journey along waterways with dynamic low angle. Exciting for rivers, canals, and coastal routes.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasWaterways'], // REQUIRES waterways\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.speedboat(map, control, options)\n  },\n  sailboat: {\n    label: '‚õµ Sailboat',\n    description: 'Graceful navigation across water bodies at sailing speed. Peaceful and scenic for lakes, bays, and open water.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasWater'], // REQUIRES water bodies\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.sailboat(map, control, options)\n  },\n  cruiseShip: {\n    label: 'üõ•Ô∏è Cruise Ship',\n    description: 'Stately movement across large water bodies with elevated viewpoint. Majestic perspective for oceans, large lakes, and harbors.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasWater'], // REQUIRES water bodies\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.cruiseShip(map, control, options)\n  },\n  droneFollow: {\n    label: 'üõ∏ Drone Follow',\n    description: 'Aerial tracking that follows roads from above with varying altitude. Modern perspective for documenting routes and infrastructure.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasRoads'], // REQUIRES roads\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.droneFollow(map, control, options)\n  },\n  helicopterTour: {\n    label: 'üöÅ Helicopter Tour',\n    description: 'High-altitude road following with sweeping movements and wide views. Professional aerial tour perspective.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasRoads'], // REQUIRES roads\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.helicopterTour(map, control, options)\n  },\n  birdsEyeRoad: {\n    label: 'ü¶Ö Bird\\'s Eye Road',\n    description: 'Top-down road following that maintains vertical perspective. Ideal for showing route patterns and spatial relationships.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasRoads'], // REQUIRES roads\n    /** @type {AnimationWithSetup} */\n    func: (map, control, options) => PresetAnimations.birdsEyeRoad(map, control, options)\n  },\n  planeFlight: {\n    label: '‚úàÔ∏è Plane Flight',\n    description: 'High-altitude journey with plane-like speed and perspective. Covers large distances quickly for regional overviews.',\n    supportsExploration: true,\n    group: 'road',\n    requires: ['hasRoads'], // REQUIRES roads\n    /** @type {AnimationWithSetup} */\n    func: (_map, _control, options) => ({ animation: async (m, callbacks) => PresetAnimations.waypointTour(m, callbacks, options) })\n  },\n\n  // üéØ Waypoint Tour\n  waypointTour: {\n    label: 'üó∫Ô∏è Visit All Waypoints',\n    description: 'Travels through your custom waypoints in order with smooth transitions. Perfect for guided tours, storytelling, and showcasing specific locations in sequence.',\n    supportsExploration: false,\n    group: 'waypoint',\n    requires: [], // Works with user-provided waypoints\n    /** @type {AnimationFunction} */\n    func: (_map, _control, options) => ({ animation: async (m, callbacks) => PresetAnimations.waypointTour(m, callbacks, options) })\n  }\n};\n\n// Group labels for the dropdown\nconst ANIMATION_GROUPS = {\n  auto: 'üß† Auto',\n  loops: '‚ü≥ Seamless Loops ready',\n  cinematic: 'üé¨ Cinematic & POI',\n  road: 'üõ£Ô∏è Road Following',\n  waypoint: 'üéØ Waypoint Tour'\n};\n\n/**\n * @class VideoExportControl\n * @property {string} _waypointsLayerId - MapLibre layer ID for waypoints\n * @property {string} _waypointsSourceId - MapLibre source ID for waypoints\n */\nclass VideoExportControl {\n  // Default settings for all inputs\n  static DEFAULT_SETTINGS = {\n    // Video settings\n    've-resolution': 'auto',\n    've-cinematic-bars': 'none',\n    've-duration': '30',\n    've-speed': '1',\n    've-fps': 60,\n    've-format': 'webm-vp9',\n    've-bitrate': 'auto',\n    've-wait-tiles': true,\n    've-format-advanced-toggle': false,\n\n    // Animation\n    've-animation': 'smart',\n    've-loop': 'false',\n    've-show-labels-toggle': false,\n    've-icon-size-slider': 1.0,\n\n    // Constraints\n    've-bounds-west': '',\n    've-bounds-east': '',\n    've-bounds-south': '',\n    've-bounds-north': '',\n    've-zoom-min': '',\n    've-zoom-max': '',\n    've-strict-bounds': false,\n    've-show-bounds': true,\n\n    // Format-specific settings\n    've-mp4-speed': '5',\n    've-mp4-qp': '10,42',\n    've-mp4-gop': '30',\n    've-vp8-bitrate-custom': '',\n    've-vp9-quality': 'high',\n    've-vp9-latency': 'quality',\n    've-vp9-bitrate-mode': 'variable',\n    've-vp9-keyframe': 120,\n    've-vp9-content-hint': ''\n  };\n\n  /**\n     * @param {VideoExportOptions} [options={}] - Configuration options\n     */\n  constructor(options = {}) {\n    this.options = {\n      // Video settings\n      resolution: options.resolution || 'auto', // 'auto', 'fullhd', 'hd', '4k', '8k', or {width, height}\n      fps: options.fps || 60,\n      bitrate: options.bitrate !== undefined ? options.bitrate : 'auto', // 'auto' or kbps value\n      speedMultiplier: options.speedMultiplier || 1, // Animation speed multiplier (1 = real-time)\n      waitForTiles: options.waitForTiles !== undefined ? options.waitForTiles : true, // Wait for tiles to load before each frame\n\n      // UI settings\n      position: options.position || 'top-left',\n      collapsed: options.collapsed !== false,\n      compactPosition: options.compactPosition || 'top-left', // Position when in compact mode: 'top-left', 'top-right', 'bottom-left', 'bottom-right'\n\n      // Animation\n      animation: options.animation || 'smart', // 'smart', 'orbit', 'pulse', or function\n      duration: options.duration || 30000, // Total animation duration in ms\n      loop: options.loop || false, // false, true/'instant', or 'smooth'\n\n      // Exploration limits\n      explorationLimitEnabled: options.explorationLimitEnabled !== undefined ? options.explorationLimitEnabled : false, // Enable/disable exploration duration limit\n      explorationMaxDuration: options.explorationMaxDuration || 300000, // Maximum exploration duration in ms (default: 5 minutes)\n\n      // Geographic constraints\n      maxBounds: options.maxBounds || null, // [[west, south], [east, north]] or LngLatBounds\n      minZoom: options.minZoom !== undefined ? options.minZoom : null, // Minimum zoom level (null = no limit)\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : null, // Maximum zoom level (null = no limit)\n      strictBounds: options.strictBounds || false, // If true, strictly enforce bounds (no partial view outside)\n      showBoundsOverlay: options.showBoundsOverlay !== undefined ? options.showBoundsOverlay : false, // Show visual bounds on map\n\n      // Waypoints (Points of Interest)\n      waypoints: options.waypoints || null, // Array of waypoint objects [{center: [lng, lat], zoom, duration, bearing, pitch, name, icon}]\n\n      // Video format - auto-detects VP9 support and uses it by default for better quality\n      format: options.format || getDefaultFormat(), // 'webm-vp8', 'webm-vp9' (default if supported), or 'mp4'\n\n      // Encoder paths - auto-detects plugin location first, then CDN fallback for MP4\n      encoderPath: options.encoderPath || null, // Custom path (optional)\n      encoderCdn: options.encoderCdn || MP4_ENCODER_CDN, // MP4 CDN fallback\n\n      // Callbacks\n      onStart: options.onStart || (() => {}),\n      onProgress: options.onProgress || (() => {}),\n      onComplete: options.onComplete || (() => {}),\n      onError: options.onError || ((err) => console.error('Video export error:', err))\n    };\n\n    this._map = null;\n    this._container = null;\n    this._animationController = new AnimationController();\n    this._encoder = null;\n    this._encoderLoaded = false;\n\n    // Waypoint icons from map sprite\n    /** @type {any[]} */\n    this._spriteIcons = [];\n    /** @type {any[]} */\n    this._waypointMarkers = []; // Array of maplibregl.Marker instances (draggable)\n    this._isRecording = false; // Flag to prevent marker recreation during recording\n    this._savedWaypointsVisibility = undefined; // Saved state during recording\n    this._waypointsLayerId = 've-waypoints-recording-layer'; // MapLibre layer ID for waypoints\n    this._waypointsSourceId = 've-waypoints-recording-source'; // MapLibre source ID for waypoints\n\n    // Initialize waypoints as GeoJSON FeatureCollection\n    if (!this.options.waypoints || !(this.options.waypoints).type) {\n      /** @type {any} */\n      this.options.waypoints = this._loadWaypoints();\n    }\n\n    // Sprite visual data\n    this._spriteImage = null; // PNG image complete\n    this._spriteData = null; // JSON metadata\n    this._spritePngUrl = null; // URL du sprite PNG pour CSS background-image\n\n    // Icon size multiplier for waypoints on map\n    this._iconSize = 1.0; // Default size multiplier\n\n    // Font management for waypoint labels\n    /** @type {string[]} */\n    this._availableFonts = []; // List of available fonts from fontstacks.json\n    this._selectedFont = null; // Currently selected font\n    this._showWaypointLabels = false; // Whether to show text labels on waypoints (default: icons only)\n\n    // Recording time tracking for ETA\n    this._recordingStartTime = null;\n  }\n\n  onAdd(map) {\n    this._map = map;\n\n    // Check MapLibre GL JS version for timeControl API support\n    this._checkMapLibreVersion();\n    this._container = document.createElement('div');\n    this._container.className = 'maplibregl-ctrl maplibre-gl-video-export-ctrl';\n\n    this._createUI();\n    // Encoder loaded on-demand when recording starts\n\n    // Load sprite icons and default waypoint icon when map style is ready\n    if (map.isStyleLoaded()) {\n      console.log('[VideoExport] Map style already loaded, loading sprites and default icon now');\n      this._checkMapCapabilities();\n      this._loadSpriteIcons();\n      this._addDefaultWaypointIcon();\n      // Create waypoints layer if we have waypoints\n      if (this.options.waypoints && this.options.waypoints.features && this.options.waypoints.features.length > 0) {\n        setTimeout(() => {\n          this._createWaypointsLayer();\n          this._createWaypointMarkers();\n          this._updateWaypointsUI();\n        }, 500); // Small delay to ensure sprites are loaded\n      }\n    } else {\n      console.log('[VideoExport] Waiting for map style to load...');\n      map.once('load', () => {\n        console.log('[VideoExport] Map style loaded, loading sprites and default icon now');\n        this._checkMapCapabilities();\n        this._loadSpriteIcons();\n        this._addDefaultWaypointIcon();\n        // Create waypoints layer if we have waypoints\n        if (this.options.waypoints && this.options.waypoints.features && this.options.waypoints.features.length > 0) {\n          setTimeout(() => {\n            this._createWaypointsLayer();\n            this._createWaypointMarkers();\n            this._updateWaypointsUI();\n          }, 500); // Small delay to ensure sprites are loaded\n        }\n      });\n    }\n\n    return this._container;\n  }\n\n  onRemove() {\n    // Cleanup encoder if exists\n    if (this._encoder) {\n      if (this._encoder.destroy) {\n        this._encoder.destroy(); // WebM encoder\n      } else if (this._encoder.delete) {\n        this._encoder.delete(); // MP4 encoder\n      }\n      this._encoder = null;\n    }\n\n    // Remove overlay and panel from map container\n    const mapContainer = this._map?.getContainer();\n    if (mapContainer) {\n      if (this._overlay && this._overlay.parentNode) {\n        this._overlay.parentNode.removeChild(this._overlay);\n      }\n      if (this._panel && this._panel.parentNode) {\n        this._panel.parentNode.removeChild(this._panel);\n      }\n    }\n\n    // Remove control button container\n    if (this._container && this._container.parentNode) {\n      this._container.parentNode.removeChild(this._container);\n    }\n\n    this._overlay = null;\n    this._panel = null;\n    this._container = null;\n    this._map = null;\n  }\n\n  /**\n     * Check MapLibre GL JS version and warn if timeControl API is not available\n     */\n  _checkMapLibreVersion() {\n    // Check if timeControl API is available (added in v5.10.0)\n    // Note: maplibregl.now() is not exported in official v5.10.0 (see https://github.com/maplibre/maplibre-gl-js/issues/6643)\n    // but we need it for animations. Check for the 3 functions that ARE exported.\n    const hasTimeControl = typeof maplibregl !== 'undefined' &&\n                              // @ts-ignore - timeControl API properties may not exist in older versions\n                              typeof maplibregl.setNow === 'function' &&\n                              typeof maplibregl.restoreNow === 'function' &&\n                              typeof maplibregl.isTimeFrozen === 'function';\n\n    if (!hasTimeControl) {\n      // @ts-ignore - version property exists at runtime but not in type definitions\n      const version = this._map && this._map.version ? this._map.version : 'unknown';\n      throw new Error(\n        'MapLibre GL JS v5.10.0 or higher is required for video recording. ' +\n                'The timeControl API (setNow, restoreNow, isTimeFrozen) is missing. ' +\n                'Please upgrade to MapLibre GL JS v5.10.0+. ' +\n                'Current version: ' + version\n      );\n    }\n\n    // Check if now() is available (required for animations but not exported in official v5.10.0)\n    // @ts-ignore\n    const hasNow = typeof maplibregl.now === 'function';\n    if (!hasNow) {\n      // @ts-ignore - version property exists at runtime but not in type definitions\n      const version = this._map && this._map.version ? this._map.version : 'unknown';\n      throw new Error(\n        'MapLibre GL JS with exported now() function is required for vehicle animations. ' +\n                'The official v5.10.0 does not export now() - see https://github.com/maplibre/maplibre-gl-js/issues/6643. ' +\n                'Please use a custom build of MapLibre that exports now() from time_control.ts. ' +\n                'Current version: ' + version\n      );\n    }\n\n    console.log('[VideoExport] ‚úì MapLibre GL JS timeControl API detected (including now())');\n  }\n\n  /**\n     * Generates HTML options for animation dropdown from ANIMATION_PROFILES\n     * @returns {string} HTML string with optgroups and options\n     */\n  _generateAnimationOptions() {\n    const groupedAnimations = {};\n\n    // Group animations by their group property\n    Object.entries(ANIMATION_PROFILES).forEach(([key, profile]) => {\n      if (!groupedAnimations[profile.group]) {\n        groupedAnimations[profile.group] = [];\n      }\n      groupedAnimations[profile.group].push({ key, ...profile });\n    });\n\n    // Generate HTML for each group\n    let html = '';\n    Object.entries(ANIMATION_GROUPS).forEach(([groupKey, groupLabel]) => {\n      if (groupedAnimations[groupKey]) {\n        // Special handling for road group - initially hidden\n        const groupStyle = groupKey === 'road' ? ' style=\"display: none;\"' : '';\n        const groupId = groupKey === 'road' ? ' id=\"ve-road-animations-group\"' : '';\n\n        html += `<optgroup label=\"${groupLabel}\"${groupId}${groupStyle}>`;\n\n        groupedAnimations[groupKey].forEach(anim => {\n          const selected = anim.key === this.options.animation ? ' selected' : '';\n          html += `<option value=\"${anim.key}\"${selected}>&nbsp;&nbsp;${anim.label}</option>`;\n        });\n\n        html += '</optgroup>';\n      }\n    });\n\n    return html;\n  }\n\n  /**\n     * Load settings from localStorage or return defaults\n     * @returns {Object} Settings object\n     */\n  _loadSettings() {\n    const saved = localStorage.getItem('maplibre-video-export-settings');\n    return saved ? JSON.parse(saved) : VideoExportControl.DEFAULT_SETTINGS;\n  }\n\n  /**\n     * Apply settings to UI inputs and trigger change events\n     * Handles smart sequencing for select/custom field pairs using naming convention\n     * @param {Object} settings - Settings object with input IDs as keys\n     */\n  _applySettings(settings) {\n    // First pass: force parent selects to 'custom' when custom values are present\n    Object.entries(settings).forEach(([id, value]) => {\n      // Skip empty/null values\n      if (value === '' || value === undefined || value === null) return;\n\n      // Detect custom fields by naming convention: *-custom\n      if (id.endsWith('-custom')) {\n        // Extract parent select ID\n        // Examples:\n        //   've-speed-custom' ‚Üí 've-speed'\n        //   've-duration-custom' ‚Üí 've-duration'\n        //   've-resolution-width-custom' ‚Üí 've-resolution'\n        //   've-resolution-height-custom' ‚Üí 've-resolution'\n        let parentId = id.replace(/-custom$/, '');\n\n        // Special handling for resolution: remove -width/-height suffixes\n        parentId = parentId.replace(/-(width|height)$/, '');\n\n        // Find and update parent select\n        const selectEl = document.getElementById(parentId);\n        if (selectEl && selectEl.tagName === 'SELECT') {\n          selectEl.value = 'custom';\n        }\n      }\n    });\n\n    // Second pass: apply all values and trigger change events\n    Object.entries(settings).forEach(([id, value]) => {\n      const el = document.getElementById(id);\n      if (!el) return;\n\n      if (el.type === 'checkbox') {\n        el.checked = value;\n      } else {\n        el.value = value;\n      }\n\n      // Trigger change event to update dependent UI elements\n      el.dispatchEvent(new Event('change'));\n    });\n  }\n\n  /**\n     * Save current settings to localStorage\n     * Scans all input/select/textarea elements with IDs starting with \"ve-\"\n     * Only saves -custom values when their parent select is set to 'custom'\n     */\n  _saveSettings() {\n    const settings = {};\n\n    // Scanner uniquement les inputs/selects/textarea avec ID ve-*\n    this._panel.querySelectorAll('input[id^=\"ve-\"], select[id^=\"ve-\"], textarea[id^=\"ve-\"]').forEach(el => {\n      if (el.type === 'checkbox') {\n        settings[el.id] = el.checked;\n      } else if (el.value !== '') {\n        // Si c'est un champ -custom, v√©rifier que le select parent est sur 'custom'\n        if (el.id.endsWith('-custom')) {\n          let parentId = el.id.replace(/-custom$/, '');\n          // Special handling for resolution: remove -width/-height suffixes\n          parentId = parentId.replace(/-(width|height)$/, '');\n          const selectEl = document.getElementById(parentId);\n\n          // Sauvegarder seulement si le parent est sur 'custom'\n          if (selectEl?.value === 'custom') {\n            settings[el.id] = el.value;\n          }\n        } else {\n          settings[el.id] = el.value;\n        }\n      }\n    });\n\n    localStorage.setItem('maplibre-video-export-settings', JSON.stringify(settings));\n  }\n\n  /**\n   * Load waypoints from localStorage or return empty collection\n   * @returns {Object} GeoJSON FeatureCollection\n   */\n  _loadWaypoints() {\n    const saved = localStorage.getItem('maplibre-video-export-waypoints');\n    if (saved) {\n      try {\n        return JSON.parse(saved);\n      } catch (e) {\n        console.warn('[Waypoints] Failed to parse saved waypoints:', e);\n      }\n    }\n    return {\n      type: 'FeatureCollection',\n      features: []\n    };\n  }\n\n  /**\n   * Save waypoints to localStorage\n   */\n  _saveWaypoints() {\n    if (!this.options.waypoints) return;\n    try {\n      localStorage.setItem('maplibre-video-export-waypoints', JSON.stringify(this.options.waypoints));\n      console.log(`[Waypoints] Saved ${this.options.waypoints.features?.length || 0} waypoints to localStorage`);\n    } catch (e) {\n      console.error('[Waypoints] Failed to save waypoints:', e);\n    }\n  }\n\n  /**\n   * Load section collapse states from localStorage\n   * @returns {Object} Section states\n   */\n  _loadSectionStates() {\n    const saved = localStorage.getItem('maplibre-video-export-sections');\n    const defaults = {\n      'video-settings': false, // Open by default\n      movie: false, // Open by default\n      'points-of-interest': true, // Collapsed by default\n      'geographic-constraints': true // Collapsed by default\n    };\n    return saved ? { ...defaults, ...JSON.parse(saved) } : defaults;\n  }\n\n  /**\n   * Save section collapse states to localStorage\n   */\n  _saveSectionStates() {\n    if (!this._sectionStates) return;\n    localStorage.setItem('maplibre-video-export-sections', JSON.stringify(this._sectionStates));\n  }\n\n  /**\n   * Toggle a collapsible section\n   * @param {string} sectionId - Section identifier\n   */\n  _toggleSection(sectionId) {\n    if (!this._sectionStates) this._sectionStates = this._loadSectionStates();\n\n    const header = this._panel?.querySelector(`[data-section=\"${sectionId}\"]`);\n    const content = this._panel?.querySelector(`[data-section-content=\"${sectionId}\"]`);\n    const indicator = header?.querySelector('.section-indicator');\n\n    if (!header || !content) return;\n\n    // Toggle state\n    const isCollapsed = !this._sectionStates[sectionId];\n    this._sectionStates[sectionId] = isCollapsed;\n\n    // Update UI\n    if (content instanceof HTMLElement) {\n      content.style.display = isCollapsed ? 'none' : 'block';\n    }\n    if (indicator) indicator.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';\n\n    // Save to localStorage\n    this._saveSectionStates();\n\n    console.log(`[UI] Section \"${sectionId}\" ${isCollapsed ? 'collapsed' : 'expanded'}`);\n  }\n\n  _collapseSection(sectionId) {\n    if (!this._sectionStates) this._sectionStates = this._loadSectionStates();\n\n    const header = this._panel?.querySelector(`[data-section=\"${sectionId}\"]`);\n    const content = this._panel?.querySelector(`[data-section-content=\"${sectionId}\"]`);\n    const indicator = header?.querySelector('.section-indicator');\n\n    if (!header || !content) return;\n\n    // Force collapse\n    this._sectionStates[sectionId] = true;\n\n    // Update UI\n    if (content instanceof HTMLElement) {\n      content.style.display = 'none';\n    }\n    if (indicator) indicator.textContent = '‚ñ∂';\n\n    // Save to localStorage\n    this._saveSectionStates();\n\n    console.log(`[UI] Section \"${sectionId}\" collapsed`);\n  }\n\n  _createUI() {\n    if (!this._container) return;\n\n    // Button group (like NavigationControl)\n    const group = document.createElement('div');\n    group.className = 'maplibregl-ctrl-group';\n\n    const button = document.createElement('button');\n    button.className = 'maplibregl-ctrl-icon';\n    button.type = 'button';\n    button.title = 'Export Video';\n    button.innerHTML = `\n            <svg width=\"30\" height=\"30\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\">\n                <circle cx=\"12\" cy=\"12\" r=\"10\" stroke-width=\"2\"/>\n                <path d=\"M10 8l6 4-6 4V8z\" fill=\"currentColor\"/>\n                <circle cx=\"18\" cy=\"6\" r=\"3\" fill=\"#ef4444\" stroke=\"#b91c1c\" stroke-width=\"1\"/>\n            </svg>\n        `;\n\n    button.addEventListener('click', () => this._togglePanel());\n    group.appendChild(button);\n\n    // Create progress widget in ctrl-group\n    this._progressWidget = document.createElement('div');\n    this._progressWidget.className = 'maplibregl-ctrl-progress-widget';\n    this._progressWidget.style.display = 'none';\n    this._progressWidget.innerHTML = `\n            <style>\n                .maplibregl-ctrl-progress-widget {\n                    background: rgba(255, 255, 255, 0.95);\n                    border-radius: 6px;\n                    padding: 12px;\n                    margin-top: 12px;\n                    border: 1px solid rgba(0, 0, 0, 0.1);\n                    font-size: 12px;\n                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n                    line-height: 1.5;\n                    color: #333;\n                }\n                .maplibregl-ctrl-progress-widget .progress-status {\n                    color: #555;\n                    font-weight: 500;\n                    font-size: 11px;\n                    text-transform: uppercase;\n                    letter-spacing: 0.5px;\n                }\n                .maplibregl-ctrl-progress-widget .progress-percent {\n                    color: #4CAF50;\n                    font-weight: 600;\n                    font-size: 14px;\n                }\n                .maplibregl-ctrl-progress-widget .progress-time {\n                    color: #1976D2;\n                    font-weight: 500;\n                }\n                .maplibregl-ctrl-progress-widget .progress-secondary {\n                    color: #888;\n                }\n                .maplibregl-ctrl-progress-widget .progress-separator {\n                    color: #888;\n                }\n                /* Override MapLibre popup constraints for waypoint popups */\n                .maplibregl-popup-content:has(.ve-waypoint-popup) {\n                    max-width: none !important;\n                    padding: 10px !important;\n                }\n                .maplibregl-popup {\n                    max-width: none !important;\n                }\n                .ve-waypoint-popup {\n                    box-sizing: border-box;\n                }\n                .ve-waypoint-popup h3 {\n                    margin: 0 0 8px 0 !important;\n                }\n\n                @media (prefers-color-scheme: dark) {\n                    .maplibregl-ctrl-progress-widget {\n                        background: rgba(42, 42, 42, 0.95);\n                        color: #e0e0e0;\n                        border-color: rgba(255, 255, 255, 0.1);\n                    }\n                    .maplibregl-ctrl-progress-widget .progress-status {\n                        color: #999;\n                    }\n                }\n            </style>\n            <div style=\"margin-bottom: 3px;\">\n                <span class=\"progress-status\" id=\"ve-progress-status\">Recording</span>\n            </div>\n            <div>\n                <span class=\"progress-percent\" id=\"ve-progress-percent\">0% complete</span>\n                <span class=\"progress-separator\" style=\"margin: 0 4px;\">‚Ä¢</span>\n                <span class=\"progress-secondary\" id=\"ve-progress-frames\">Frame 0 of 0</span>\n            </div>\n            <div style=\"margin-top: 2px; font-size: 11px;\">\n                <span class=\"progress-secondary\" id=\"ve-progress-size\">Size: ~0 MB</span>\n                <span class=\"progress-separator\" style=\"margin: 0 4px;\">‚Ä¢</span>\n                <span class=\"progress-time\" id=\"ve-progress-time\">calculating time...</span>\n            </div>\n            <!-- Final stats summary (hidden during recording, shown at end) -->\n            <div id=\"ve-progress-summary\" style=\"display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0,0,0,0.1);\">\n                <div style=\"margin-bottom: 4px;\">\n                    <span class=\"progress-status\">‚úÖ Export Complete</span>\n                </div>\n                <div style=\"font-size: 11px; line-height: 1.6;\">\n                    <div><strong>Video:</strong> <span id=\"ve-summary-video\">-</span></div>\n                    <div><strong>Real time:</strong> <span id=\"ve-summary-realtime\">-</span></div>\n                    <div><strong>Speed:</strong> <span id=\"ve-summary-speed\">-</span></div>\n                    <div><strong>Size:</strong> <span id=\"ve-summary-size\">-</span></div>\n                </div>\n            </div>\n        `;\n    // Don't add to group - will be added to panel instead\n\n    this._container.appendChild(group);\n\n    // Create hidden panel\n    this._panel = document.createElement('div');\n    this._panel.className = 'maplibre-gl-video-export-panel';\n    this._panel.style.display = 'none';\n    this._panel.innerHTML = `\n            <style>\n                /* Invisible overlay to capture clicks outside panel */\n                .maplibre-gl-video-export-overlay {\n                    position: absolute;\n                    top: 0;\n                    left: 0;\n                    right: 0;\n                    bottom: 0;\n                    z-index: 999;\n                    opacity: 0;\n                    pointer-events: none;\n                }\n\n                .maplibre-gl-video-export-overlay[data-visible=\"true\"] {\n                    opacity: 1;\n                    pointer-events: auto;\n                }\n\n                /* Centered panel within map container */\n                .maplibre-gl-video-export-panel {\n                    position: absolute;\n                    top: 50%;\n                    left: 50%;\n                    transform: translate(-50%, calc(-50% + 20px)) scale(0.95);\n                    background: rgba(255, 255, 255, 0.95);\n                    border-radius: 12px;\n                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);\n                    padding: 20px;\n                    width: 420px;\n                    max-width: 90%;\n                    max-height: 90%;\n                    overflow-y: auto;\n                    z-index: 1000;\n                    opacity: 0;\n                    transition: opacity 0.3s ease-out, transform 0.3s ease-out;\n                    pointer-events: none;\n                    height: auto;\n                }\n\n                .maplibre-gl-video-export-panel[data-visible=\"true\"] {\n                    opacity: 1;\n                    transform: translate(-50%, -50%) scale(1);\n                    pointer-events: auto;\n                }\n\n                /* Compact mode: panel positioning during test/record */\n                .maplibre-gl-video-export-panel.compact-top-left {\n                    top: 10px;\n                    left: 10px;\n                    transform: translate(-20px, -20px) scale(0.95);\n                    min-width: 280px;\n                    max-width: 320px;\n                }\n\n                .maplibre-gl-video-export-panel.compact-top-left[data-visible=\"true\"] {\n                    transform: translate(0, 0) scale(1);\n                }\n\n                .maplibre-gl-video-export-panel.compact-top-right {\n                    top: 10px;\n                    right: 10px;\n                    left: auto;\n                    transform: translate(20px, -20px) scale(0.95);\n                    min-width: 280px;\n                    max-width: 320px;\n                }\n\n                .maplibre-gl-video-export-panel.compact-top-right[data-visible=\"true\"] {\n                    transform: translate(0, 0) scale(1);\n                }\n\n                .maplibre-gl-video-export-panel.compact-bottom-left {\n                    bottom: 10px;\n                    left: 10px;\n                    top: auto;\n                    transform: translate(-20px, 20px) scale(0.95);\n                    min-width: 280px;\n                    max-width: 320px;\n                }\n\n                .maplibre-gl-video-export-panel.compact-bottom-left[data-visible=\"true\"] {\n                    transform: translate(0, 0) scale(1);\n                }\n\n                .maplibre-gl-video-export-panel.compact-bottom-right {\n                    bottom: 10px;\n                    right: 10px;\n                    top: auto;\n                    left: auto;\n                    transform: translate(20px, 20px) scale(0.95);\n                    min-width: 280px;\n                    max-width: 320px;\n                }\n\n                .maplibre-gl-video-export-panel.compact-bottom-right[data-visible=\"true\"] {\n                    transform: translate(0, 0) scale(1);\n                }\n\n                /* Smooth scrollbar for panel content */\n                .maplibre-gl-video-export-panel::-webkit-scrollbar {\n                    width: 8px;\n                }\n\n                .maplibre-gl-video-export-panel::-webkit-scrollbar-track {\n                    background: rgba(0, 0, 0, 0.05);\n                    border-radius: 4px;\n                }\n\n                .maplibre-gl-video-export-panel::-webkit-scrollbar-thumb {\n                    background: rgba(0, 0, 0, 0.2);\n                    border-radius: 4px;\n                }\n\n                .maplibre-gl-video-export-panel::-webkit-scrollbar-thumb:hover {\n                    background: rgba(0, 0, 0, 0.3);\n                }\n\n                @media (prefers-color-scheme: dark) {\n                    .maplibre-gl-video-export-panel {\n                        background: rgba(40, 40, 40, 0.95);\n                        color: #e0e0e0;\n                    }\n                    .maplibre-gl-video-export-panel::-webkit-scrollbar-track {\n                        background: rgba(255, 255, 255, 0.05);\n                    }\n                    .maplibre-gl-video-export-panel::-webkit-scrollbar-thumb {\n                        background: rgba(255, 255, 255, 0.2);\n                    }\n                    .maplibre-gl-video-export-panel::-webkit-scrollbar-thumb:hover {\n                        background: rgba(255, 255, 255, 0.3);\n                    }\n                }\n                .maplibre-gl-video-export-panel h3 {\n                    margin: 0 0 10px 0;\n                    font-size: 14px;\n                    color: #333;\n                }\n                .maplibre-gl-video-export-panel .form-group {\n                    margin-bottom: 10px;\n                }\n                .maplibre-gl-video-export-panel label {\n                    display: block;\n                    font-size: 12px;\n                    margin-bottom: 3px;\n                    color: #666;\n                }\n                .maplibre-gl-video-export-panel select,\n                .maplibre-gl-video-export-panel input[type=\"number\"],\n                .maplibre-gl-video-export-panel input[type=\"text\"] {\n                    width: 100%;\n                    padding: 5px;\n                    border: 1px solid #ddd;\n                    border-radius: 3px;\n                    font-size: 12px;\n                }\n                .maplibre-gl-video-export-panel input[type=\"checkbox\"] {\n                    margin: 0 6px 0 0;\n                    padding: 0;\n                    vertical-align: middle;\n                }\n                .maplibre-gl-video-export-panel label:has(input[type=\"checkbox\"]) {\n                    display: block;\n                    cursor: pointer;\n                    margin-bottom: 5px;\n                    line-height: 1.4;\n                }\n\n                /* Timing Table - Style 2 (Subtle Background) */\n                .ve-timing-table {\n                    width: 100%;\n                    border-collapse: collapse;\n                    border: 1px solid #dee2e6;\n                    border-radius: 4px;\n                    overflow: hidden;\n                }\n                .ve-timing-table th {\n                    font-size: 11px;\n                    font-weight: 500;\n                    padding: 8px 10px;\n                    text-align: left;\n                    background: #f8f9fa;\n                    border-bottom: 1px solid #dee2e6;\n                    color: #495057;\n                }\n                .ve-timing-table td {\n                    padding: 8px 10px;\n                    background: white;\n                }\n                .ve-timing-table th + th,\n                .ve-timing-table td + td {\n                    border-left: 1px solid #dee2e6;\n                }\n                /* Column widths (anti-jumping) */\n                .ve-timing-table th:nth-child(1),\n                .ve-timing-table td:nth-child(1) {\n                    width: 50%;\n                }\n                .ve-timing-table th:nth-child(2),\n                .ve-timing-table td:nth-child(2) {\n                    width: 30%;\n                }\n                .ve-timing-table th:nth-child(3),\n                .ve-timing-table td:nth-child(3) {\n                    width: 20%;\n                }\n                .ve-timing-table select,\n                .ve-timing-table input[type=\"number\"] {\n                    padding: 4px 6px;\n                    font-size: 12px;\n                    border: 1px solid #ccc;\n                    border-radius: 3px;\n                }\n                .ve-timing-table abbr {\n                    text-decoration: none;\n                    border-bottom: 1px dotted #999;\n                    cursor: help;\n                }\n\n                .maplibre-gl-video-export-panel .recording-time-display {\n                    text-align: center;\n                    padding: 10px;\n                    margin-top: 15px;\n                    margin-bottom: 10px;\n                    background: #e3f2fd;\n                    border-radius: 4px;\n                    font-size: 14px;\n                    color: #1976d2;\n                }\n                .maplibre-gl-video-export-panel .button-group {\n                    display: flex;\n                    gap: 10px;\n                }\n                .maplibre-gl-video-export-panel button {\n                    flex: 1;\n                    padding: 8px;\n                    border: none;\n                    border-radius: 4px;\n                    font-size: 12px;\n                    cursor: pointer;\n                    transition: background 0.2s;\n                    min-height: 36px;\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                }\n                .maplibre-gl-video-export-panel .btn-primary {\n                    background: #3887be;\n                    color: white;\n                }\n                .maplibre-gl-video-export-panel .btn-primary:hover {\n                    background: #2e7bb3;\n                }\n                .maplibre-gl-video-export-panel .btn-secondary {\n                    background: #f0f0f0;\n                    color: #333;\n                }\n                .maplibre-gl-video-export-panel .btn-secondary:hover {\n                    background: #e0e0e0;\n                }\n                .maplibre-gl-video-export-panel .btn-compact {\n                    padding: 6px !important; /* Smaller buttons for compact areas */\n                    font-size: 11px;\n                }\n                .maplibre-gl-video-export-panel .btn-mini {\n                    padding: 4px !important; /* Mini buttons for tight spaces */\n                    font-size: 11px;\n                }\n                .maplibre-gl-video-export-panel .status {\n                    margin-top: 10px;\n                    padding: 8px;\n                    background: #f0f0f0;\n                    border-radius: 3px;\n                    font-size: 11px;\n                    text-align: center;\n                    color: #666;\n                }\n                .maplibre-gl-video-export-ctrl > .maplibregl-ctrl-group {\n                    border-bottom-right-radius: unset;\n                    border-bottom-left-radius: unset;\n                }\n                .maplibre-gl-video-export-panel .status.recording {\n                    background: #ffebee;\n                    color: #c62828;\n                    animation: pulse 1s infinite;\n                }\n                .maplibre-gl-video-export-panel .status.success {\n                    background: #e8f5e9;\n                    color: #2e7d32;\n                }\n                .maplibre-gl-video-export-panel .status.error {\n                    background: #ffebee;\n                    color: #c62828;\n                }\n                small {\n                    font-size: 0.9em;\n                }\n                @keyframes pulse {\n                    0%, 100% { opacity: 1; }\n                    50% { opacity: 0.7; }\n                }\n\n                /* Dark mode support */\n                @media (prefers-color-scheme: dark) {\n                    /* Control group and button dark mode */\n                    .maplibre-gl-video-export-ctrl .maplibregl-ctrl-group {\n                        background: #2d2d2d;\n                    }\n                    .maplibre-gl-video-export-ctrl .maplibregl-ctrl-group button {\n                        background: transparent;\n                        border: none;\n                        color: #e0e0e0;  /* currentColor h√©rite de cette couleur */\n                    }\n                    .maplibre-gl-video-export-ctrl .maplibregl-ctrl-group button:hover {\n                        background: rgba(255, 255, 255, 0.1);\n                    }\n\n                    /* Panel dark mode */\n                    .maplibre-gl-video-export-panel {\n                        background: #2d2d2d;\n                        box-shadow: 0 2px 8px rgba(0,0,0,0.5);\n                    }\n                    .maplibre-gl-video-export-panel h3 {\n                        color: #e0e0e0;\n                    }\n                    .maplibre-gl-video-export-panel label {\n                        color: #b0b0b0;\n                    }\n                    .maplibre-gl-video-export-panel select,\n                    .maplibre-gl-video-export-panel input {\n                        background: #3d3d3d;\n                        border: 1px solid #555;\n                        color: #e0e0e0;\n                    }\n                    .maplibre-gl-video-export-panel select option {\n                        background: #3d3d3d;\n                        color: #e0e0e0;\n                    }\n                    .maplibre-gl-video-export-panel .btn-secondary {\n                        background: #3d3d3d;\n                        color: #e0e0e0;\n                    }\n                    .maplibre-gl-video-export-panel .btn-secondary:hover {\n                        background: #4d4d4d;\n                    }\n                    .maplibre-gl-video-export-panel .status {\n                        background: #3d3d3d;\n                        color: #b0b0b0;\n                    }\n                    .maplibre-gl-video-export-panel .status.recording {\n                        background: #4d2020;\n                        color: #ff8a80;\n                    }\n                    .maplibre-gl-video-export-panel .status.success {\n                        background: #1b4d1b;\n                        color: #81c784;\n                    }\n                    .maplibre-gl-video-export-panel .status.error {\n                        background: #4d2020;\n                        color: #ff8a80;\n                    }\n                    .maplibre-gl-video-export-panel small {\n                        color: #888 !important;\n                    }\n                    .maplibre-gl-video-export-panel .recording-time-display {\n                        background: #1e3a5f;\n                        color: #64b5f6;\n                    }\n                    /* Additional dark mode support for waypoints */\n                    .ve-waypoint-item {\n                        background: #2a2a2a !important;\n                        color: #e0e0e0 !important;\n                    }\n                    #ve-icon-size-control {\n                        background: rgba(42, 42, 42, 0.8) !important;\n                    }\n                    #ve-waypoint-editor {\n                        border-top-color: #444 !important;\n                    }\n                    #ve-icon-preview {\n                        background: #333 !important;\n                        border-color: #444 !important;\n                    }\n                    #ve-waypoints-list {\n                        background: transparent !important;\n                    }\n                    .ve-wp-edit {\n                        background: #1a5490 !important;\n                    }\n                    .ve-wp-delete {\n                        background: #aa3333 !important;\n                    }\n                    #ve-wp-save {\n                        background: #2a6b2a !important;\n                    }\n                    #ve-icon-size-value {\n                        color: #b0b0b0 !important;\n                    }\n                    /* Section groups dark mode */\n                    #ve-video-settings-group,\n                    #ve-movie-group,\n                    #ve-waypoints-group,\n                    #ve-constraints-group {\n                        background: rgba(255, 255, 255, 0.03) !important;\n                        border-color: #444 !important;\n                        box-shadow: 0 1px 3px rgba(0,0,0,0.2) !important;\n                    }\n                    #ve-waypoints-group > div:first-child span {\n                        color: #b0b0b0 !important;\n                    }\n                    #ve-waypoints-group > div:first-child {\n                        border-bottom-color: rgba(255,255,255,0.1) !important;\n                    }\n                    #ve-constraints-group > div:first-child span {\n                        color: #b0b0b0 !important;\n                    }\n                    #ve-constraints-group > div:first-child {\n                        border-bottom-color: rgba(255,255,255,0.1) !important;\n                    }\n                    /* Timing table dark mode */\n                    .ve-timing-table {\n                        border-color: #444;\n                    }\n                    .ve-timing-table th {\n                        background: #3d3d3d;\n                        border-bottom-color: #444;\n                        color: #b0b0b0;\n                    }\n                    .ve-timing-table td {\n                        background: #2a2a2a;\n                    }\n                    .ve-timing-table th + th,\n                    .ve-timing-table td + td {\n                        border-left-color: #444;\n                    }\n                    #ve-real-time {\n                        color: #888 !important;\n                    }\n                    /* Waypoint popup dark mode */\n                    .maplibregl-popup-content {\n                        background: #2d2d2d !important;\n                        color: #e0e0e0 !important;\n                    }\n                    .maplibregl-popup-content h3 {\n                        color: #e0e0e0 !important;\n                    }\n                    .maplibregl-popup-content label {\n                        color: #b0b0b0 !important;\n                    }\n                    .maplibregl-popup-content small {\n                        color: #888 !important;\n                    }\n                    .maplibregl-popup-content input,\n                    .maplibregl-popup-content select {\n                        background: #3d3d3d !important;\n                        color: #e0e0e0 !important;\n                        border-color: #555 !important;\n                    }\n                    .maplibregl-popup-content input:disabled {\n                        background: #2a2a2a !important;\n                        color: #666 !important;\n                    }\n                    .maplibregl-popup-content input::placeholder {\n                        color: #666 !important;\n                    }\n                    /* Popup icon preview dark mode */\n                    .maplibregl-popup-content [id^=\"ve-popup-icon-preview-\"] {\n                        background: #3d3d3d !important;\n                        border-color: #555 !important;\n                    }\n                    /* Popup buttons dark mode */\n                    .maplibregl-popup-content .ve-popup-save {\n                        background: #2e7d32 !important;\n                    }\n                    .maplibregl-popup-content .ve-popup-cancel {\n                        background: #666 !important;\n                    }\n                    .maplibregl-popup-content .ve-popup-delete {\n                        background: #c62828 !important;\n                    }\n                    .maplibregl-popup-tip {\n                        border-top-color: #2d2d2d !important;\n                        border-bottom-color: #2d2d2d !important;\n                    }\n                    /* Popup scrollbar dark mode */\n                    .ve-waypoint-popup::-webkit-scrollbar {\n                        width: 8px;\n                    }\n                    .ve-waypoint-popup::-webkit-scrollbar-track {\n                        background: rgba(255, 255, 255, 0.05);\n                        border-radius: 4px;\n                    }\n                    .ve-waypoint-popup::-webkit-scrollbar-thumb {\n                        background: rgba(255, 255, 255, 0.2);\n                        border-radius: 4px;\n                    }\n                    .ve-waypoint-popup::-webkit-scrollbar-thumb:hover {\n                        background: rgba(255, 255, 255, 0.3);\n                    }\n                }\n            </style>\n\n            <!-- Reset button -->\n            <div style=\"margin-bottom: 15px; text-align: right;\">\n                <a href=\"#\" id=\"ve-reset-defaults\" style=\"font-size: 11px; color: #666; text-decoration: none; padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; display: inline-block;\">‚Üª Reset to Defaults</a>\n            </div>\n\n            <!-- Reset message (hidden by default) -->\n            <div id=\"ve-reset-message\" style=\"display: none; background: #fff3cd; border: 1px solid #ffc107; color: #856404; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 12px;\">\n                Settings reset to defaults. <a href=\"#\" id=\"ve-cancel-reset\" style=\"color: #856404; font-weight: bold;\">Cancel</a> or Run to save.\n            </div>\n\n            <!-- VIDEO SETTINGS Section -->\n\n            <h3 data-section=\"video-settings\" style=\"cursor: pointer; user-select: none;\">\n              <span class=\"section-indicator\">‚ñº</span> üé¨ VIDEO SETTINGS\n            </h3>\n\n            <div data-section-content=\"video-settings\">\n\n              <div id=\"ve-video-settings-group\" style=\"padding: 15px; background: rgba(0,0,0,0.05); border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);\">\n\n                  <!-- Section Header -->\n                  <div style=\"margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(0,0,0,0.1);\">\n                      <span style=\"font-size: 11px; font-weight: 600; color: #555; text-transform: uppercase; letter-spacing: 0.5px;\">\n                        Configuration\n                      </span>\n                  </div>\n\n              <div class=\"form-group\">\n                  <label for=\"ve-resolution\"><h4>Resolution</h4></label>\n                  <select id=\"ve-resolution\">\n                      <option value=\"auto\" selected>Auto (Current Size)</option>\n                      <option value=\"hd\">HD (1280√ó720)</option>\n                      <option value=\"fullhd\">Full HD (1920√ó1080)</option>\n                      <option value=\"4k\">4K (3840√ó2160)</option>\n                      <option value=\"8k\">8K (7680√ó4320)</option>\n                      <option value=\"custom\">Custom...</option>\n                  </select>\n              </div>\n\n              <div class=\"form-group\">\n                  <label for=\"ve-cinematic-bars\"><h4>Cinematic Bars</h4></label>\n                  <select id=\"ve-cinematic-bars\">\n                      <option value=\"none\" selected>None</option>\n                      <option value=\"2.39\">2.39:1 (Scope)</option>\n                      <option value=\"1.85\">1.85:1 (Cinema)</option>\n                      <option value=\"2.33\">21:9 (Ultrawide)</option>\n                  </select>\n                  <small style=\"color: #999;\">Add black bars for cinematic aspect ratios</small>\n              </div>\n\n              <div class=\"form-group\" id=\"ve-resolution-custom-group\" style=\"display:none;\">\n                  <label>Custom Resolution</label>\n                  <div style=\"display: flex; gap: 5px; align-items: center;\">\n                      <input type=\"number\" id=\"ve-resolution-width-custom\" value=\"1920\" step=\"16\" placeholder=\"Width\" style=\"flex: 1;\">\n                      <span style=\"color: #999;\">√ó</span>\n                      <input type=\"number\" id=\"ve-resolution-height-custom\" value=\"1080\" step=\"16\" placeholder=\"Height\" style=\"flex: 1;\">\n                  </div>\n                  <small style=\"color: #999;\">Dimensions should be multiples of 16</small>\n              </div>\n\n              <!-- Timing Table -->\n              <div class=\"form-group\" style=\"margin-top: 12px;\">\n                  <label style=\"margin-bottom: 6px;\"><h4>Timing</h4></label>\n                  <table class=\"ve-timing-table\">\n                      <thead>\n                          <tr>\n                              <th>Virtual time</th>\n                              <th>Speed</th>\n                              <th><abbr title=\"Frames per second\">FPS</abbr></th>\n                          </tr>\n                      </thead>\n                      <tbody>\n                          <tr>\n                              <td>\n                                  <select id=\"ve-duration\" style=\"width: 100%;\">\n                                      <option value=\"3\">3s</option>\n                                      <option value=\"5\">5s</option>\n                                      <option value=\"10\">10s</option>\n                                      <option value=\"15\">15s</option>\n                                      <option value=\"30\" selected>30s</option>\n                                      <option value=\"60\">1m</option>\n                                      <option value=\"custom\">Custom...</option>\n                                  </select>\n                              </td>\n                              <td>\n                                  <select id=\"ve-speed\" style=\"width: 100%;\">\n                                      <option value=\"0.25\">0.25x</option>\n                                      <option value=\"0.5\">0.5x</option>\n                                      <option value=\"1\" selected>1x</option>\n                                      <option value=\"2\">2x</option>\n                                      <option value=\"4\">4x</option>\n                                      <option value=\"custom\">Custom...</option>\n                                  </select>\n                              </td>\n                              <td>\n                                  <input type=\"number\" id=\"ve-fps\" value=\"60\" min=\"1\" max=\"120\" step=\"0.01\" style=\"width: 100%; text-align: center;\">\n                              </td>\n                          </tr>\n                      </tbody>\n                  </table>\n                  <div id=\"ve-real-time\" style=\"font-size: 11px; color: #666; font-style: italic; margin-top: 6px;\">\n                      Real capture time: ~30s\n                  </div>\n              </div>\n\n              <!-- Custom duration input (hidden) -->\n              <div class=\"form-group\" id=\"ve-duration-custom-group\" style=\"display:none;\">\n                  <label>Custom Virtual Time (seconds)</label>\n                  <input type=\"number\" id=\"ve-duration-custom\" value=\"30\" min=\"1\">\n              </div>\n\n              <!-- Custom speed input (hidden) -->\n              <div class=\"form-group\" id=\"ve-speed-custom-group\" style=\"display:none;\">\n                  <label>Custom Speed Multiplier</label>\n                  <input type=\"number\" id=\"ve-speed-custom\" value=\"1\" step=\"0.1\" min=\"0.1\">\n                  <small style=\"color: #999;\">1.0 = real-time, 2.0 = twice as fast</small>\n              </div>\n\n              <!-- Video Format Section -->\n              <div class=\"form-group\" style=\"margin-top: 12px;\">\n                  <label for=\"ve-format\"><h4>Format</h4></label>\n                  <select id=\"ve-format\">\n                      <option value=\"webm-vp8\">WebM (VP8) - Good Compatibility</option>\n                      <option value=\"webm-vp9\" id=\"ve-format-vp9\">WebM (VP9) ‚≠ê Recommended - Best Quality [Auto-selected if supported]</option>\n                      <option value=\"mp4\">MP4 (H.264) - Legacy Compatibility</option>\n                  </select>\n                  <small id=\"ve-format-info\" style=\"display:block; margin-top: 6px; color: #666; line-height: 1.4;\"></small>\n              </div>\n\n              <div class=\"form-group\">\n                  <label for=\"ve-bitrate\"><h4>Bitrate</h4></label>\n                  <select id=\"ve-bitrate\">\n                      <option value=\"auto\" selected>Auto</option>\n                      <option value=\"5000\">5 Mbps (HD)</option>\n                      <option value=\"8000\">8 Mbps (Full HD)</option>\n                      <option value=\"12000\">12 Mbps (2K)</option>\n                      <option value=\"20000\">20 Mbps (4K)</option>\n                      <option value=\"custom\">Custom...</option>\n                  </select>\n              </div>\n\n              <div class=\"form-group\" id=\"ve-bitrate-custom-group\" style=\"display:none;\">\n                  <label>Custom Bitrate (kbps)</label>\n                  <input type=\"number\" id=\"ve-bitrate-custom\" value=\"8000\" step=\"1000\" min=\"100\">\n                  <small style=\"color: #999;\">Higher = better quality but larger file</small>\n              </div>\n\n              <!-- Format-specific settings -->\n              <div class=\"form-group\">\n                  <label>\n                      <input type=\"checkbox\" id=\"ve-format-advanced-toggle\">\n                      Format-specific settings\n                  </label>\n              </div>\n\n              <div id=\"ve-format-advanced-group\" style=\"display:none; padding: 10px; background: rgba(0,0,0,0.03); border-radius: 4px; margin-top: -5px;\">\n                  <!-- MP4 Advanced Settings -->\n                  <div id=\"ve-mp4-advanced\" style=\"display:none;\">\n                      <div class=\"form-group\">\n                          <label>Encoding Speed</label>\n                          <select id=\"ve-mp4-speed\">\n                              <option value=\"10\">Fast (default)</option>\n                              <option value=\"5\" selected>Balanced</option>\n                              <option value=\"0\">Best Quality (slow)</option>\n                          </select>\n                          <small style=\"color: #999;\">Slower = better compression</small>\n                      </div>\n\n                      <div class=\"form-group\">\n                          <label>Quality (QP)</label>\n                          <select id=\"ve-mp4-qp\">\n                              <option value=\"10,42\" selected>Standard</option>\n                              <option value=\"5,35\">High Quality</option>\n                              <option value=\"15,45\">Smaller File</option>\n                          </select>\n                          <small style=\"color: #999;\">Lower QP = better quality</small>\n                      </div>\n\n                      <div class=\"form-group\">\n                          <label>Keyframe Interval</label>\n                          <select id=\"ve-mp4-gop\">\n                              <option value=\"30\" selected>Standard (30)</option>\n                              <option value=\"10\">Frequent (10)</option>\n                              <option value=\"60\">Sparse (60)</option>\n                          </select>\n                          <small style=\"color: #999;\">More keyframes = easier editing</small>\n                      </div>\n                  </div>\n\n                  <!-- WebM VP8 Settings -->\n                  <div id=\"ve-webm-vp8-advanced\" style=\"display:none;\">\n                      <div style=\"padding: 8px; background: rgba(46, 125, 50, 0.1); border-radius: 4px; margin-bottom: 10px;\">\n                          <small style=\"color: #2e7d32;\">‚ÑπÔ∏è VP8 optimized for broad compatibility. Bitrate auto-adjusted for quality.</small>\n                      </div>\n                      <div class=\"form-group\">\n                          <label>Bitrate Override</label>\n                          <input type=\"number\" id=\"ve-vp8-bitrate-custom\" placeholder=\"Auto\" step=\"1000\" min=\"1000\">\n                          <small style=\"color: #999;\">Leave empty for auto (recommended). Custom bitrate in kbps.</small>\n                      </div>\n                      <small style=\"color: #999;\">üí° For advanced controls, use WebM VP9 format (Modern browsers).</small>\n                  </div>\n\n                  <!-- WebM VP9 Settings -->\n                  <div id=\"ve-webm-vp9-advanced\" style=\"display:none;\">\n                      <div style=\"padding: 8px; background: rgba(25, 118, 210, 0.1); border-radius: 4px; margin-bottom: 10px;\">\n                          <small style=\"color: #1976d2;\">üåü VP9 High Quality - Hardware Accelerated (WebCodecs)</small>\n                      </div>\n\n                      <div class=\"form-group\">\n                          <label>Quality Preset</label>\n                          <select id=\"ve-vp9-quality\">\n                              <option value=\"medium\">Medium (fast, smaller)</option>\n                              <option value=\"high\" selected>High (balanced)</option>\n                              <option value=\"very-high\">Very High (best quality)</option>\n                          </select>\n                          <small style=\"color: #999;\">Higher quality = larger file & slower encoding</small>\n                      </div>\n\n                      <div class=\"form-group\">\n                          <label>Encoding Mode</label>\n                          <select id=\"ve-vp9-latency\">\n                              <option value=\"quality\" selected>Quality (slower, better)</option>\n                              <option value=\"realtime\">Realtime (faster, good)</option>\n                          </select>\n                          <small style=\"color: #999;\">Realtime mode useful for long videos</small>\n                      </div>\n\n                      <div class=\"form-group\">\n                          <label>Bitrate Mode</label>\n                          <select id=\"ve-vp9-bitrate-mode\">\n                              <option value=\"variable\" selected>Variable (VBR) - Recommended</option>\n                              <option value=\"constant\">Constant (CBR)</option>\n                          </select>\n                          <small style=\"color: #999;\">VBR gives better quality at same file size</small>\n                      </div>\n\n                      <div class=\"form-group\">\n                          <label>Keyframe Interval (frames)</label>\n                          <input type=\"number\" id=\"ve-vp9-keyframe\" value=\"120\" min=\"10\" max=\"300\" step=\"10\">\n                          <small style=\"color: #999;\">Lower = better seeking, larger file. Default: 120 (2s @ 60fps)</small>\n                      </div>\n\n                      <div class=\"form-group\">\n                          <label>Content Optimization</label>\n                          <select id=\"ve-vp9-content-hint\">\n                              <option value=\"\" selected>Auto</option>\n                              <option value=\"motion\">Motion (aerial views, animations)</option>\n                              <option value=\"detail\">Detail (fine map details)</option>\n                              <option value=\"text\">Text (overlays, labels)</option>\n                          </select>\n                          <small style=\"color: #999;\">Optimizes encoder for content type</small>\n                      </div>\n                  </div>\n              </div>\n\n              <div class=\"form-group\">\n                  <label>\n                      <input type=\"checkbox\" id=\"ve-wait-tiles\" checked>\n                      Wait for tiles to load\n                  </label>\n                  <small style=\"color: #999;\">Try to ensures all tiles are loaded (slower but better quality)</small>\n              </div>\n\n              </div> <!-- End ve-video-settings-group -->\n\n            </div>\n\n            <!-- Section Separator -->\n            <hr style=\"border: none; border-top: 1px solid #ddd; margin: 20px 0;\">\n\n            <!-- MOVIE Section -->\n\n            <h3 data-section=\"movie\" style=\"cursor: pointer; user-select: none;\">\n              <span class=\"section-indicator\">‚ñº</span> üéûÔ∏è MOVIE\n            </h3>\n\n            <div data-section-content=\"movie\">\n\n              <div id=\"ve-movie-group\" style=\"padding: 15px; background: rgba(0,0,0,0.05); border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);\">\n\n                  <!-- Section Header -->\n                  <div style=\"margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(0,0,0,0.1);\">\n                      <span style=\"font-size: 11px; font-weight: 600; color: #555; text-transform: uppercase; letter-spacing: 0.5px;\">\n                        Configuration\n                      </span>\n                  </div>\n\n              <div class=\"form-group\">\n                  <label for=\"ve-animation\"><h4>Animation</h4></label>\n                  <select id=\"ve-animation\">\n                      ${this._generateAnimationOptions()}\n                  </select>\n                  <small style=\"color: #999; display: block; margin-top: 3px;\">\n                      üí° Tip: Most animations adapt to show all waypoints when present (happily or not)\n                  </small>\n\n                  <!-- Animation Description -->\n                  <div id=\"ve-animation-description\" style=\"display: none; margin-top: 8px; padding: 10px; background: rgba(33, 150, 243, 0.08); border-left: 3px solid #2196F3; border-radius: 4px;\">\n                      <span style=\"color: #1976D2; font-size: 13px; line-height: 1.5;\"></span>\n                  </div>\n\n                  <!-- Capability Feedback UI -->\n                  <div id=\"ve-capability-feedback\" style=\"display: none; margin-top: 8px;\">\n                      <!-- Dynamically filled with capability analysis -->\n                  </div>\n              </div>\n\n              <div class=\"form-group\">\n                  <label for=\"ve-loop\"><h4>Loop Animation</h4></label>\n                  <select id=\"ve-loop\">\n                      <option value=\"false\">No loop</option>\n                      <option value=\"true\">Loop (instant jump)</option>\n                      <option value=\"smooth\">Loop (smooth transition)</option>\n                  </select>\n                  <small style=\"color: #999;\">Return to start position for seamless video loops (some does not need this param)</small>\n              </div>\n\n              </div> <!-- End ve-movie-group -->\n\n            </div>\n\n            <hr style=\"border: none; border-top: 1px solid #ddd; margin: 20px 0;\">\n\n            <!-- Waypoints Section -->\n\n            <h3 data-section=\"points-of-interest\" style=\"cursor: pointer; user-select: none;\">\n              <span class=\"section-indicator\">‚ñº</span>\n              <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\" style=\"vertical-align: middle; margin-right: 4px;\">\n                <defs>\n                  <linearGradient id=\"poi-star-gradient\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">\n                    <stop offset=\"0%\" style=\"stop-color:#ffd700;stop-opacity:1\" />\n                    <stop offset=\"100%\" style=\"stop-color:#ffed4e;stop-opacity:1\" />\n                  </linearGradient>\n                </defs>\n                <path d=\"M12 2 L15 9 L22 10 L17 15 L18 22 L12 18 L6 22 L7 15 L2 10 L9 9 Z\"\n                      fill=\"url(#poi-star-gradient)\" stroke=\"#d4af37\" stroke-width=\"1\"/>\n              </svg> POINTS OF INTEREST\n            </h3>\n\n            <div data-section-content=\"points-of-interest\">\n\n              <div id=\"ve-waypoints-group\" style=\"padding: 15px; background: rgba(0,0,0,0.05); border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);\">\n\n                  <!-- Section Header -->\n                  <div style=\"margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(0,0,0,0.1);\">\n                      <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                          <span style=\"font-size: 11px; font-weight: 600; color: #555; text-transform: uppercase; letter-spacing: 0.5px;\">\n                            Configuration\n                          </span>\n                          <small id=\"ve-icon-mode-status\" style=\"font-size: 10px; color: #666;\">\n                              Checking for map icons...\n                          </small>\n                      </div>\n                  </div>\n\n                  <!-- Waypoint Labels Toggle -->\n                  <div style=\"margin-bottom: 10px; padding: 8px; border-radius: 3px;\">\n                      <label style=\"display: flex; align-items: center; gap: 5px; font-size: 11px; cursor: pointer; color: #555;\">\n                          <input type=\"checkbox\" id=\"ve-show-labels-toggle\" style=\"margin: 0;\">\n                          <span style=\"color: #555; font-weight: 500;\">Show Waypoint Labels</span>\n                      </label>\n                      <small style=\"color: #666; display: block; margin-top: 3px;\">\n                          Display text labels on waypoints (requires fonts)\n                      </small>\n\n                      <!-- Font Selection (visible only if labels enabled) -->\n                      <div id=\"ve-font-select-container\" style=\"display: none; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1);\">\n                          <label style=\"font-size: 10px; color: #666; display: block; margin-bottom: 4px;\">\n                              Font Family:\n                          </label>\n                          <select id=\"ve-font-select\" style=\"width: 100%; padding: 4px; font-size: 11px; border: 1px solid #ccc; border-radius: 3px;\">\n                              <option value=\"\">Loading fonts...</option>\n                          </select>\n                          <small id=\"ve-font-status\" style=\"color: #666; display: block; margin-top: 3px;\">\n                              No fonts available\n                          </small>\n                      </div>\n                  </div>\n\n                  <!-- Icon Size Slider -->\n                  <div id=\"ve-icon-size-control\" style=\"margin-bottom: 10px; padding: 8px; background: rgba(255,255,255,0.5); border-radius: 3px;\">\n                      <label style=\"font-size: 11px; color: #333; font-weight: 500; display: block; margin-bottom: 6px;\">\n                          Icon Size: <span id=\"ve-icon-size-value\">1.0√ó</span>\n                      </label>\n                      <input type=\"range\" id=\"ve-icon-size-slider\"\n                            min=\"0.5\" max=\"3\" step=\"0.1\" value=\"1.0\"\n                            style=\"width: 100%; margin: 0;\">\n                  </div>\n\n                  <!-- Waypoints List -->\n                  <div id=\"ve-waypoints-list\" style=\"max-height: 200px; overflow-y: auto; margin-bottom: 10px;\">\n                      <!-- Dynamically filled with waypoints -->\n                      <div style=\"text-align: center; color: #999; font-size: 12px; padding: 20px 0;\">\n                          No waypoints yet. Click \"Add draggable Icon\" to start.\n                      </div>\n                  </div>\n\n                  <!-- Action Buttons -->\n                  <div style=\"display: flex; gap: 5px; margin-bottom: 10px;\">\n                      <button type=\"button\" id=\"ve-waypoint-add\" class=\"btn-secondary btn-compact\" style=\"flex: 1;\">\n                          üìç Add draggable Icon\n                      </button>\n                      <button type=\"button\" id=\"ve-waypoint-import\" class=\"btn-secondary btn-compact\" style=\"flex: 1;\">\n                          üì• Import JSON\n                      </button>\n                      <button type=\"button\" id=\"ve-waypoint-export\" class=\"btn-secondary btn-compact\" style=\"flex: 1;\" disabled>\n                          üì§ Export\n                      </button>\n                  </div>\n\n              </div>\n\n            </div>\n\n            <hr style=\"border: none; border-top: 1px solid #ddd; margin: 20px 0;\">\n\n            <!-- Geographic Constraints Section -->\n\n            <h3 data-section=\"geographic-constraints\" style=\"cursor: pointer; user-select: none;\">\n              <span class=\"section-indicator\">‚ñº</span> üó∫Ô∏è GEOGRAPHIC CONSTRAINTS\n            </h3>\n\n            <div data-section-content=\"geographic-constraints\">\n\n              <div id=\"ve-constraints-group\" style=\"padding: 15px; background: rgba(0,0,0,0.05); border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);\">\n\n                  <!-- Section Header -->\n                  <div style=\"margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(0,0,0,0.1);\">\n                      <span style=\"font-size: 11px; font-weight: 600; color: #555; text-transform: uppercase; letter-spacing: 0.5px;\">\n                        Configuration\n                      </span>\n                  </div>\n\n                  <!-- Bounding Box -->\n                  <div class=\"form-group\">\n                      <label>Bounding Box (Longitude, Latitude)</label>\n                      <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 5px;\">\n                          <input type=\"number\" id=\"ve-bounds-west\" placeholder=\"West\" step=\"0.001\">\n                          <input type=\"number\" id=\"ve-bounds-east\" placeholder=\"East\" step=\"0.001\">\n                          <input type=\"number\" id=\"ve-bounds-south\" placeholder=\"South\" step=\"0.001\">\n                          <input type=\"number\" id=\"ve-bounds-north\" placeholder=\"North\" step=\"0.001\">\n                      </div>\n                      <div style=\"margin-top: 5px; display: flex; gap: 5px;\">\n                          <button type=\"button\" id=\"ve-bounds-current\" class=\"btn-secondary btn-mini\" style=\"flex: 1;\">\n                              üó∫Ô∏è Use Current View\n                          </button>\n                          <button type=\"button\" id=\"ve-bounds-waypoints\" class=\"btn-secondary btn-mini\" style=\"flex: 1;\">\n                              üìê From POIs\n                          </button>\n                      </div>\n                      <small style=\"color: #999;\">Animation will stay within these bounds</small>\n                  </div>\n\n                  <!-- Zoom Limits -->\n                  <div class=\"form-group\">\n                      <label>Zoom Limits</label>\n                      <div style=\"display: flex; gap: 5px; align-items: center;\">\n                          <input type=\"number\" id=\"ve-zoom-min\" placeholder=\"Min\" min=\"0\" max=\"24\" step=\"0.5\" style=\"flex: 1;\">\n                          <span style=\"color: #999;\">to</span>\n                          <input type=\"number\" id=\"ve-zoom-max\" placeholder=\"Max\" min=\"0\" max=\"24\" step=\"0.5\" style=\"flex: 1;\">\n                      </div>\n                      <small style=\"color: #999;\">Zoom will stay between these levels (0-24)</small>\n                  </div>\n\n                  <!-- Strict Mode -->\n                  <div class=\"form-group\">\n                      <label>\n                          <input type=\"checkbox\" id=\"ve-strict-bounds\">\n                          Strict Bounds\n                      </label>\n                      <small style=\"color: #999;\">Strictly enforce bounds (no partial view outside)</small>\n                  </div>\n\n                  <!-- Show Overlay -->\n                  <div class=\"form-group\">\n                      <label>\n                          <input type=\"checkbox\" id=\"ve-show-bounds\">\n                          Show Bounds Overlay\n                      </label>\n                      <small style=\"color: #999;\">Display visual boundary on map during recording</small>\n                  </div>\n              </div>\n\n            </div>\n\n            <!-- Section Separator -->\n            <hr style=\"border: none; border-top: 1px solid #ddd; margin: 20px 0;\">\n\n            <div class=\"recording-time-display\">\n                üìπ <strong>Recording time: <span id=\"ve-recording-time\">30s</span></strong>\n            </div>\n\n            <div style=\"margin-bottom: 8px;\" id=\"ve-exploration-limit-container\">\n                <label style=\"display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;\">\n                    <input type=\"checkbox\" id=\"ve-exploration-limit\" style=\"cursor: pointer;\">\n                    <span>Limit exploration duration (<span id=\"ve-exploration-max-duration\">300</span>s)</span>\n                </label>\n            </div>\n\n            <div class=\"button-group\">\n                <button class=\"btn-secondary\" id=\"ve-test\">‚ñ∂Ô∏è Test</button>\n                <button class=\"btn-secondary\" id=\"ve-explore\" style=\"display: none;\">üó∫Ô∏è Explore</button>\n                <button class=\"btn-primary\" id=\"ve-record\">üî¥ Record</button>\n            </div>\n\n            <div class=\"status\" id=\"ve-status\">Ready</div>\n        `;\n\n    // Create invisible overlay to capture clicks outside panel\n    this._overlay = document.createElement('div');\n    this._overlay.className = 'maplibre-gl-video-export-overlay';\n    this._overlay.style.display = 'none';\n    this._overlay.addEventListener('click', () => this._togglePanel());\n\n    // Append overlay and panel to map container instead of control container\n    // This allows them to be centered within the map using absolute positioning\n    const mapContainer = this._map.getContainer();\n\n    // Ensure map container has position: relative for absolute positioning to work\n    const computedStyle = window.getComputedStyle(mapContainer);\n    if (computedStyle.position === 'static') {\n      mapContainer.style.position = 'relative';\n    }\n\n    mapContainer.appendChild(this._overlay);\n    mapContainer.appendChild(this._panel);\n\n    // Add progress widget to panel (will be shown/hidden as needed)\n    this._panel.appendChild(this._progressWidget);\n\n    // Initialize waypoints icon select\n    this._initWaypointsIconSelect();\n\n    // Load and apply saved settings (or defaults if first time)\n    const settings = this._loadSettings();\n    this._applySettings(settings);\n\n    this._bindEvents();\n\n    // Initialize animation description display\n    this._updateAnimationDescription();\n  }\n\n  _bindEvents() {\n    if (!this._panel) return;\n\n    // Initialize collapsible sections\n    this._sectionStates = this._loadSectionStates();\n\n    // Bind section toggle listeners\n    ['video-settings', 'movie', 'points-of-interest', 'geographic-constraints'].forEach(sectionId => {\n      const header = this._panel.querySelector(`[data-section=\"${sectionId}\"]`);\n      const content = this._panel.querySelector(`[data-section-content=\"${sectionId}\"]`);\n      const indicator = header?.querySelector('.section-indicator');\n\n      if (header && content) {\n        // Initialize section state\n        const isCollapsed = this._sectionStates[sectionId];\n        content.style.display = isCollapsed ? 'none' : 'block';\n        if (indicator) indicator.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';\n\n        // Add click listener\n        header.addEventListener('click', () => this._toggleSection(sectionId));\n      }\n    });\n\n    this._panel.querySelector('#ve-test')?.addEventListener('click', () => this._testAnimation());\n    this._panel.querySelector('#ve-explore')?.addEventListener('click', () => this._startExploration());\n    this._panel.querySelector('#ve-record')?.addEventListener('click', () => this._startRecording());\n\n    // Reset to defaults button\n    this._panel.querySelector('#ve-reset-defaults')?.addEventListener('click', (e) => {\n      e.preventDefault();\n      if (!confirm('Reset all settings to default values?')) return;\n\n      // Apply defaults to UI\n      this._applySettings(VideoExportControl.DEFAULT_SETTINGS);\n\n      // Show reset message\n      const resetMessage = this._panel.querySelector('#ve-reset-message');\n      if (resetMessage) resetMessage.style.display = 'block';\n    });\n\n    // Cancel reset button\n    this._panel.querySelector('#ve-cancel-reset')?.addEventListener('click', (e) => {\n      e.preventDefault();\n\n      // Reload settings from localStorage\n      const savedSettings = this._loadSettings();\n      this._applySettings(savedSettings);\n\n      // Hide reset message\n      const resetMessage = this._panel.querySelector('#ve-reset-message');\n      if (resetMessage) resetMessage.style.display = 'none';\n    });\n\n    // Helper to update recording time display\n    const updateRecordingTime = () => {\n      if (!this._panel) return;\n      const recordingDuration = this.options.duration / this.options.speedMultiplier;\n      const seconds = Math.round(recordingDuration / 1000);\n      const timeDisplay = this._panel.querySelector('#ve-recording-time');\n      if (timeDisplay) {\n        timeDisplay.textContent = `${seconds}s`;\n      }\n    };\n\n    // Update options when form changes\n    this._panel.querySelector('#ve-animation')?.addEventListener('change', (e) => {\n      this.options.animation = asSelect(e.target)?.value || 'orbit';\n\n      // Update animation description\n      this._updateAnimationDescription();\n\n      // Show/hide Explore button and Auto-continue checkbox based on animation type\n      this._updateExplorationUI();\n    });\n\n    // Check for OpenMapTiles and show/hide road animations (wait for style to be loaded)\n    // Check capabilities once when map is idle (all sources loaded)\n    this._map.once('idle', () => {\n      this._checkMapCapabilities();\n    });\n\n    const resolutionSelect = asSelect(this._panel.querySelector('#ve-resolution'));\n    const resolutionCustomGroup = asHTMLElement(this._panel.querySelector('#ve-resolution-custom-group'));\n    const resolutionWidthInput = asInput(this._panel.querySelector('#ve-resolution-width-custom'));\n    const resolutionHeightInput = asInput(this._panel.querySelector('#ve-resolution-height-custom'));\n\n    resolutionSelect?.addEventListener('change', (e) => {\n      if (asSelect(e.target)?.value === 'custom') {\n        if (resolutionCustomGroup) resolutionCustomGroup.style.display = 'block';\n        this.options.resolution = {\n          width: parseInt(resolutionWidthInput?.value || '1920', 10),\n          height: parseInt(resolutionHeightInput?.value || '1080', 10)\n        };\n      } else {\n        if (resolutionCustomGroup) resolutionCustomGroup.style.display = 'none';\n        this.options.resolution = asSelect(e.target)?.value || '1920x1080';\n      }\n    });\n\n    resolutionWidthInput?.addEventListener('input', (e) => {\n      if (resolutionSelect?.value === 'custom') {\n        this.options.resolution = {\n          width: parseInt(asInput(e.target)?.value || '1920', 10),\n          height: parseInt(resolutionHeightInput?.value || '1080', 10)\n        };\n      }\n    });\n\n    resolutionHeightInput?.addEventListener('input', (e) => {\n      if (resolutionSelect?.value === 'custom') {\n        this.options.resolution = {\n          width: parseInt(resolutionWidthInput?.value || '1920', 10),\n          height: parseInt(asInput(e.target)?.value || '1080', 10)\n        };\n      }\n    });\n\n    // Duration select (new timing table)\n    const durationSelect = asSelect(this._panel.querySelector('#ve-duration'));\n    const durationCustomGroup = asHTMLElement(this._panel.querySelector('#ve-duration-custom-group'));\n    const durationInput = asInput(this._panel.querySelector('#ve-duration-custom'));\n    const realTimeDisplay = asHTMLElement(this._panel.querySelector('#ve-real-time'));\n\n    // Initialize duration from UI value\n    if (durationSelect) {\n      if (durationSelect.value === 'custom') {\n        this.options.duration = parseFloat(durationInput?.value || '30') * 1000;\n      } else {\n        this.options.duration = parseFloat(durationSelect.value || '30') * 1000;\n      }\n    }\n\n    // Helper to update real-time display\n    const updateRealTimeDisplay = () => {\n      const virtualTime = this.options.duration / 1000; // in seconds\n      const speed = this.options.speedMultiplier;\n      const realTime = virtualTime / speed;\n\n      if (realTimeDisplay) {\n        let timeStr;\n        if (realTime < 60) {\n          timeStr = `~${Math.round(realTime)}s`;\n        } else {\n          const mins = Math.floor(realTime / 60);\n          const secs = Math.round(realTime % 60);\n          timeStr = secs > 0 ? `~${mins}m ${secs}s` : `~${mins}m`;\n        }\n        realTimeDisplay.textContent = `Real capture time: ${timeStr}`;\n      }\n      updateRecordingTime();\n    };\n\n    if (durationSelect) {\n      durationSelect.addEventListener('change', (e) => {\n        const value = asSelect(e.target)?.value;\n        if (value === 'custom') {\n          if (durationCustomGroup) durationCustomGroup.style.display = 'block';\n          this.options.duration = parseFloat(durationInput?.value || '30') * 1000;\n        } else {\n          if (durationCustomGroup) durationCustomGroup.style.display = 'none';\n          this.options.duration = parseFloat(value || '30') * 1000;\n        }\n        updateRealTimeDisplay();\n      });\n    }\n\n    if (durationInput) {\n      durationInput.addEventListener('input', (e) => {\n        this.options.duration = parseFloat(asInput(e.target)?.value || '30') * 1000;\n        updateRealTimeDisplay();\n      });\n    }\n\n    this._panel.querySelector('#ve-fps')?.addEventListener('input', (e) => {\n      this.options.fps = parseFloat(asInput(e.target)?.value || '30');\n    });\n\n    this._panel.querySelector('#ve-wait-tiles')?.addEventListener('change', (e) => {\n      this.options.waitForTiles = asInput(e.target)?.checked ?? true;\n    });\n\n    this._panel.querySelector('#ve-loop')?.addEventListener('change', (e) => {\n      const value = asSelect(e.target)?.value;\n      if (value === 'false') {\n        this.options.loop = false;\n      } else if (value === 'true') {\n        this.options.loop = true;\n      } else {\n        this.options.loop = 'smooth';\n      }\n    });\n\n    this._panel.querySelector('#ve-format')?.addEventListener('change', (e) => {\n      if (!this._panel) return;\n      this.options.format = asSelect(e.target)?.value || 'webm-vp8'; // 'webm-vp8', 'webm-vp9', or 'mp4'\n      console.log('üìπ Format changed to:', this.options.format);\n\n      // Update format info message\n      const formatInfo = asHTMLElement(this._panel.querySelector('#ve-format-info'));\n      if (formatInfo) {\n        if (this.options.format === 'webm-vp8') {\n          formatInfo.innerHTML = '‚úì Free & open-source (no licensing issues)<br>‚úì Works on all modern browsers<br>‚úì Good quality for most use cases';\n          formatInfo.style.color = '#2e7d32'; // green\n        } else if (this.options.format === 'webm-vp9') {\n          formatInfo.innerHTML = '‚úì Free & open-source<br>‚úì Best compression & quality<br>‚ö† Modern browsers only (WebCodecs API)';\n          formatInfo.style.color = '#1976d2'; // blue\n        } else if (this.options.format === 'mp4') {\n          formatInfo.innerHTML = '‚ö† Patent-encumbered codec<br>‚ö† May require licensing for commercial use<br>‚úì Maximum compatibility';\n          formatInfo.style.color = '#d32f2f'; // red\n        }\n      }\n\n      // Show/hide format-specific advanced options\n      const mp4Advanced = asHTMLElement(this._panel.querySelector('#ve-mp4-advanced'));\n      const vp8Advanced = asHTMLElement(this._panel.querySelector('#ve-webm-vp8-advanced'));\n      const vp9Advanced = asHTMLElement(this._panel.querySelector('#ve-webm-vp9-advanced'));\n\n      if (mp4Advanced && vp8Advanced && vp9Advanced) {\n        mp4Advanced.style.display = 'none';\n        vp8Advanced.style.display = 'none';\n        vp9Advanced.style.display = 'none';\n\n        if (this.options.format === 'mp4') {\n          mp4Advanced.style.display = 'block';\n        } else if (this.options.format === 'webm-vp8') {\n          vp8Advanced.style.display = 'block';\n        } else if (this.options.format === 'webm-vp9') {\n          vp9Advanced.style.display = 'block';\n        }\n      }\n    });\n\n    // WebCodecs detection - disable VP9 if not supported\n    const vp9Option = /** @type {HTMLOptionElement | null} */(this._panel.querySelector('#ve-format-vp9'));\n    const formatSelect = asSelect(this._panel.querySelector('#ve-format'));\n    const supportsWebCodecs = typeof VideoEncoder !== 'undefined' && typeof VideoFrame !== 'undefined';\n\n    if (!supportsWebCodecs && vp9Option) {\n      vp9Option.disabled = true;\n      vp9Option.textContent = 'WebM (VP9) - Not supported in this browser';\n      console.log('‚ö†Ô∏è WebCodecs not supported - VP9 option disabled');\n\n      // If VP9 was somehow selected, switch to VP8\n      if (this.options.format === 'webm-vp9') {\n        this.options.format = 'webm-vp8';\n        if (formatSelect) formatSelect.value = 'webm-vp8';\n      }\n    } else if (supportsWebCodecs) {\n      console.log('‚úì WebCodecs supported - VP9 high quality encoding available');\n\n      // Set formatSelect to match the auto-detected format from options\n      if (formatSelect) formatSelect.value = this.options.format;\n    }\n\n    // Trigger format change to show initial info message\n    formatSelect?.dispatchEvent(new Event('change'));\n\n    // Initialize real-time display with default values\n    // Use setTimeout to ensure all UI updates and events have completed\n    setTimeout(() => {\n      updateRealTimeDisplay();\n    }, 0);\n\n    // Format-specific advanced settings toggle\n    const formatAdvancedToggle = asInput(this._panel.querySelector('#ve-format-advanced-toggle'));\n    const formatAdvancedGroup = asHTMLElement(this._panel.querySelector('#ve-format-advanced-group'));\n\n    formatAdvancedToggle?.addEventListener('change', (e) => {\n      if (!this._panel) return;\n      if (formatAdvancedGroup) formatAdvancedGroup.style.display = asInput(e.target)?.checked ? 'block' : 'none';\n      // Show the correct format options\n      const mp4Advanced = asHTMLElement(this._panel.querySelector('#ve-mp4-advanced'));\n      const vp8Advanced = asHTMLElement(this._panel.querySelector('#ve-webm-vp8-advanced'));\n      const vp9Advanced = asHTMLElement(this._panel.querySelector('#ve-webm-vp9-advanced'));\n\n      if (asInput(e.target)?.checked && mp4Advanced && vp8Advanced && vp9Advanced) {\n        mp4Advanced.style.display = 'none';\n        vp8Advanced.style.display = 'none';\n        vp9Advanced.style.display = 'none';\n\n        if (this.options.format === 'mp4') {\n          mp4Advanced.style.display = 'block';\n        } else if (this.options.format === 'webm-vp8') {\n          vp8Advanced.style.display = 'block';\n        } else if (this.options.format === 'webm-vp9') {\n          vp9Advanced.style.display = 'block';\n        }\n      }\n    });\n\n    const speedSelect = asSelect(this._panel.querySelector('#ve-speed'));\n    const speedCustomGroup = asHTMLElement(this._panel.querySelector('#ve-speed-custom-group'));\n    const speedCustomInput = asInput(this._panel.querySelector('#ve-speed-custom'));\n\n    // Initialize speedMultiplier from UI value\n    if (speedSelect) {\n      if (speedSelect.value === 'custom') {\n        this.options.speedMultiplier = parseFloat(speedCustomInput?.value || '1');\n      } else {\n        this.options.speedMultiplier = parseFloat(speedSelect.value || '1');\n      }\n    }\n\n    speedSelect?.addEventListener('change', (e) => {\n      if (asSelect(e.target)?.value === 'custom') {\n        if (speedCustomGroup) speedCustomGroup.style.display = 'block';\n        this.options.speedMultiplier = parseFloat(speedCustomInput?.value || '1');\n      } else {\n        if (speedCustomGroup) speedCustomGroup.style.display = 'none';\n        this.options.speedMultiplier = parseFloat(asSelect(e.target)?.value || '1');\n      }\n      updateRealTimeDisplay();\n    });\n\n    speedCustomInput?.addEventListener('input', (e) => {\n      this.options.speedMultiplier = parseFloat(asInput(e.target)?.value || '1');\n      updateRealTimeDisplay();\n    });\n\n    // Bitrate control\n    const bitrateSelect = asSelect(this._panel.querySelector('#ve-bitrate'));\n    const bitrateCustomGroup = asHTMLElement(this._panel.querySelector('#ve-bitrate-custom-group'));\n    const bitrateCustomInput = asInput(this._panel.querySelector('#ve-bitrate-custom'));\n\n    bitrateSelect?.addEventListener('change', (e) => {\n      if (asSelect(e.target)?.value === 'custom') {\n        if (bitrateCustomGroup) bitrateCustomGroup.style.display = 'block';\n        this.options.bitrate = parseInt(bitrateCustomInput?.value || '5000', 10);\n      } else if (asSelect(e.target)?.value === 'auto') {\n        if (bitrateCustomGroup) bitrateCustomGroup.style.display = 'none';\n        this.options.bitrate = 'auto';\n      } else {\n        if (bitrateCustomGroup) bitrateCustomGroup.style.display = 'none';\n        this.options.bitrate = parseInt(asSelect(e.target)?.value || '5000', 10);\n      }\n    });\n\n    bitrateCustomInput?.addEventListener('input', (e) => {\n      this.options.bitrate = parseInt(asInput(e.target)?.value || '5000', 10);\n    });\n\n    // Geographic Constraints event listeners\n    // Note: Constraints section is now always visible (controlled by collapsible section)\n\n    // Use Current View button\n    const boundsCurrentBtn = this._panel.querySelector('#ve-bounds-current');\n    if (boundsCurrentBtn) {\n      boundsCurrentBtn.addEventListener('click', () => {\n        if (!this._panel) return;\n        if (this._map) {\n          const bounds = this._map.getBounds();\n          const west = asInput(this._panel.querySelector('#ve-bounds-west'));\n          const east = asInput(this._panel.querySelector('#ve-bounds-east'));\n          const south = asInput(this._panel.querySelector('#ve-bounds-south'));\n          const north = asInput(this._panel.querySelector('#ve-bounds-north'));\n\n          if (west) west.value = bounds.getWest().toFixed(6);\n          if (east) east.value = bounds.getEast().toFixed(6);\n          if (south) south.value = bounds.getSouth().toFixed(6);\n          if (north) north.value = bounds.getNorth().toFixed(6);\n\n          // Also set current zoom limits\n          const currentZoom = this._map.getZoom();\n          const minZoomInput = asInput(this._panel.querySelector('#ve-zoom-min'));\n          const maxZoomInput = asInput(this._panel.querySelector('#ve-zoom-max'));\n\n          if (minZoomInput && !minZoomInput.value) {\n            minZoomInput.value = Math.max(0, currentZoom - 2).toFixed(1);\n          }\n          if (maxZoomInput && !maxZoomInput.value) {\n            maxZoomInput.value = Math.min(24, currentZoom + 2).toFixed(1);\n          }\n\n          this._updateBoundsFromUI();\n          this._updateBoundsOverlay();\n        }\n      });\n    }\n\n    // Suggest Bounds from Waypoints button\n    const boundsWaypointsBtn = this._panel.querySelector('#ve-bounds-waypoints');\n    if (boundsWaypointsBtn) {\n      boundsWaypointsBtn.addEventListener('click', () => {\n        if (!this._panel) return;\n        const features = this.options.waypoints?.features || [];\n\n        if (features.length === 0) {\n          alert('No waypoints available.\\n\\nAdd some waypoints first using the Waypoints section above.');\n          return;\n        }\n\n        // Calculate bounds from all waypoints\n        let west = Infinity; let south = Infinity; let east = -Infinity; let north = -Infinity;\n\n        features.forEach(feature => {\n          const [lng, lat] = feature.geometry.coordinates;\n          west = Math.min(west, lng);\n          east = Math.max(east, lng);\n          south = Math.min(south, lat);\n          north = Math.max(north, lat);\n        });\n\n        // Add 10% padding\n        const padLng = (east - west) * 0.1;\n        const padLat = (north - south) * 0.1;\n\n        west -= padLng;\n        east += padLng;\n        south -= padLat;\n        north += padLat;\n\n        // Update UI\n        const westInput = asInput(this._panel.querySelector('#ve-bounds-west'));\n        const eastInput = asInput(this._panel.querySelector('#ve-bounds-east'));\n        const southInput = asInput(this._panel.querySelector('#ve-bounds-south'));\n        const northInput = asInput(this._panel.querySelector('#ve-bounds-north'));\n\n        if (westInput) westInput.value = west.toFixed(6);\n        if (eastInput) eastInput.value = east.toFixed(6);\n        if (southInput) southInput.value = south.toFixed(6);\n        if (northInput) northInput.value = north.toFixed(6);\n\n        // Calculate optimal zoom based on bounds\n        if (this._map) {\n          const canvas = this._map.getCanvas();\n          const padding = Math.min(canvas.width, canvas.height) * 0.15;\n          const camera = this._map.cameraForBounds(\n            [[west, south], [east, north]],\n            { padding: { top: padding, bottom: padding, left: padding, right: padding } }\n          );\n\n          if (camera) {\n            const minZoomInput = asInput(this._panel.querySelector('#ve-zoom-min'));\n            const maxZoomInput = asInput(this._panel.querySelector('#ve-zoom-max'));\n\n            if (minZoomInput && !minZoomInput.value) {\n              minZoomInput.value = Math.max(0, camera.zoom - 2).toFixed(1);\n            }\n            if (maxZoomInput && !maxZoomInput.value) {\n              maxZoomInput.value = Math.min(24, camera.zoom + 2).toFixed(1);\n            }\n          }\n        }\n\n        this._updateBoundsFromUI();\n        this._updateBoundsOverlay();\n\n        console.log(`‚úÖ Suggested bounds from ${features.length} waypoints: [${west.toFixed(4)}, ${south.toFixed(4)}] to [${east.toFixed(4)}, ${north.toFixed(4)}]`);\n      });\n    }\n\n    // Bounds input listeners\n    const boundInputs = ['#ve-bounds-west', '#ve-bounds-east', '#ve-bounds-south', '#ve-bounds-north'];\n    boundInputs.forEach(selector => {\n      const input = this._panel?.querySelector(selector);\n      if (input) {\n        input.addEventListener('input', () => {\n          this._updateBoundsFromUI();\n          this._updateBoundsOverlay();\n        });\n      }\n    });\n\n    // Zoom limit listeners\n    const zoomInputs = ['#ve-zoom-min', '#ve-zoom-max'];\n    zoomInputs.forEach(selector => {\n      const input = this._panel?.querySelector(selector);\n      if (input) {\n        input.addEventListener('input', () => {\n          this._updateZoomLimitsFromUI();\n        });\n      }\n    });\n\n    // Strict bounds listener\n    const strictBoundsCheck = asInput(this._panel.querySelector('#ve-strict-bounds'));\n    if (strictBoundsCheck) {\n      strictBoundsCheck.addEventListener('change', (e) => {\n        this.options.strictBounds = asInput(e.target)?.checked ?? false;\n      });\n    }\n\n    // Show bounds overlay listener\n    const showBoundsCheck = asInput(this._panel.querySelector('#ve-show-bounds'));\n    if (showBoundsCheck) {\n      showBoundsCheck.addEventListener('change', (e) => {\n        const checked = asInput(e.target)?.checked ?? false;\n        this.options.showBoundsOverlay = checked;\n        if (checked) {\n          this._updateBoundsOverlay();\n        } else {\n          this._removeBoundsOverlay();\n        }\n      });\n    }\n\n    // Waypoints event listeners\n    // Note: Waypoints section is now always visible (controlled by collapsible section)\n\n    // Icon mode: sprite only (emoji mode removed)\n\n    // Show waypoint labels toggle\n    const showLabelsToggle = asInput(this._panel.querySelector('#ve-show-labels-toggle'));\n    const fontSelectContainer = asHTMLElement(this._panel.querySelector('#ve-font-select-container'));\n    if (showLabelsToggle && fontSelectContainer) {\n      showLabelsToggle.addEventListener('change', (e) => {\n        const checked = asInput(e.target)?.checked ?? false;\n        this._showWaypointLabels = checked;\n        console.log(`[Waypoints] Show labels changed to: ${this._showWaypointLabels}`);\n\n        // Show/hide font select\n        fontSelectContainer.style.display = checked ? 'block' : 'none';\n\n        // Update map layer\n        this._updateWaypointsLayer();\n      });\n    }\n\n    // Font select\n    const fontSelect = asSelect(this._panel.querySelector('#ve-font-select'));\n    if (fontSelect) {\n      fontSelect.addEventListener('change', (e) => {\n        this._selectedFont = asSelect(e.target)?.value || 'Roboto';\n        console.log(`[Waypoints] Font changed to: ${this._selectedFont}`);\n\n        // Update map layer\n        this._updateWaypointsLayer();\n      });\n    }\n\n    // Icon size slider\n    const iconSizeSlider = asInput(this._panel.querySelector('#ve-icon-size-slider'));\n    const iconSizeValue = asHTMLElement(this._panel.querySelector('#ve-icon-size-value'));\n    if (iconSizeSlider && iconSizeValue) {\n      iconSizeSlider.addEventListener('input', (e) => {\n        this._iconSize = parseFloat(asInput(e.target)?.value || '1');\n        iconSizeValue.textContent = `${this._iconSize.toFixed(1)}√ó`;\n\n        // Update the layer if it exists\n        if (this._map && this._map.getLayer(this._waypointsLayerId)) {\n          this._updateWaypointsLayer();\n        }\n      });\n    }\n\n    const addWaypointBtn = this._panel.querySelector('#ve-waypoint-add');\n    if (addWaypointBtn) {\n      addWaypointBtn.addEventListener('click', () => this._addWaypoint());\n    }\n\n    const importWaypointsBtn = this._panel.querySelector('#ve-waypoint-import');\n    if (importWaypointsBtn) {\n      importWaypointsBtn.addEventListener('click', () => this._importWaypoints());\n    }\n\n    const exportWaypointsBtn = this._panel.querySelector('#ve-waypoint-export');\n    if (exportWaypointsBtn) {\n      exportWaypointsBtn.addEventListener('click', () => this._exportWaypoints());\n    }\n  }\n\n  _updateBoundsFromUI() {\n    if (!this._panel) return;\n    const west = parseFloat(asInput(this._panel.querySelector('#ve-bounds-west'))?.value || '');\n    const east = parseFloat(asInput(this._panel.querySelector('#ve-bounds-east'))?.value || '');\n    const south = parseFloat(asInput(this._panel.querySelector('#ve-bounds-south'))?.value || '');\n    const north = parseFloat(asInput(this._panel.querySelector('#ve-bounds-north'))?.value || '');\n\n    if (!isNaN(west) && !isNaN(east) && !isNaN(south) && !isNaN(north)) {\n      this.options.maxBounds = [[west, south], [east, north]];\n    } else {\n      this.options.maxBounds = null;\n    }\n  }\n\n  _updateZoomLimitsFromUI() {\n    if (!this._panel) return;\n    const minZoom = parseFloat(asInput(this._panel.querySelector('#ve-zoom-min'))?.value || '');\n    const maxZoom = parseFloat(asInput(this._panel.querySelector('#ve-zoom-max'))?.value || '');\n\n    this.options.minZoom = !isNaN(minZoom) ? minZoom : null;\n    this.options.maxZoom = !isNaN(maxZoom) ? maxZoom : null;\n  }\n\n  _updateBoundsOverlay() {\n    if (!this._map || !this.options.maxBounds || !this.options.showBoundsOverlay) {\n      this._removeBoundsOverlay();\n      return;\n    }\n\n    const bounds = this.options.maxBounds;\n    const sourceId = 'video-export-bounds-overlay';\n    const layerId = 'video-export-bounds-overlay-layer';\n\n    // Remove existing if any\n    if (this._map.getLayer(layerId)) {\n      this._map.removeLayer(layerId);\n    }\n    if (this._map.getSource(sourceId)) {\n      this._map.removeSource(sourceId);\n    }\n\n    // Add new source and layer\n    this._map.addSource(sourceId, {\n      type: 'geojson',\n      data: {\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[\n            [bounds[0][0], bounds[0][1]],\n            [bounds[1][0], bounds[0][1]],\n            [bounds[1][0], bounds[1][1]],\n            [bounds[0][0], bounds[1][1]],\n            [bounds[0][0], bounds[0][1]]\n          ]]\n        }\n      }\n    });\n\n    this._map.addLayer({\n      id: layerId,\n      type: 'fill',\n      source: sourceId,\n      paint: {\n        'fill-color': '#3887be',\n        'fill-opacity': 0.1\n      }\n    });\n\n    this._map.addLayer({\n      id: layerId + '-outline',\n      type: 'line',\n      source: sourceId,\n      paint: {\n        'line-color': '#3887be',\n        'line-width': 2,\n        'line-dasharray': [2, 2]\n      }\n    });\n  }\n\n  _removeBoundsOverlay() {\n    if (!this._map) return;\n\n    const layerId = 'video-export-bounds-overlay-layer';\n    const sourceId = 'video-export-bounds-overlay';\n\n    if (this._map.getLayer(layerId + '-outline')) {\n      this._map.removeLayer(layerId + '-outline');\n    }\n    if (this._map.getLayer(layerId)) {\n      this._map.removeLayer(layerId);\n    }\n    if (this._map.getSource(sourceId)) {\n      this._map.removeSource(sourceId);\n    }\n  }\n\n  // ============================================================================\n  // WAYPOINTS SYSTEM\n  // ============================================================================\n\n  // Entry point - loads both sprites and fonts\n  async _loadSpriteIcons() {\n    if (!this._map) return;\n\n    try {\n      // Load sprites and fonts in parallel\n      await Promise.all([\n        this._loadSpriteSheet(),\n        this._loadFontstacks()\n      ]);\n\n      // Update UI with loaded data\n      this._populateFontSelect();\n      this._updateIconAvailability();\n      this._initWaypointsIconSelect(); // Fill icon select with loaded sprites\n    } catch (error) {\n      console.error('[Waypoints] Error loading sprite icons:', error);\n      this._spriteIcons = [];\n      this._updateIconAvailability();\n      this._initWaypointsIconSelect(); // Update UI even on error\n    }\n  }\n\n  // ============================================================================\n  // SPRITES - Loading and UI\n  // ============================================================================\n\n  async _loadSpriteSheet() {\n    try {\n      const style = this._map.getStyle();\n      if (!style || !style.sprite) {\n        console.warn('[Waypoints] No sprite URL in style - waypoints icons will not work');\n        this._spriteIcons = [];\n        this._spriteData = null;\n        this._spriteImage = null;\n        return;\n      }\n\n      const spriteUrl = style.sprite;\n      console.log('[Waypoints] Loading sprite from:', spriteUrl);\n\n      // Try @2x first for better quality, fall back to 1x if not available\n      let pixelRatio = 2;\n      let suffix = '@2x';\n      let spriteData = null;\n      let spriteImage = null;\n\n      // Try to load @2x version first\n      try {\n        const jsonUrl = `${spriteUrl}${suffix}.json`;\n        const jsonResponse = await fetch(jsonUrl);\n        if (!jsonResponse.ok) {\n          throw new Error(`@2x not available (${jsonResponse.status})`);\n        }\n        spriteData = await jsonResponse.json();\n\n        // Load PNG\n        const pngUrl = `${spriteUrl}${suffix}.png`;\n        spriteImage = new Image();\n        spriteImage.crossOrigin = 'anonymous';\n\n        await new Promise((resolve, reject) => {\n          spriteImage.onload = resolve;\n          spriteImage.onerror = reject;\n          spriteImage.src = pngUrl;\n        });\n\n        console.log('[Waypoints] Loaded @2x sprite (retina quality)');\n      } catch (error) {\n        console.log('[Waypoints] @2x sprite not available, trying 1x fallback:', error.message);\n\n        // Fallback to 1x version\n        pixelRatio = 1;\n        suffix = '';\n\n        const jsonUrl = `${spriteUrl}${suffix}.json`;\n        const jsonResponse = await fetch(jsonUrl);\n        if (!jsonResponse.ok) {\n          throw new Error(`Failed to load sprite JSON (1x): ${jsonResponse.status}`);\n        }\n        spriteData = await jsonResponse.json();\n\n        // Load PNG\n        const pngUrl = `${spriteUrl}${suffix}.png`;\n        spriteImage = new Image();\n        spriteImage.crossOrigin = 'anonymous';\n\n        await new Promise((resolve, reject) => {\n          spriteImage.onload = resolve;\n          spriteImage.onerror = reject;\n          spriteImage.src = pngUrl;\n        });\n\n        console.log('[Waypoints] Loaded 1x sprite (standard quality)');\n      }\n\n      // Store loaded sprite data\n      this._spritePixelRatio = pixelRatio;\n      this._spriteData = spriteData;\n      this._spriteImage = spriteImage;\n      this._spritePngUrl = `${spriteUrl}${suffix}.png`;\n\n      // Extract icon names from sprite data\n      this._spriteIcons = Object.keys(this._spriteData);\n      console.log(`[Waypoints] Loaded ${this._spriteIcons.length} icons from sprite sheet`);\n    } catch (error) {\n      console.error('[Waypoints] Error loading sprite sheet:', error);\n      this._spriteIcons = [];\n      this._spriteImage = null;\n      this._spriteData = null;\n    }\n  }\n\n  async _loadFontstacks() {\n    try {\n      const style = this._map.getStyle();\n      if (!style || !style.glyphs) {\n        console.log('[Waypoints] No glyphs URL in style - text labels not available');\n        this._availableFonts = [];\n        return [];\n      }\n\n      // Extract base URL from glyphs template\n      // Example: \"https://example.com/fonts/{fontstack}/{range}.pbf\"\n      //       -> \"https://example.com/fonts/fontstacks.json\"\n      const glyphsUrl = style.glyphs;\n      console.log('[Waypoints] Glyphs URL template:', glyphsUrl);\n\n      const baseUrl = glyphsUrl.replace('/{fontstack}/{range}.pbf', '');\n      const fontstacksUrl = `${baseUrl}/fontstacks.json`;\n\n      console.log('[Waypoints] Base URL:', baseUrl);\n      console.log('[Waypoints] Trying to load fontstacks from:', fontstacksUrl);\n\n      // Try to load fontstacks.json (not a standard, may not exist)\n      try {\n        const response = await fetch(fontstacksUrl, {\n          method: 'GET',\n          headers: { Accept: 'application/json' }\n        });\n\n        if (response.ok) {\n          const fontstacks = await response.json();\n\n          if (Array.isArray(fontstacks) && fontstacks.length > 0) {\n            this._availableFonts = fontstacks;\n            console.log(`[Waypoints] ‚úì Loaded ${fontstacks.length} font stacks from fontstacks.json`);\n\n            if (!this._selectedFont) {\n              this._selectedFont = fontstacks[0];\n              console.log('[Waypoints] Selected default font:', this._selectedFont);\n            }\n\n            return fontstacks;\n          }\n        }\n      } catch (fetchError) {\n        // fontstacks.json not available - will extract from style instead\n        console.log('[Waypoints] fontstacks.json not available, extracting fonts from style layers...');\n      }\n\n      // Fallback: Extract fonts from style layers\n      const fonts = new Set();\n\n      if (style.layers) {\n        for (const layer of style.layers) {\n          if (layer.layout && layer.layout['text-font']) {\n            const textFont = layer.layout['text-font'];\n\n            // text-font can be:\n            // - Simple array: [\"Noto Sans Regular\", \"Arial Unicode MS Regular\"]\n            // - Expression: [\"literal\", [\"Noto Sans Regular\"]]\n            // - Dynamic: [\"get\", \"font_property\"]\n\n            if (Array.isArray(textFont)) {\n              // Handle [\"literal\", [...]] expressions\n              if (textFont[0] === 'literal' && Array.isArray(textFont[1])) {\n                textFont[1].forEach(font => {\n                  if (typeof font === 'string') fonts.add(font);\n                });\n              } else {\n                // Handle simple arrays or other cases\n                textFont.forEach(item => {\n                  if (typeof item === 'string' && !item.startsWith('get') && !item.startsWith('literal')) {\n                    fonts.add(item);\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n\n      const fontstacks = Array.from(fonts).sort();\n\n      if (fontstacks.length > 0) {\n        this._availableFonts = fontstacks;\n        console.log(`[Waypoints] ‚úì Extracted ${fontstacks.length} fonts from style:`, fontstacks);\n\n        if (!this._selectedFont) {\n          this._selectedFont = fontstacks[0];\n          console.log('[Waypoints] Selected default font:', this._selectedFont);\n        }\n\n        return fontstacks;\n      }\n\n      // No fonts found at all\n      console.warn('[Waypoints] No fonts found in style');\n      this._availableFonts = [];\n      return [];\n    } catch (error) {\n      console.error('[Waypoints] Error loading fontstacks:', error);\n      this._availableFonts = [];\n      return [];\n    }\n  }\n\n  // ============================================================================\n  // FONTS - Font management for labels\n  // ============================================================================\n\n  _populateFontSelect() {\n    if (!this._panel) return;\n    const fontSelect = asSelect(this._panel.querySelector('#ve-font-select'));\n    const fontStatus = asHTMLElement(this._panel.querySelector('#ve-font-status'));\n    if (!fontSelect || !fontStatus) return;\n\n    fontSelect.innerHTML = '';\n\n    if (this._availableFonts.length === 0) {\n      const option = document.createElement('option');\n      option.value = '';\n      option.textContent = 'No fonts available';\n      option.disabled = true;\n      fontSelect.appendChild(option);\n      if (fontStatus) {\n        fontStatus.textContent = 'No fonts available - labels cannot be shown';\n        fontStatus.style.color = '#e74c3c';\n      }\n      return;\n    }\n\n    this._availableFonts.forEach(font => {\n      const option = document.createElement('option');\n      option.value = font;\n      option.textContent = font;\n      fontSelect.appendChild(option);\n    });\n\n    if (this._selectedFont) {\n      fontSelect.value = this._selectedFont;\n    }\n\n    if (fontStatus) {\n      fontStatus.textContent = `${this._availableFonts.length} fonts available`;\n      fontStatus.style.color = '#4CAF50';\n    }\n  }\n\n  // ============================================================================\n  // SPRITES UI - Icon selection and preview\n  // ============================================================================\n\n  _updateIconAvailability() {\n    if (!this._panel) return;\n    const statusEl = asHTMLElement(this._panel.querySelector('#ve-icon-mode-status'));\n\n    if (!statusEl) return;\n\n    if (this._spriteIcons.length > 0) {\n      // Show available icons count\n      statusEl.textContent = `${this._spriteIcons.length} icons available`;\n      statusEl.style.color = '#4CAF50';\n    } else {\n      // Show that default icon will be used\n      statusEl.textContent = 'Using default icon';\n      statusEl.style.color = '#999';\n      console.log('[Waypoints] No map sprites found - using built-in default icon');\n    }\n  }\n\n  _initWaypointsIconSelect() {\n    if (!this._panel) return;\n    const iconSelect = asSelect(this._panel.querySelector('#ve-wp-icon'));\n    const searchInput = asHTMLElement(this._panel.querySelector('#ve-wp-icon-search'));\n    if (!iconSelect) return;\n\n    // Show/hide search based on mode\n    if (searchInput) {\n      searchInput.style.display = (this._spriteIcons.length > 30) ? 'block' : 'none';\n    }\n\n    // Store all icons for filtering (sprite mode only)\n    this._allIcons = [...this._spriteIcons];\n\n    // Fill select with icons\n    this._fillIconSelect();\n\n    // Add search listener for sprite icons\n    if (searchInput) {\n      searchInput.removeEventListener('input', this._handleIconSearch);\n      this._handleIconSearch = this._handleIconSearch.bind(this);\n      searchInput.addEventListener('input', this._handleIconSearch);\n    }\n\n    // Add change listener to update preview\n    iconSelect.removeEventListener('change', this._updateIconPreview);\n    this._updateIconPreview = this._updateIconPreview.bind(this);\n    iconSelect.addEventListener('change', this._updateIconPreview);\n\n    // Update preview for current selection\n    this._updateIconPreview();\n  }\n\n  _fillIconSelect(filter = '') {\n    if (!this._panel) return;\n    const iconSelect = asSelect(this._panel.querySelector('#ve-wp-icon'));\n    if (!iconSelect) return;\n\n    const currentValue = iconSelect.value;\n    iconSelect.innerHTML = '';\n\n    if (this._spriteIcons.length > 0) {\n      // Always add default icon as first option\n      if (!filter || 'waypoint-default'.includes(filter.toLowerCase()) || 'default'.includes(filter.toLowerCase())) {\n        const defaultOption = document.createElement('option');\n        defaultOption.value = 'waypoint-default';\n        defaultOption.textContent = 'üéØ Default Waypoint Icon';\n        iconSelect.appendChild(defaultOption);\n      }\n\n      // Filter icons if search is active\n      const iconsToShow = filter\n        ? (this._allIcons || []).filter(id => id.toLowerCase().includes(filter.toLowerCase()))\n        : (this._allIcons || []);\n\n      // Add all icons (no limit)\n      iconsToShow.forEach(iconId => {\n        const option = document.createElement('option');\n        option.value = iconId;\n        option.textContent = iconId.replace(/[_-]/g, ' ');\n        iconSelect.appendChild(option);\n      });\n\n      // If no results\n      if (iconsToShow.length === 0) {\n        const option = document.createElement('option');\n        option.value = '';\n        option.textContent = 'No icons found';\n        option.disabled = true;\n        iconSelect.appendChild(option);\n      }\n    } else {\n      // No sprites available - show default icon option\n      const option = document.createElement('option');\n      option.value = 'waypoint-default';\n      option.textContent = 'Default Waypoint Icon';\n      iconSelect.appendChild(option);\n    }\n\n    // Restore previous selection if it exists\n    const iconSelectCasted = asSelect(iconSelect);\n    if (currentValue && iconSelectCasted && Array.from(iconSelectCasted.options).some(opt => opt.value === currentValue)) {\n      iconSelectCasted.value = currentValue;\n    } else if (iconSelectCasted && iconSelectCasted.options.length > 0) {\n      // Select first non-disabled option if no previous selection\n      const firstValidOption = Array.from(iconSelectCasted.options).find(opt => !opt.disabled);\n      if (firstValidOption) {\n        iconSelectCasted.value = firstValidOption.value;\n      }\n    }\n\n    // Re-attach change listener (innerHTML = '' removes it)\n    iconSelect.removeEventListener('change', this._updateIconPreview);\n    iconSelect.addEventListener('change', this._updateIconPreview);\n\n    // Update preview for current selection\n    this._updateIconPreview();\n  }\n\n  _handleIconSearch(e) {\n    const filter = e.target.value;\n    this._fillIconSelect(filter);\n    this._updateIconPreview();\n  }\n\n  _updateIconPreview() {\n    if (!this._panel) return;\n    const iconSelect = asSelect(this._panel.querySelector('#ve-wp-icon'));\n    const previewDiv = asHTMLElement(this._panel.querySelector('#ve-wp-icon-preview'));\n\n    if (!iconSelect || !previewDiv) return;\n\n    const selectedIcon = iconSelect.value;\n\n    // Clear previous content\n    previewDiv.innerHTML = '';\n\n    // Handle empty selection\n    if (!selectedIcon) {\n      const span = document.createElement('span');\n      span.style.fontSize = '20px';\n      span.textContent = 'üìç';\n      previewDiv.appendChild(span);\n      return;\n    }\n\n    // Handle default waypoint icon\n    if (selectedIcon === 'waypoint-default') {\n      const div = document.createElement('div');\n      div.innerHTML = `<svg width=\"24\" height=\"36\" viewBox=\"0 0 24 36\" xmlns=\"http://www.w3.org/2000/svg\">\n                <ellipse cx=\"12\" cy=\"34\" rx=\"4\" ry=\"2\" fill=\"rgba(0,0,0,0.3)\" />\n                <path d=\"M12 2 C7 2 3 6 3 11 C3 16 12 26 12 26 C12 26 21 16 21 11 C21 6 17 2 12 2 Z\" fill=\"white\" />\n                <path d=\"M12 4 C8 4 5 7 5 11 C5 15 12 24 12 24 C12 24 19 15 19 11 C19 7 16 4 12 4 Z\" fill=\"#3887be\" />\n                <circle cx=\"12\" cy=\"11\" r=\"3\" fill=\"white\" opacity=\"0.9\" />\n            </svg>`;\n      div.style.display = 'flex';\n      div.style.alignItems = 'center';\n      div.style.justifyContent = 'center';\n      div.style.width = '100%';\n      div.style.height = '100%';\n      previewDiv.appendChild(div);\n      console.log('[Preview] Default icon preview created');\n      return;\n    }\n\n    console.log('[Preview] Updating icon preview:', {\n      selectedIcon,\n      hasSpriteData: !!this._spriteData,\n      hasIconInData: this._spriteData ? !!this._spriteData[selectedIcon] : false,\n      hasSpriteUrl: !!this._spritePngUrl,\n      hasSpriteImage: !!this._spriteImage,\n      imageComplete: this._spriteImage ? this._spriteImage.complete : false\n    });\n\n    // Verify sprite image is loaded before accessing dimensions\n    if (this._spriteData &&\n            this._spriteData[selectedIcon] &&\n            this._spritePngUrl &&\n            this._spriteImage &&\n            this._spriteImage.complete) {\n      const iconData = this._spriteData[selectedIcon];\n      const pr = this._spritePixelRatio || 2; // Use stored pixelRatio (default @2x)\n\n      // Calculate background dimensions safely\n      const bgWidth = this._spriteImage.width / pr;\n      const bgHeight = this._spriteImage.height / pr;\n\n      console.log('[Preview] Sprite dimensions:', {\n        iconWidth: iconData.width,\n        iconHeight: iconData.height,\n        iconX: iconData.x,\n        iconY: iconData.y,\n        bgWidth,\n        bgHeight,\n        pixelRatio: pr\n      });\n\n      // Verify dimensions are valid before using them\n      if (!isNaN(bgWidth) && !isNaN(bgHeight) && bgWidth > 0 && bgHeight > 0) {\n        const div = document.createElement('div');\n        div.style.width = `${iconData.width / pr}px`;\n        div.style.height = `${iconData.height / pr}px`;\n        div.style.backgroundImage = `url(${this._spritePngUrl})`;\n        div.style.backgroundPosition = `-${iconData.x / pr}px -${iconData.y / pr}px`;\n        div.style.backgroundSize = `${bgWidth}px ${bgHeight}px`;\n        div.style.backgroundRepeat = 'no-repeat';\n        div.style.maxWidth = '100%';\n        div.style.maxHeight = '100%';\n        previewDiv.appendChild(div);\n        console.log('[Preview] Sprite preview created successfully');\n        return;\n      } else {\n        console.warn('[Preview] Invalid sprite dimensions');\n      }\n    } else {\n      console.warn('[Preview] Sprite not available');\n    }\n\n    // No preview available\n    const span = document.createElement('span');\n    span.style.fontSize = '12px';\n    span.style.color = '#999';\n    span.textContent = 'No preview';\n    previewDiv.appendChild(span);\n  }\n\n  /**\n   * Fill popup icon select with filtered options\n   * @param {number} index - Waypoint index\n   * @param {string} filter - Search filter\n   */\n  _fillPopupIconSelect(index, filter = '') {\n    // Find currently open popup\n    const popups = document.querySelectorAll('.maplibregl-popup');\n    if (popups.length === 0) return;\n\n    // Find the icon select in the popup\n    const iconSelect = document.querySelector(`#ve-popup-icon-select-${index}`);\n    if (!iconSelect) return;\n\n    const currentValue = asSelect(iconSelect)?.value;\n    iconSelect.innerHTML = '';\n\n    if (this._spriteIcons.length > 0) {\n      // Always add default icon as first option\n      if (!filter || 'waypoint-default'.includes(filter.toLowerCase()) || 'default'.includes(filter.toLowerCase())) {\n        const defaultOption = document.createElement('option');\n        defaultOption.value = 'waypoint-default';\n        defaultOption.textContent = 'üéØ Default Waypoint Icon';\n        iconSelect.appendChild(defaultOption);\n      }\n\n      // Filter icons if search is active\n      const iconsToShow = filter\n        ? this._spriteIcons.filter(id => id.toLowerCase().includes(filter.toLowerCase()))\n        : this._spriteIcons;\n\n      // Add sprite icons (no limit)\n      iconsToShow.forEach(iconId => {\n        const option = document.createElement('option');\n        option.value = iconId;\n        option.textContent = iconId;\n        iconSelect.appendChild(option);\n      });\n    } else {\n      // Fallback if no sprite icons\n      const defaultOption = document.createElement('option');\n      defaultOption.value = 'waypoint-default';\n      defaultOption.textContent = 'Default Waypoint';\n      iconSelect.appendChild(defaultOption);\n    }\n\n    // Restore selection\n    if (currentValue) {\n      asSelect(iconSelect).value = currentValue;\n    }\n  }\n\n  /**\n   * Update icon preview in popup\n   * @param {number} index - Waypoint index\n   */\n  _updatePopupIconPreview(index) {\n    const iconSelect = document.querySelector(`#ve-popup-icon-select-${index}`);\n    const previewDiv = document.querySelector(`#ve-popup-icon-preview-${index}`);\n\n    if (!iconSelect || !previewDiv) return;\n\n    const selectedIcon = asSelect(iconSelect)?.value;\n\n    // Clear previous content\n    previewDiv.innerHTML = '';\n\n    // Handle empty selection\n    if (!selectedIcon) {\n      const span = document.createElement('span');\n      span.style.fontSize = '20px';\n      span.textContent = 'üìç';\n      previewDiv.appendChild(span);\n      return;\n    }\n\n    // Handle default waypoint icon\n    if (selectedIcon === 'waypoint-default') {\n      const div = document.createElement('div');\n      div.innerHTML = `<svg width=\"24\" height=\"36\" viewBox=\"0 0 24 36\" xmlns=\"http://www.w3.org/2000/svg\">\n                <ellipse cx=\"12\" cy=\"34\" rx=\"4\" ry=\"2\" fill=\"rgba(0,0,0,0.3)\" />\n                <path d=\"M12 2 C7 2 3 6 3 11 C3 16 12 26 12 26 C12 26 21 16 21 11 C21 6 17 2 12 2 Z\" fill=\"white\" />\n                <circle cx=\"12\" cy=\"11\" r=\"5\" fill=\"#2196F3\" />\n            </svg>`;\n      div.style.display = 'flex';\n      div.style.justifyContent = 'center';\n      div.style.alignItems = 'center';\n      div.style.width = '100%';\n      div.style.height = '100%';\n      previewDiv.appendChild(div);\n      return;\n    }\n\n    // Verify sprite image is loaded before accessing dimensions\n    if (this._spriteData &&\n                this._spriteData[selectedIcon] &&\n                this._spritePngUrl &&\n                this._spriteImage &&\n                this._spriteImage.complete &&\n                this._spriteImage.naturalWidth > 0 &&\n                this._spriteImage.naturalHeight > 0) {\n      const iconData = this._spriteData[selectedIcon];\n      const pr = typeof iconData.pixelRatio === 'number' ? iconData.pixelRatio : 1;\n      const bgWidth = this._spriteImage.naturalWidth / pr;\n      const bgHeight = this._spriteImage.naturalHeight / pr;\n\n      if (typeof bgWidth === 'number' && typeof bgHeight === 'number' && bgWidth > 0 && bgHeight > 0) {\n        const div = document.createElement('div');\n        div.style.width = `${iconData.width / pr}px`;\n        div.style.height = `${iconData.height / pr}px`;\n        div.style.backgroundImage = `url(${this._spritePngUrl})`;\n        div.style.backgroundPosition = `-${iconData.x / pr}px -${iconData.y / pr}px`;\n        div.style.backgroundSize = `${bgWidth}px ${bgHeight}px`;\n        div.style.backgroundRepeat = 'no-repeat';\n        div.style.maxWidth = '100%';\n        div.style.maxHeight = '100%';\n        previewDiv.appendChild(div);\n        return;\n      }\n    }\n\n    // No preview available\n    const span = document.createElement('span');\n    span.style.fontSize = '12px';\n    span.style.color = '#999';\n    span.textContent = 'No preview';\n    previewDiv.appendChild(span);\n  }\n\n  // ============================================================================\n  // WAYPOINTS DEFAULT ICON - Built-in fallback icon\n  // ============================================================================\n\n  /**\n     * Add a default waypoint icon to MapLibre using dataURL\n     * This provides a fallback when no sprite sheet is available\n     */\n  _addDefaultWaypointIcon() {\n    if (!this._map) return;\n\n    // SVG pin/marker icon (24x36px)\n    const svg = `<svg width=\"24\" height=\"36\" viewBox=\"0 0 24 36\" xmlns=\"http://www.w3.org/2000/svg\">\n            <!-- Drop shadow -->\n            <ellipse cx=\"12\" cy=\"34\" rx=\"4\" ry=\"2\" fill=\"rgba(0,0,0,0.3)\" />\n            <!-- Pin body with white border -->\n            <path d=\"M12 2 C7 2 3 6 3 11 C3 16 12 26 12 26 C12 26 21 16 21 11 C21 6 17 2 12 2 Z\"\n                  fill=\"white\" />\n            <!-- Pin body colored -->\n            <path d=\"M12 4 C8 4 5 7 5 11 C5 15 12 24 12 24 C12 24 19 15 19 11 C19 7 16 4 12 4 Z\"\n                  fill=\"#3887be\" />\n            <!-- Center dot -->\n            <circle cx=\"12\" cy=\"11\" r=\"3\" fill=\"white\" opacity=\"0.9\" />\n        </svg>`;\n\n    // Convert SVG to dataURL\n    const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);\n\n    // Load image and add to map\n    const img = new Image(24, 36);\n    img.onload = () => {\n      if (this._map.hasImage('waypoint-default')) {\n        console.log('[Waypoints] Default icon already exists, skipping');\n        return;\n      }\n      this._map.addImage('waypoint-default', img, { pixelRatio: 1 });\n      console.log('[Waypoints] ‚úì Added default waypoint icon');\n    };\n    img.onerror = (err) => {\n      console.error('[Waypoints] Failed to load default icon:', err);\n    };\n    img.src = dataUrl;\n  }\n\n  /**\n   * Async version that ensures icon is loaded before proceeding\n   * Used during recording when time is frozen\n   */\n  async _ensureDefaultWaypointIcon() {\n    if (!this._map) return;\n\n    // Already loaded?\n    if (this._map.hasImage('waypoint-default')) {\n      return;\n    }\n\n    // SVG pin/marker icon (24x36px)\n    const svg = `<svg width=\"24\" height=\"36\" viewBox=\"0 0 24 36\" xmlns=\"http://www.w3.org/2000/svg\">\n            <!-- Drop shadow -->\n            <ellipse cx=\"12\" cy=\"34\" rx=\"4\" ry=\"2\" fill=\"rgba(0,0,0,0.3)\" />\n            <!-- Pin body with white border -->\n            <path d=\"M12 2 C7 2 3 6 3 11 C3 16 12 26 12 26 C12 26 21 16 21 11 C21 6 17 2 12 2 Z\"\n                  fill=\"white\" />\n            <!-- Pin body colored -->\n            <path d=\"M12 4 C8 4 5 7 5 11 C5 15 12 24 12 24 C12 24 19 15 19 11 C19 7 16 4 12 4 Z\"\n                  fill=\"#3887be\" />\n            <!-- Center dot -->\n            <circle cx=\"12\" cy=\"11\" r=\"3\" fill=\"white\" opacity=\"0.9\" />\n        </svg>`;\n\n    // Convert SVG to dataURL\n    const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);\n\n    // Load image synchronously\n    return new Promise((resolve, reject) => {\n      const img = new Image(24, 36);\n      img.onload = () => {\n        this._map.addImage('waypoint-default', img, { pixelRatio: 1 });\n        console.log('[Waypoints] ‚úì Added default waypoint icon (sync)');\n        resolve();\n      };\n      img.onerror = (err) => {\n        console.error('[Waypoints] Failed to load default icon:', err);\n        reject(err);\n      };\n      img.src = dataUrl;\n    });\n  }\n\n  // ============================================================================\n  // WAYPOINTS MARKERS - Draggable markers management\n  // ============================================================================\n\n  /**\n     * Create a marker DOM element with sprite icon\n     * @param {string} iconId - The sprite icon ID to use\n     * @param {number} index - Waypoint index for identification\n     * @returns {HTMLElement} DOM element for the marker\n     */\n  _createMarkerElement(iconId, index) {\n    if (!this._spriteData || !this._spriteData[iconId] || !this._spritePngUrl) {\n      // Fallback: use same SVG icon as default waypoint icon\n      const el = document.createElement('div');\n      el.className = 've-waypoint-marker';\n      el.innerHTML = `<svg width=\"24\" height=\"36\" viewBox=\"0 0 24 36\" xmlns=\"http://www.w3.org/2000/svg\">\n                <ellipse cx=\"12\" cy=\"34\" rx=\"4\" ry=\"2\" fill=\"rgba(0,0,0,0.3)\" />\n                <path d=\"M12 2 C7 2 3 6 3 11 C3 16 12 26 12 26 C12 26 21 16 21 11 C21 6 17 2 12 2 Z\" fill=\"white\" />\n                <path d=\"M12 4 C8 4 5 7 5 11 C5 15 12 24 12 24 C12 24 19 15 19 11 C19 7 16 4 12 4 Z\" fill=\"#3887be\" />\n                <circle cx=\"12\" cy=\"11\" r=\"3\" fill=\"white\" opacity=\"0.9\" />\n            </svg>`;\n      el.style.cssText = `\n                width: 24px;\n                height: 36px;\n                cursor: grab;\n                filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));\n            `;\n      el.dataset.waypointIndex = String(index);\n      return el;\n    }\n\n    // Get sprite icon dimensions\n    const iconData = this._spriteData[iconId];\n    const pr = this._spritePixelRatio || 2;\n    const displayWidth = iconData.width / pr;\n    const displayHeight = iconData.height / pr;\n    const bgPosX = iconData.x / pr;\n    const bgPosY = iconData.y / pr;\n    const bgWidth = this._spriteImage ? this._spriteImage.width / pr : 'auto';\n    const bgHeight = this._spriteImage ? this._spriteImage.height / pr : 'auto';\n\n    // Scale icon (apply iconSize multiplier)\n    const scaledWidth = displayWidth * this._iconSize;\n    const scaledHeight = displayHeight * this._iconSize;\n\n    // Create marker element\n    const el = document.createElement('div');\n    el.className = 've-waypoint-marker';\n    el.dataset.waypointIndex = String(index);\n    el.style.cssText = `\n            width: ${scaledWidth}px;\n            height: ${scaledHeight}px;\n            background-image: url(${this._spritePngUrl});\n            background-position: -${bgPosX * this._iconSize}px -${bgPosY * this._iconSize}px;\n            background-size: ${typeof bgWidth === 'number' ? bgWidth * this._iconSize : bgWidth}px ${typeof bgHeight === 'number' ? bgHeight * this._iconSize : bgHeight}px;\n            background-repeat: no-repeat;\n            cursor: grab;\n            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));\n        `;\n\n    return el;\n  }\n\n  /**\n     * Create popup HTML content for waypoint editing\n     * @param {number} index - Waypoint index\n     * @returns {string} HTML content for popup\n     */\n  _createMarkerPopupHTML(index) {\n    const feature = this.options.waypoints.features[index];\n    if (!feature) return '';\n\n    const props = feature.properties;\n    const coords = feature.geometry.coordinates;\n\n    // Build icon options\n    let iconOptions = '<option value=\"waypoint-default\">Default Waypoint</option>';\n    if (this._spriteIcons && this._spriteIcons.length > 0) {\n      this._spriteIcons.forEach(iconName => {\n        const selected = props.icon === iconName ? 'selected' : '';\n        iconOptions += `<option value=\"${iconName}\" ${selected}>${iconName}</option>`;\n      });\n    }\n\n    return `\n            <div class=\"ve-waypoint-popup\" style=\"min-width: 280px; max-width: 320px; max-height: 70vh; overflow-y: auto;\">\n                <h3 style=\"font-size: 13px; font-weight: 600;\">${props.name || `Waypoint ${index + 1}`}</h3>\n\n                <div style=\"margin-bottom: 6px;\">\n                    <label style=\"display: block; font-size: 11px; color: #666; margin-bottom: 2px;\">Icon</label>\n                    <input type=\"text\" id=\"ve-popup-icon-search-${index}\" placeholder=\"Search icons...\"\n                           style=\"width: 100%; padding: 3px; font-size: 11px; border: 1px solid #ddd; border-radius: 3px; margin-bottom: 3px; display: ${this._spriteIcons.length > 30 ? 'block' : 'none'};\" />\n                    <select id=\"ve-popup-icon-select-${index}\" data-field=\"icon\" data-index=\"${index}\"\n                            style=\"width: 100%; padding: 3px; font-size: 12px; border: 1px solid #ddd; border-radius: 3px;\">\n                        ${iconOptions}\n                    </select>\n                    <div id=\"ve-popup-icon-preview-${index}\"\n                         style=\"margin-top: 4px; padding: 6px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 3px; text-align: center; min-height: 36px; display: flex; align-items: center; justify-content: center;\">\n                    </div>\n                </div>\n\n                <div style=\"margin-bottom: 6px;\">\n                    <label style=\"display: block; font-size: 11px; color: #666; margin-bottom: 2px;\">Name (optional)</label>\n                    <input type=\"text\" value=\"${props.name || ''}\" placeholder=\"e.g., Eiffel Tower\"\n                           data-field=\"name\" data-index=\"${index}\"\n                           style=\"width: 100%; padding: 3px; font-size: 12px; border: 1px solid #ddd; border-radius: 3px;\" />\n                </div>\n\n                <div style=\"margin-bottom: 6px;\">\n                    <label style=\"display: block; font-size: 11px; color: #666; margin-bottom: 2px;\">Coordinates</label>\n                    <div style=\"display: flex; gap: 4px;\">\n                        <input type=\"number\" id=\"ve-popup-lng-${index}\" placeholder=\"Longitude\" step=\"0.000001\" value=\"${coords[0].toFixed(6)}\" style=\"flex: 1; padding: 3px; font-size: 11px;\">\n                        <input type=\"number\" id=\"ve-popup-lat-${index}\" placeholder=\"Latitude\" step=\"0.000001\" value=\"${coords[1].toFixed(6)}\" style=\"flex: 1; padding: 3px; font-size: 11px;\">\n                    </div>\n                </div>\n\n                <div style=\"margin-bottom: 6px;\">\n                    <label style=\"font-size: 11px;\">\n                        <input type=\"checkbox\" id=\"ve-popup-camera-toggle-${index}\">\n                        Capturer la position de cam√©ra\n                    </label>\n                    <div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-top: 3px;\">\n                        <input type=\"number\" id=\"ve-popup-zoom-${index}\" placeholder=\"Zoom\" size=\"3\" step=\"0.5\" style=\"padding: 3px; font-size: 11px;\" disabled>\n                        <input type=\"number\" id=\"ve-popup-bearing-${index}\" placeholder=\"Bearing\" size=\"3\" step=\"1\" style=\"padding: 3px; font-size: 11px;\" disabled>\n                        <input type=\"number\" id=\"ve-popup-pitch-${index}\" placeholder=\"Pitch\" size=\"3\" step=\"1\" style=\"padding: 3px; font-size: 11px;\" disabled>\n                    </div>\n                    <small style=\"display: block; color: #999; font-size: 10px; margin-top: 2px;\">Fige le zoom et l'angle de vue pour ce point de passage</small>\n                </div>\n\n                <div style=\"margin-bottom: 6px;\">\n                    <label style=\"display: block; font-size: 11px; color: #666; margin-bottom: 2px;\">Pause Duration (ms)</label>\n                    <input type=\"number\" value=\"${props.duration || 2000}\" step=\"100\" placeholder=\"e.g., 3000\"\n                           data-field=\"duration\" data-index=\"${index}\"\n                           style=\"width: 100%; padding: 3px; font-size: 12px; border: 1px solid #ddd; border-radius: 3px;\" />\n                    <small style=\"display: block; color: #999; font-size: 10px; margin-top: 2px;\">How long to pause at this waypoint (0 = no pause)</small>\n                </div>\n\n                <div style=\"display: flex; gap: 4px; margin-top: 8px;\">\n                    <button class=\"ve-popup-save\" data-index=\"${index}\"\n                            style=\"flex: 1; padding: 5px; font-size: 11px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;\">\n                        ‚úì Save\n                    </button>\n                    <button class=\"ve-popup-cancel\" data-index=\"${index}\"\n                            style=\"flex: 1; padding: 5px; font-size: 11px; background: #999; color: white; border: none; border-radius: 3px; cursor: pointer;\">\n                        ‚úó Cancel\n                    </button>\n                </div>\n                <div style=\"margin-top: 4px;\">\n                    <button class=\"ve-popup-delete\" data-index=\"${index}\"\n                            style=\"width: 100%; padding: 5px; font-size: 11px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;\">\n                        üóëÔ∏è Delete\n                    </button>\n                </div>\n            </div>\n        `;\n  }\n\n  /**\n     * Create or update draggable markers for all waypoints\n     * Replaces the old layer-based approach\n     */\n  _createWaypointMarkers() {\n    if (!this._map) {\n      return;\n    }\n\n    // Remove existing markers\n    this._waypointMarkers.forEach(marker => marker.remove());\n    this._waypointMarkers = [];\n\n    const features = this.options.waypoints.features || [];\n\n    if (features.length === 0) {\n      return;\n    }\n\n    features.forEach((feature, index) => {\n      const coords = feature.geometry.coordinates;\n      const props = feature.properties;\n\n      // Find sprite icon for this waypoint\n      const iconName = props.icon || 'waypoint-default';\n      let iconId = null;\n\n      // Handle built-in default icon (not a sprite)\n      if (iconName === 'waypoint-default') {\n        iconId = 'waypoint-default';\n      } else {\n        // Try to find matching icon in sprite data\n        const searchTerm = iconName.toLowerCase();\n\n        // First try exact match\n        if (this._spriteIcons.includes(iconName)) {\n          iconId = iconName;\n        } else {\n          // Then try fuzzy match\n          iconId = this._spriteIcons.find(icon => {\n            const iconLower = icon.toLowerCase();\n            return iconLower.includes(searchTerm) ||\n                               iconLower.startsWith(searchTerm + '-') ||\n                               iconLower.startsWith(searchTerm + '_');\n          });\n        }\n\n        // If not found, use default icon\n        if (!iconId) {\n          iconId = 'waypoint-default';\n        }\n      }\n\n      console.log(`[Waypoints] Marker ${index}: icon=\"${iconName}\" ‚Üí iconId=\"${iconId}\"`);\n\n      // Create marker element\n      const el = this._createMarkerElement(iconId, index);\n\n      // Create marker with draggable option\n      const marker = new maplibregl.Marker({\n        element: el,\n        draggable: true,\n        anchor: 'bottom' // Anchor at bottom center (like a pin)\n      })\n        .setLngLat(coords)\n        .addTo(this._map);\n\n      // Create popup for editing\n      const popupHTML = this._createMarkerPopupHTML(index);\n      const popup = new maplibregl.Popup({\n        offset: 25,\n        closeButton: true,\n        closeOnClick: true\n      })\n        .setHTML(popupHTML);\n\n      marker.setPopup(popup);\n\n      // Listen to marker events (using official MapLibre API)\n      let originalCoords = null;\n      marker.on('dragstart', () => {\n        el.style.cursor = 'grabbing';\n        // Save original coordinates in case we need to revert\n        originalCoords = [...feature.geometry.coordinates];\n      });\n\n      marker.on('dragend', () => {\n        el.style.cursor = 'grab';\n        const lngLat = marker.getLngLat();\n\n        // Validate coordinates against bounds if defined\n        if (!this._validateWaypointCoordinates(lngLat.lng, lngLat.lat)) {\n          const [[west, south], [east, north]] = this.options.maxBounds;\n          const waypointName = feature.properties.name || `Waypoint ${index + 1}`;\n          const confirmed = confirm(\n            '‚ö†Ô∏è Warning: This position is OUTSIDE the defined geographic bounds!\\n\\n' +\n                        `Waypoint: \"${waypointName}\"\\n` +\n                        `New position: [${lngLat.lng.toFixed(4)}, ${lngLat.lat.toFixed(4)}]\\n` +\n                        `Bounds: [${west.toFixed(2)}, ${south.toFixed(2)}] to [${east.toFixed(2)}, ${north.toFixed(2)}]\\n\\n` +\n                        'Animations may not visit this waypoint if strict bounds are enabled.\\n\\n' +\n                        'Keep new position?'\n          );\n\n          if (!confirmed) {\n            // Revert to original position\n            marker.setLngLat(originalCoords);\n            console.log(`[Waypoints] Marker ${index} drag cancelled - out of bounds`);\n            return;\n          }\n        }\n\n        // Update waypoint coordinates\n        feature.geometry.coordinates = [lngLat.lng, lngLat.lat];\n\n        // Update popup content with new coordinates\n        popup.setHTML(this._createMarkerPopupHTML(index));\n\n        // Re-attach event listeners after popup content update\n        this._attachPopupEventListeners(index, popup);\n\n        console.log(`[Waypoints] Marker ${index} dragged to:`, lngLat);\n      });\n\n      // Attach event listeners for popup inputs\n      popup.on('open', () => {\n        this._attachPopupEventListeners(index, popup);\n      });\n\n      // Store marker reference\n      this._waypointMarkers.push(marker);\n    });\n\n    console.log(`[Waypoints] ‚úì Created ${this._waypointMarkers.length} draggable markers`);\n  }\n\n  /**\n     * Attach event listeners to popup input fields\n     * @param {number} index - Waypoint index\n     * @param {maplibregl.Popup} popup - Popup instance\n     */\n  _attachPopupEventListeners(index, popup) {\n    const popupEl = popup.getElement();\n    if (!popupEl) return;\n\n    const feature = this.options.waypoints.features[index];\n    if (!feature) return;\n\n    // Store camera update listener for cleanup (declared here so buttons can access it)\n    let cameraUpdateListener = null;\n\n    // Input fields (name, zoom, duration, bearing, pitch)\n    const inputs = popupEl.querySelectorAll('input[data-field]');\n    inputs.forEach(input => {\n      input.addEventListener('change', (e) => {\n        const field = /** @type {HTMLElement} */(e.target)?.dataset.field;\n        if (!field) return;\n\n        /** @type {string | number | undefined} */\n        let value = asInput(e.target)?.value;\n\n        // Parse numbers or remove empty values\n        if (field === 'zoom' || field === 'duration' || field === 'bearing' || field === 'pitch') {\n          if (value === '' || value === null || value === undefined) {\n            // Remove property if empty (will use auto values)\n            delete feature.properties[field];\n          } else {\n            value = parseFloat(value);\n            feature.properties[field] = value;\n          }\n        } else {\n          // String fields (name)\n          feature.properties[field] = value;\n        }\n\n        // Update UI list in panel\n        this._updateWaypointsUI();\n\n        console.log(`[Waypoints] Updated waypoint ${index} ${field}:`, value);\n      });\n    });\n\n    // Icon select\n    const iconSelect = popupEl.querySelector(`#ve-popup-icon-select-${index}`);\n    if (iconSelect) {\n      iconSelect.addEventListener('change', (e) => {\n        const iconValue = asSelect(e.target)?.value;\n        if (!iconValue) return;\n\n        // Update icon property\n        feature.properties.icon = iconValue;\n\n        // Update preview\n        this._updatePopupIconPreview(index);\n\n        // Don't recreate markers here - would close popup\n        // Markers will be updated when Save is clicked\n\n        console.log(`[Waypoints] Updated waypoint ${index} icon:`, iconValue);\n      });\n\n      // Initialize preview on popup open\n      this._updatePopupIconPreview(index);\n    }\n\n    // Icon search\n    const iconSearch = popupEl.querySelector(`#ve-popup-icon-search-${index}`);\n    if (iconSearch && iconSelect) {\n      iconSearch.addEventListener('input', (e) => {\n        const filter = asInput(e.target)?.value || '';\n        this._fillPopupIconSelect(index, filter);\n        this._updatePopupIconPreview(index);\n      });\n    }\n\n    // Save button (close popup and update markers)\n    const saveBtn = popupEl.querySelector('.ve-popup-save');\n    if (saveBtn) {\n      saveBtn.addEventListener('click', () => {\n        // Stop camera listener if active\n        if (this._map && cameraUpdateListener) {\n          this._map.off('move', cameraUpdateListener);\n          cameraUpdateListener = null;\n        }\n\n        // Close popup\n        popup.remove();\n\n        // Recreate markers to update position (if coordinates changed)\n        this._createWaypointMarkers();\n\n        // Update UI list now that editing is done\n        this._updateWaypointsUI();\n\n        // Save to localStorage\n        this._saveWaypoints();\n\n        console.log(`[Waypoints] Saved waypoint ${index}`);\n      });\n    }\n\n    // Cancel button (revert changes and close)\n    const cancelBtn = popupEl.querySelector('.ve-popup-cancel');\n    if (cancelBtn) {\n      cancelBtn.addEventListener('click', () => {\n        // Stop camera listener if active\n        if (this._map && cameraUpdateListener) {\n          this._map.off('move', cameraUpdateListener);\n          cameraUpdateListener = null;\n        }\n\n        // Note: We don't revert changes here as they're applied in real-time\n        // If you want to revert, you'd need to store initial state\n\n        // Just close popup\n        popup.remove();\n\n        console.log(`[Waypoints] Cancelled editing waypoint ${index}`);\n      });\n    }\n\n    // Delete button\n    const deleteBtn = popupEl.querySelector('.ve-popup-delete');\n    if (deleteBtn) {\n      deleteBtn.addEventListener('click', () => {\n        // Stop camera listener if active\n        if (this._map && cameraUpdateListener) {\n          this._map.off('move', cameraUpdateListener);\n          cameraUpdateListener = null;\n        }\n\n        // Remove from data\n        this.options.waypoints.features.splice(index, 1);\n\n        // Close popup\n        popup.remove();\n\n        // Recreate all markers (indices have changed)\n        this._createWaypointMarkers();\n\n        // Update UI list\n        this._updateWaypointsUI();\n\n        // Save to localStorage\n        this._saveWaypoints();\n\n        console.log(`[Waypoints] Deleted waypoint ${index}`);\n      });\n    }\n\n    // Coordinates fields\n    const lngField = popupEl.querySelector(`#ve-popup-lng-${index}`);\n    const latField = popupEl.querySelector(`#ve-popup-lat-${index}`);\n\n    if (lngField && latField) {\n      lngField.addEventListener('change', (e) => {\n        const value = parseFloat(asInput(e.target)?.value || '');\n        if (!isNaN(value)) {\n          feature.geometry.coordinates[0] = value;\n          // Don't recreate markers here - would close the popup\n          // Marker position will be updated when Save is clicked\n          console.log(`[Waypoints] Updated longitude to ${value}`);\n        }\n      });\n\n      latField.addEventListener('change', (e) => {\n        const value = parseFloat(asInput(e.target)?.value || '');\n        if (!isNaN(value)) {\n          feature.geometry.coordinates[1] = value;\n          // Don't recreate markers here - would close the popup\n          // Marker position will be updated when Save is clicked\n          console.log(`[Waypoints] Updated latitude to ${value}`);\n        }\n      });\n    }\n\n    // Camera toggle checkbox\n    const cameraToggle = popupEl.querySelector(`#ve-popup-camera-toggle-${index}`);\n    const zoomField = popupEl.querySelector(`#ve-popup-zoom-${index}`);\n    const bearingField = popupEl.querySelector(`#ve-popup-bearing-${index}`);\n    const pitchField = popupEl.querySelector(`#ve-popup-pitch-${index}`);\n\n    if (cameraToggle && zoomField && bearingField && pitchField) {\n      const cameraToggleEl = asInput(cameraToggle);\n      const zoomFieldEl = asInput(zoomField);\n      const bearingFieldEl = asInput(bearingField);\n      const pitchFieldEl = asInput(pitchField);\n\n      // Function to update camera fields from map\n      const updateCameraFields = () => {\n        if (!this._map) return;\n        const zoom = this._map.getZoom();\n        const bearing = this._map.getBearing();\n        const pitch = this._map.getPitch();\n\n        if (zoomFieldEl) zoomFieldEl.value = zoom.toFixed(1);\n        if (bearingFieldEl) bearingFieldEl.value = bearing.toFixed(0);\n        if (pitchFieldEl) pitchFieldEl.value = pitch.toFixed(0);\n\n        feature.properties.zoom = zoom;\n        feature.properties.bearing = bearing;\n        feature.properties.pitch = pitch;\n\n        // Don't update UI here - would close the popup\n      };\n\n      // Initialize checkbox state and field values if properties exist\n      if (feature.properties.zoom !== undefined || feature.properties.bearing !== undefined || feature.properties.pitch !== undefined) {\n        if (cameraToggleEl) cameraToggleEl.checked = true;\n        if (zoomFieldEl) {\n          zoomFieldEl.disabled = false;\n          if (feature.properties.zoom !== undefined) zoomFieldEl.value = feature.properties.zoom.toString();\n        }\n        if (bearingFieldEl) {\n          bearingFieldEl.disabled = false;\n          if (feature.properties.bearing !== undefined) bearingFieldEl.value = feature.properties.bearing.toString();\n        }\n        if (pitchFieldEl) {\n          pitchFieldEl.disabled = false;\n          if (feature.properties.pitch !== undefined) pitchFieldEl.value = feature.properties.pitch.toString();\n        }\n\n        // Start auto-update if checkbox is checked\n        if (this._map) {\n          cameraUpdateListener = updateCameraFields;\n          this._map.on('move', cameraUpdateListener);\n        }\n      }\n\n      // Toggle camera capture\n      cameraToggle.addEventListener('change', (e) => {\n        const checked = asInput(e.target)?.checked;\n\n        if (checked) {\n          // Enable fields and populate with current map values\n          if (zoomFieldEl) zoomFieldEl.disabled = false;\n          if (bearingFieldEl) bearingFieldEl.disabled = false;\n          if (pitchFieldEl) pitchFieldEl.disabled = false;\n\n          // Initial update\n          updateCameraFields();\n\n          // Start auto-update on map movements\n          if (this._map && !cameraUpdateListener) {\n            cameraUpdateListener = updateCameraFields;\n            this._map.on('move', cameraUpdateListener);\n          }\n        } else {\n          // Disable fields and remove properties\n          if (zoomFieldEl) {\n            zoomFieldEl.disabled = true;\n            zoomFieldEl.value = '';\n          }\n          if (bearingFieldEl) {\n            bearingFieldEl.disabled = true;\n            bearingFieldEl.value = '';\n          }\n          if (pitchFieldEl) {\n            pitchFieldEl.disabled = true;\n            pitchFieldEl.value = '';\n          }\n\n          delete feature.properties.zoom;\n          delete feature.properties.bearing;\n          delete feature.properties.pitch;\n\n          // Stop auto-update\n          if (this._map && cameraUpdateListener) {\n            this._map.off('move', cameraUpdateListener);\n            cameraUpdateListener = null;\n          }\n        }\n\n        console.log(`[Waypoints] Camera capture ${checked ? 'enabled' : 'disabled'} for waypoint ${index}`);\n      });\n\n      // Handle manual field changes (user edits)\n      [zoomField, bearingField, pitchField].forEach(field => {\n        field.addEventListener('change', (e) => {\n          const inputEl = asInput(e.target);\n          const value = inputEl?.value;\n          const fieldId = inputEl?.id || '';\n\n          if (value && value !== '') {\n            const numValue = parseFloat(value);\n            if (fieldId.includes('zoom')) {\n              feature.properties.zoom = numValue;\n            } else if (fieldId.includes('bearing')) {\n              feature.properties.bearing = numValue;\n            } else if (fieldId.includes('pitch')) {\n              feature.properties.pitch = numValue;\n            }\n            console.log(`[Waypoints] Manually updated camera ${fieldId} to ${numValue}`);\n          }\n          // Don't update UI here - would close the popup\n        });\n      });\n\n      // Cleanup listener when popup is closed\n      popup.on('close', () => {\n        if (this._map && cameraUpdateListener) {\n          this._map.off('move', cameraUpdateListener);\n          cameraUpdateListener = null;\n        }\n      });\n    }\n  }\n\n  // ============================================================================\n  // WAYPOINTS LAYER - Map layer management (DEPRECATED - now using Markers)\n  // ============================================================================\n\n  _createWaypointsLayer() {\n    // Legacy method - now redirects to marker-based implementation\n    console.log('[Waypoints] _createWaypointsLayer called (redirecting to markers)');\n    this._createWaypointMarkers();\n  }\n\n  _updateWaypointsLayer() {\n    // Legacy method - now redirects to marker-based implementation\n    console.log('[Waypoints] _updateWaypointsLayer called (redirecting to markers)');\n    this._createWaypointMarkers();\n  }\n\n  _removeWaypointsLayer() {\n    // Legacy method - now removes markers instead of layer\n    console.log('[Waypoints] _removeWaypointsLayer called (removing markers)');\n    this._waypointMarkers.forEach(marker => marker.remove());\n    this._waypointMarkers = [];\n  }\n\n  /**\n     * Hide waypoint markers (e.g., during recording)\n     * Markers are DOM elements that appear in the video, so we need to hide them\n     */\n  _hideWaypointMarkers() {\n    console.log('[Waypoints] Hiding waypoint markers for recording');\n    this._waypointMarkers.forEach(marker => {\n      const el = marker.getElement();\n      if (el) {\n        el.style.display = 'none';\n      }\n    });\n  }\n\n  /**\n     * Show waypoint markers (e.g., after recording)\n     */\n  _showWaypointMarkers() {\n    this._waypointMarkers.forEach(marker => {\n      const el = marker.getElement();\n      if (el) {\n        el.style.display = ''; // Restore default display\n      }\n    });\n  }\n\n  /**\n     * Create a temporary WebGL layer for waypoints during video recording\n     * This layer will be captured in the video (unlike DOM markers)\n     */\n  async _createWaypointsWebGLLayer() {\n    if (!this._map || !this.options.waypoints || this.options.waypoints.features.length === 0) {\n      return;\n    }\n\n    // Ensure default icon is loaded (wait for it if needed)\n    await this._ensureDefaultWaypointIcon();\n\n    const sourceId = 've-waypoints-recording-source';\n    const layerId = 've-waypoints-recording-layer';\n\n    // Remove layer/source if they already exist\n    if (this._map.getLayer(layerId)) {\n      this._map.removeLayer(layerId);\n    }\n    if (this._map.getSource(sourceId)) {\n      this._map.removeSource(sourceId);\n    }\n\n    // Prepare GeoJSON with icon IDs\n    const geojsonWithIcons = {\n      type: 'FeatureCollection',\n      features: this.options.waypoints.features.map((feature, index) => {\n        const iconName = feature.properties.icon || 'waypoint-default';\n        let iconId = null;\n\n        // Handle built-in default icon (not a sprite)\n        if (iconName === 'waypoint-default') {\n          iconId = 'waypoint-default';\n        } else {\n          // Try to find matching icon in sprite data\n\n          // First try exact match\n          if (this._spriteIcons.includes(iconName)) {\n            iconId = iconName;\n          }\n          // If not found, use default icon\n          if (!iconId) {\n            iconId = 'waypoint-default';\n          }\n        }\n\n        console.log(`[Waypoints] WebGL Layer - Waypoint ${index}: icon=\"${iconName}\" ‚Üí iconId=\"${iconId}\"`);\n\n        // Clone feature and add resolved iconId\n        return {\n          ...feature,\n          properties: {\n            ...feature.properties,\n            iconId: iconId || 'marker' // Fallback\n          }\n        };\n      })\n    };\n\n    // Add source\n    this._map.addSource(sourceId, {\n      type: 'geojson',\n      data: geojsonWithIcons\n    });\n\n    // Add layer with sprite icons - at the TOP of all layers\n    // Note: We don't specify a 'beforeId' so it goes on top by default\n    this._map.addLayer({\n      id: layerId,\n      type: 'symbol',\n      source: sourceId,\n      layout: {\n        'icon-image': ['get', 'iconId'], // Use the resolved iconId\n        'icon-size': this._iconSize || 1,\n        'icon-allow-overlap': true,\n        'icon-ignore-placement': true, // Force rendering even if overlaps\n        'icon-anchor': 'bottom', // Match marker anchor\n        visibility: 'visible', // Explicitly set visibility\n        // Only show text if labels are enabled AND we have a font\n        ...(this._showWaypointLabels && this._selectedFont\n          ? {\n            'text-field': ['get', 'name'],\n            'text-font': [this._selectedFont], // Use detected font\n            'text-offset': [0, 0.5],\n            'text-anchor': 'top',\n            'text-size': 12,\n            'text-allow-overlap': true,\n            'text-ignore-placement': true\n          }\n          : {})\n      },\n      paint: {\n        'icon-opacity': 1,\n        'text-color': '#333',\n        'text-halo-color': '#fff',\n        'text-halo-width': 2\n      }\n    });\n\n    console.log(`[Waypoints] ‚úì Created WebGL layer with ${geojsonWithIcons.features.length} waypoints`);\n  }\n\n  /**\n     * Remove the temporary WebGL layer after recording\n     */\n  _removeWaypointsWebGLLayer() {\n    const sourceId = 've-waypoints-recording-source';\n    const layerId = 've-waypoints-recording-layer';\n\n    if (this._map.getLayer(layerId)) {\n      this._map.removeLayer(layerId);\n    }\n    if (this._map.getSource(sourceId)) {\n      this._map.removeSource(sourceId);\n    }\n  }\n\n  /**\n   * Validate waypoint coordinates against geographic constraints\n   * @param {number} lng - Longitude\n   * @param {number} lat - Latitude\n   * @returns {boolean} True if valid (within bounds or no bounds defined)\n   */\n  _validateWaypointCoordinates(lng, lat) {\n    if (!this.options.maxBounds) return true;\n\n    const [[west, south], [east, north]] = this.options.maxBounds;\n    return lng >= west && lng <= east && lat >= south && lat <= north;\n  }\n\n  _addWaypoint() {\n    if (!this._map) return;\n\n    // Get current map center\n    const center = this._map.getCenter();\n\n    // Validate against bounds if defined\n    if (!this._validateWaypointCoordinates(center.lng, center.lat)) {\n      const [[west, south], [east, north]] = this.options.maxBounds;\n      const confirmed = confirm(\n        '‚ö†Ô∏è Warning: This waypoint is OUTSIDE the defined geographic bounds!\\n\\n' +\n                  `Waypoint: [${center.lng.toFixed(4)}, ${center.lat.toFixed(4)}]\\n` +\n                  `Bounds: [${west.toFixed(2)}, ${south.toFixed(2)}] to [${east.toFixed(2)}, ${north.toFixed(2)}]\\n\\n` +\n                  'Animations may not visit this waypoint if strict bounds are enabled.\\n\\n' +\n                  'Add anyway?'\n      );\n\n      if (!confirmed) {\n        console.log('Waypoint addition cancelled - out of bounds');\n        return;\n      }\n    }\n\n    // Create GeoJSON Feature (without camera params - user can add them via toggle)\n    const feature = {\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: [center.lng, center.lat]\n      },\n      properties: {\n        name: `Waypoint ${(this.options.waypoints.features.length || 0) + 1}`,\n        icon: 'waypoint-default',\n        duration: 2000 // Default pause duration\n      }\n    };\n\n    this.options.waypoints.features.push(feature);\n    this._updateWaypointsUI();\n    this._saveWaypoints();\n\n    // Create/update markers on map (including popups)\n    this._createWaypointMarkers();\n\n    // Open popup for the newly added waypoint (last marker in array)\n    const lastMarker = this._waypointMarkers[this._waypointMarkers.length - 1];\n    if (lastMarker) {\n      lastMarker.togglePopup();\n    }\n\n    // Hide the entire control panel so user can see the new marker on the map\n    // User can click on the control button to reopen it\n    this._hidePanel();\n\n    console.log('Added waypoint:', feature);\n  }\n\n  _updateWaypointsUI() {\n    if (!this._panel) return;\n    const list = asHTMLElement(this._panel.querySelector('#ve-waypoints-list'));\n    const exportBtn = asButton(this._panel.querySelector('#ve-waypoint-export'));\n\n    if (!list || !exportBtn) return;\n\n    // Clear list\n    list.innerHTML = '';\n\n    const features = this.options.waypoints.features || [];\n\n    if (features.length === 0) {\n      list.innerHTML = `\n                <div style=\"text-align: center; color: #999; font-size: 12px; padding: 20px 0;\">\n                    No waypoints yet. Click \"Add draggable Icon\" to start.\n                </div>\n            `;\n      exportBtn.disabled = true;\n      return;\n    }\n\n    // Enable export button\n    exportBtn.disabled = false;\n\n    // Add waypoint items\n    features.forEach((feature, index) => {\n      const props = feature.properties;\n      const item = document.createElement('div');\n      item.className = 've-waypoint-item';\n      item.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 6px; background: white; border-radius: 3px; margin-bottom: 4px; cursor: pointer;';\n\n      // Icon preview\n      let iconHTML = '<span style=\"font-size: 18px;\">‚ùì</span>'; // Default unknown icon\n\n      // Handle default waypoint icon\n      if (props.icon === 'waypoint-default') {\n        iconHTML = `<div style=\"width: 20px; height: 20px; display: flex; align-items: center; justify-content: center;\">\n                    <svg width=\"12\" height=\"18\" viewBox=\"0 0 24 36\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <ellipse cx=\"12\" cy=\"34\" rx=\"4\" ry=\"2\" fill=\"rgba(0,0,0,0.3)\" />\n                        <path d=\"M12 2 C7 2 3 6 3 11 C3 16 12 26 12 26 C12 26 21 16 21 11 C21 6 17 2 12 2 Z\" fill=\"white\" />\n                        <path d=\"M12 4 C8 4 5 7 5 11 C5 15 12 24 12 24 C12 24 19 15 19 11 C19 7 16 4 12 4 Z\" fill=\"#3887be\" />\n                        <circle cx=\"12\" cy=\"11\" r=\"3\" fill=\"white\" opacity=\"0.9\" />\n                    </svg>\n                </div>`;\n      } else if (this._spriteData && this._spriteData[props.icon] && this._spritePngUrl) {\n        // Handle sprite icons\n        const iconData = this._spriteData[props.icon];\n        const pr = this._spritePixelRatio || 2; // Use stored pixelRatio (default @2x)\n        const displayWidth = iconData.width / pr;\n        const displayHeight = iconData.height / pr;\n        const bgPosX = iconData.x / pr;\n        const bgPosY = iconData.y / pr;\n        const bgWidth = this._spriteImage ? this._spriteImage.width / pr : 'auto';\n        const bgHeight = this._spriteImage ? this._spriteImage.height / pr : 'auto';\n\n        // Scale to fit 20px container while preserving aspect ratio\n        const scale = Math.min(20 / displayWidth, 20 / displayHeight);\n        const scaledWidth = displayWidth * scale;\n        const scaledHeight = displayHeight * scale;\n\n        iconHTML = `<div style=\"width: 20px; height: 20px; display: flex; align-items: center; justify-content: center;\">\n                    <div style=\"width: ${scaledWidth}px; height: ${scaledHeight}px; background-image: url(${this._spritePngUrl}); background-position: -${bgPosX}px -${bgPosY}px; background-size: ${bgWidth}px ${bgHeight}px; background-repeat: no-repeat;\"></div>\n                </div>`;\n      }\n\n      // Security: Use createElement + textContent to prevent XSS from waypoint names\n      // Create icon container\n      const iconContainer = document.createElement('div');\n      iconContainer.innerHTML = iconHTML; // iconHTML is safe (built from validated sprite data or static SVG)\n      item.appendChild(iconContainer);\n\n      // Create name span (safe - uses textContent)\n      const nameSpan = document.createElement('span');\n      nameSpan.className = 've-wp-name';\n      nameSpan.setAttribute('data-index', String(index));\n      nameSpan.style.cssText = 'flex: 1; font-size: 12px; font-weight: 500; cursor: pointer;';\n      nameSpan.textContent = props.name || `Waypoint ${index + 1}`; // textContent prevents XSS\n      item.appendChild(nameSpan);\n\n      // Create move up button\n      const moveUpBtn = document.createElement('button');\n      moveUpBtn.className = 've-wp-move-up';\n      moveUpBtn.setAttribute('data-index', String(index));\n      moveUpBtn.style.cssText = 'padding: 2px 6px; font-size: 11px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer;';\n      moveUpBtn.textContent = '‚Üë';\n      moveUpBtn.disabled = index === 0;\n      item.appendChild(moveUpBtn);\n\n      // Create move down button\n      const moveDownBtn = document.createElement('button');\n      moveDownBtn.className = 've-wp-move-down';\n      moveDownBtn.setAttribute('data-index', String(index));\n      moveDownBtn.style.cssText = 'padding: 2px 6px; font-size: 11px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer;';\n      moveDownBtn.textContent = '‚Üì';\n      moveDownBtn.disabled = index === features.length - 1;\n      item.appendChild(moveDownBtn);\n\n      // Create delete button\n      const deleteBtn = document.createElement('button');\n      deleteBtn.className = 've-wp-delete';\n      deleteBtn.setAttribute('data-index', String(index));\n      deleteBtn.style.cssText = 'padding: 2px 6px; font-size: 11px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;';\n      deleteBtn.textContent = 'üóëÔ∏è';\n      item.appendChild(deleteBtn);\n\n      list.appendChild(item);\n    });\n\n    list.querySelectorAll('.ve-wp-delete').forEach(btn => {\n      btn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        const index = parseInt(btn.getAttribute('data-index') || '0', 10);\n        this._deleteWaypoint(index);\n      });\n    });\n\n    // Move up button handlers\n    list.querySelectorAll('.ve-wp-move-up').forEach(btn => {\n      btn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        const index = parseInt(btn.getAttribute('data-index') || '0', 10);\n        if (index > 0) {\n          // Swap with previous item\n          const features = this.options.waypoints.features;\n          [features[index - 1], features[index]] = [features[index], features[index - 1]];\n\n          // Update UI and markers\n          this._updateWaypointsUI();\n          this._createWaypointMarkers();\n          this._saveWaypoints();\n\n          console.log(`[Waypoints] Moved waypoint from ${index} to ${index - 1}`);\n        }\n      });\n    });\n\n    // Move down button handlers\n    list.querySelectorAll('.ve-wp-move-down').forEach(btn => {\n      btn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        const index = parseInt(btn.getAttribute('data-index') || '0', 10);\n        const features = this.options.waypoints.features;\n        if (index < features.length - 1) {\n          // Swap with next item\n          [features[index], features[index + 1]] = [features[index + 1], features[index]];\n\n          // Update UI and markers\n          this._updateWaypointsUI();\n          this._createWaypointMarkers();\n          this._saveWaypoints();\n\n          console.log(`[Waypoints] Moved waypoint from ${index} to ${index + 1}`);\n        }\n      });\n    });\n\n    // Click on waypoint name to center and open popup\n    list.querySelectorAll('.ve-wp-name').forEach(nameSpan => {\n      nameSpan.addEventListener('click', (e) => {\n        e.stopPropagation();\n        const index = parseInt(nameSpan.getAttribute('data-index') || '0', 10);\n        const feature = this.options.waypoints.features[index];\n        if (!feature || !this._map) return;\n\n        const coords = feature.geometry.coordinates;\n\n        // Close the panel\n        if (this._panel && this._panel.style.display !== 'none') {\n          this._panel.style.display = 'none';\n        }\n\n        // Fly to the waypoint\n        this._map.flyTo({\n          center: coords,\n          zoom: Math.max(this._map.getZoom(), 14), // Zoom in at least to 14\n          duration: 1000,\n          essential: true\n        });\n\n        // Wait for the flyTo to complete, then open the popup\n        this._map.once('moveend', () => {\n          // Find the corresponding marker and open its popup\n          if (this._waypointMarkers && this._waypointMarkers[index]) {\n            const marker = this._waypointMarkers[index];\n            marker.togglePopup(); // Open the popup\n          }\n        });\n\n        console.log(`[Waypoints] Centered on waypoint ${index}`);\n      });\n    });\n\n    // Update waypoints layer on map\n    this._updateWaypointsLayer();\n  }\n\n  _editWaypoint(index) {\n    if (!this._panel) return;\n    const editor = this._panel.querySelector('#ve-waypoint-editor');\n    const features = this.options.waypoints.features;\n    if (!editor || !features || !features[index]) return;\n\n    const feature = features[index];\n    const props = feature.properties;\n    const coords = feature.geometry.coordinates;\n\n    // Show editor (editor already checked for null above)\n    /** @type {HTMLElement} */(editor).style.display = 'block';\n\n    // Check if waypoint has camera parameters\n    const hasCamera = props.zoom !== undefined || props.bearing !== undefined || props.pitch !== undefined;\n\n    // Fill form\n    const wpIndex = asInput(this._panel.querySelector('#ve-wp-index'));\n    const wpIcon = asSelect(this._panel.querySelector('#ve-wp-icon'));\n    const wpName = asInput(this._panel.querySelector('#ve-wp-name'));\n    const wpLng = asInput(this._panel.querySelector('#ve-wp-lng'));\n    const wpLat = asInput(this._panel.querySelector('#ve-wp-lat'));\n    const wpDuration = asInput(this._panel.querySelector('#ve-wp-duration'));\n\n    if (wpIndex) wpIndex.value = index;\n    if (wpIcon) wpIcon.value = props.icon || 'waypoint-default';\n    if (wpName) wpName.value = props.name || '';\n    if (wpLng) wpLng.value = coords[0];\n    if (wpLat) wpLat.value = coords[1];\n    if (wpDuration) wpDuration.value = props.duration || '';\n\n    // Set camera toggle and fields\n    const cameraToggle = asInput(this._panel.querySelector('#ve-wp-camera-toggle'));\n    const zoomInput = asInput(this._panel.querySelector('#ve-wp-zoom'));\n    const bearingInput = asInput(this._panel.querySelector('#ve-wp-bearing'));\n    const pitchInput = asInput(this._panel.querySelector('#ve-wp-pitch'));\n\n    if (hasCamera) {\n      // Waypoint has camera params ‚Üí enable and fill\n      if (cameraToggle) cameraToggle.checked = true;\n      if (zoomInput) zoomInput.disabled = false;\n      if (bearingInput) bearingInput.disabled = false;\n      if (pitchInput) pitchInput.disabled = false;\n      if (zoomInput) zoomInput.value = props.zoom !== undefined ? props.zoom : '';\n      if (bearingInput) bearingInput.value = props.bearing !== undefined ? props.bearing : '';\n      if (pitchInput) pitchInput.value = props.pitch !== undefined ? props.pitch : '';\n    } else {\n      // No camera params ‚Üí disable and clear\n      if (cameraToggle) cameraToggle.checked = false;\n      if (zoomInput) zoomInput.disabled = true;\n      if (bearingInput) bearingInput.disabled = true;\n      if (pitchInput) pitchInput.disabled = true;\n      if (zoomInput) zoomInput.value = '';\n      if (bearingInput) bearingInput.value = '';\n      if (pitchInput) pitchInput.value = '';\n    }\n\n    // Update icon preview\n    this._updateIconPreview();\n  }\n\n  _saveWaypoint() {\n    if (!this._panel) return;\n    const editor = this._panel.querySelector('#ve-waypoint-editor');\n    const index = parseInt(asInput(this._panel.querySelector('#ve-wp-index'))?.value || '0', 10);\n\n    const features = this.options.waypoints.features;\n    if (!features || !features[index]) return;\n\n    // Get values\n    const icon = asSelect(this._panel.querySelector('#ve-wp-icon'))?.value || '';\n    const name = asInput(this._panel.querySelector('#ve-wp-name'))?.value;\n    const lng = parseFloat(asInput(this._panel.querySelector('#ve-wp-lng'))?.value || '0');\n    const lat = parseFloat(asInput(this._panel.querySelector('#ve-wp-lat'))?.value || '0');\n    const zoom = asInput(this._panel.querySelector('#ve-wp-zoom'))?.value;\n    const bearing = asInput(this._panel.querySelector('#ve-wp-bearing'))?.value;\n    const pitch = asInput(this._panel.querySelector('#ve-wp-pitch'))?.value;\n    const duration = asInput(this._panel.querySelector('#ve-wp-duration'))?.value;\n\n    // Validate coordinates against bounds if defined\n    if (!this._validateWaypointCoordinates(lng, lat)) {\n      const [[west, south], [east, north]] = this.options.maxBounds;\n      const waypointName = name || `Waypoint ${index + 1}`;\n      const confirmed = confirm(\n        '‚ö†Ô∏è Warning: These coordinates are OUTSIDE the defined geographic bounds!\\n\\n' +\n                `Waypoint: ${waypointName}\\n` +\n                `Coordinates: [${lng.toFixed(4)}, ${lat.toFixed(4)}]\\n` +\n                `Bounds: [${west.toFixed(2)}, ${south.toFixed(2)}] to [${east.toFixed(2)}, ${north.toFixed(2)}]\\n\\n` +\n                'Animations may not visit this waypoint if strict bounds are enabled.\\n\\n' +\n                'Save anyway?'\n      );\n\n      if (!confirmed) {\n        console.log('Waypoint save cancelled - coordinates out of bounds');\n        return;\n      }\n    }\n\n    // Update feature\n    features[index] = {\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: [lng, lat]\n      },\n      properties: {\n        icon,\n        name: name || `Waypoint ${index + 1}`,\n        ...(zoom !== '' && { zoom: parseFloat(zoom || '0') }),\n        ...(bearing !== '' && { bearing: parseFloat(bearing || '0') }),\n        ...(pitch !== '' && { pitch: parseFloat(pitch || '0') }),\n        ...(duration !== '' && { duration: parseInt(duration || '0', 10) })\n      }\n    };\n\n    // Hide editor\n    if (editor) /** @type {HTMLElement} */(editor).style.display = 'none';\n\n    // Update UI\n    this._updateWaypointsUI();\n\n    // Recreate markers (to reflect changes in position, icon, etc.)\n    this._createWaypointMarkers();\n\n    console.log('Waypoint saved:', features[index]);\n  }\n\n  _cancelWaypointEdit() {\n    if (!this._panel) return;\n    const editor = asHTMLElement(this._panel.querySelector('#ve-waypoint-editor'));\n    if (editor) {\n      editor.style.display = 'none';\n    }\n  }\n\n  _deleteWaypoint(index) {\n    if (!this._panel) return;\n    const features = this.options.waypoints.features;\n    if (!features) return;\n\n    const name = features[index].properties.name || `Waypoint ${index + 1}`;\n    if (confirm(`Delete waypoint \"${name}\"?`)) {\n      features.splice(index, 1);\n      this._updateWaypointsUI();\n      this._saveWaypoints();\n\n      // Hide editor if it was editing this waypoint\n      const editor = asHTMLElement(this._panel.querySelector('#ve-waypoint-editor'));\n      const editingIndex = parseInt(asInput(this._panel.querySelector('#ve-wp-index'))?.value || '-1', 10);\n      if (editingIndex === index && editor) {\n        editor.style.display = 'none';\n      }\n\n      console.log('Waypoint deleted, remaining:', features.length);\n    }\n  }\n\n  _importWaypoints() {\n    const input = document.createElement('input');\n    input.type = 'file';\n    input.accept = '.json,.geojson';\n\n    input.onchange = (e) => {\n      const file = asInput(e.target)?.files?.[0];\n      if (!file) return;\n\n      // Security: Validate file size (max 5MB)\n      const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB in bytes\n      if (file.size > MAX_FILE_SIZE) {\n        alert(\n          `File too large: ${(file.size / 1024 / 1024).toFixed(2)} MB\\n\\n` +\n          `Maximum allowed: ${MAX_FILE_SIZE / 1024 / 1024} MB\\n\\n` +\n          'Please use a smaller waypoints file.'\n        );\n        return;\n      }\n\n      // Security: Validate MIME type (JSON or GeoJSON)\n      const validMimeTypes = ['application/json', 'application/geo+json', 'text/plain', ''];\n      if (!validMimeTypes.includes(file.type)) {\n        alert(\n          `Invalid file type: ${file.type || 'unknown'}\\n\\n` +\n          'Please upload a .json or .geojson file.'\n        );\n        return;\n      }\n\n      const reader = new FileReader();\n\n      // Security: Add error handler for FileReader operations\n      reader.onerror = () => {\n        console.error('FileReader error:', reader.error);\n        alert(\n          `Error reading file: ${reader.error?.message || 'Unknown error'}\\n\\n` +\n          'Please try again or use a different file.'\n        );\n      };\n\n      reader.onload = (event) => {\n        try {\n          if (!event.target) return;\n          const geojson = JSON.parse(/** @type {string} */(event.target.result));\n\n          // Validate GeoJSON structure\n          if (geojson.type !== 'FeatureCollection') {\n            throw new Error('Invalid format: expected GeoJSON FeatureCollection');\n          }\n\n          if (!Array.isArray(geojson.features)) {\n            throw new Error('Invalid format: features must be an array');\n          }\n\n          // Validate each feature\n          const outOfBoundsWaypoints = [];\n          geojson.features.forEach((feature, idx) => {\n            if (feature.type !== 'Feature') {\n              throw new Error(`Feature ${idx}: invalid type`);\n            }\n            if (feature.geometry.type !== 'Point') {\n              throw new Error(`Feature ${idx}: only Point geometry supported`);\n            }\n            if (!Array.isArray(feature.geometry.coordinates) || feature.geometry.coordinates.length !== 2) {\n              throw new Error(`Feature ${idx}: invalid coordinates`);\n            }\n\n            // Check geographic constraints\n            const [lng, lat] = feature.geometry.coordinates;\n            if (!this._validateWaypointCoordinates(lng, lat)) {\n              outOfBoundsWaypoints.push({\n                idx,\n                name: feature.properties?.name || `Waypoint ${idx + 1}`,\n                coords: [lng.toFixed(4), lat.toFixed(4)]\n              });\n            }\n          });\n\n          // Warn about out-of-bounds waypoints\n          if (outOfBoundsWaypoints.length > 0 && this.options.maxBounds) {\n            const [[west, south], [east, north]] = this.options.maxBounds;\n            const waypointList = outOfBoundsWaypoints.map(wp =>\n              `  ‚Ä¢ ${wp.name}: [${wp.coords[0]}, ${wp.coords[1]}]`\n            ).join('\\n');\n\n            const confirmed = confirm(\n              `‚ö†Ô∏è Warning: ${outOfBoundsWaypoints.length} waypoint(s) are OUTSIDE the defined geographic bounds!\\n\\n` +\n              `${waypointList}\\n\\n` +\n              `Bounds: [${west.toFixed(2)}, ${south.toFixed(2)}] to [${east.toFixed(2)}, ${north.toFixed(2)}]\\n\\n` +\n              'Animations may not visit these waypoints if strict bounds are enabled.\\n\\n' +\n              'Import anyway?'\n            );\n\n            if (!confirmed) {\n              console.log('Import cancelled - waypoints out of bounds');\n              return;\n            }\n          }\n\n          this.options.waypoints = geojson;\n          this._updateWaypointsUI();\n\n          // Create markers on map\n          this._createWaypointMarkers();\n\n          // Save to localStorage\n          this._saveWaypoints();\n\n          console.log(`Imported ${geojson.features.length} waypoints`);\n          alert(`Successfully imported ${geojson.features.length} waypoints!`);\n        } catch (error) {\n          console.error('Import error:', error);\n          alert(`Error importing waypoints: ${error.message}`);\n        }\n      };\n\n      reader.readAsText(file);\n    };\n\n    input.click();\n  }\n\n  _exportWaypoints() {\n    if (!this.options.waypoints || this.options.waypoints.features.length === 0) {\n      alert('No waypoints to export');\n      return;\n    }\n\n    // Export as GeoJSON\n    const geojson = JSON.stringify(this.options.waypoints, null, 2);\n    const blob = new Blob([geojson], { type: 'application/geo+json' });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `waypoints-${Date.now()}.geojson`;\n    a.click();\n\n    URL.revokeObjectURL(url);\n\n    console.log(`Exported ${this.options.waypoints.features.length} waypoints as GeoJSON`);\n  }\n\n  _togglePanel() {\n    if (!this._panel || !this._overlay) return;\n\n    const isVisible = this._panel.getAttribute('data-visible') === 'true';\n\n    if (isVisible) {\n      // Start hide animation\n      this._panel.setAttribute('data-visible', 'false');\n      this._overlay.setAttribute('data-visible', 'false');\n\n      // Remove from DOM after animation completes\n      setTimeout(() => {\n        if (this._panel && this._overlay) {\n          this._panel.style.display = 'none';\n          this._overlay.style.display = 'none';\n        }\n      }, 250); // Match CSS transition duration\n    } else {\n      // Show overlay and panel\n      this._overlay.style.display = 'block';\n      this._panel.style.display = 'block';\n\n      // Trigger animation after DOM update\n      requestAnimationFrame(() => {\n        if (this._panel && this._overlay) {\n          this._panel.setAttribute('data-visible', 'true');\n          this._overlay.setAttribute('data-visible', 'true');\n        }\n      });\n    }\n  }\n\n  _hidePanel() {\n    if (!this._panel || !this._overlay) return;\n\n    // Start hide animation\n    this._panel.setAttribute('data-visible', 'false');\n    this._overlay.setAttribute('data-visible', 'false');\n\n    // Remove from DOM after animation completes\n    setTimeout(() => {\n      if (this._panel && this._overlay) {\n        this._panel.style.display = 'none';\n        this._overlay.style.display = 'none';\n      }\n    }, 250); // Match CSS transition duration\n  }\n\n  _adjustPanelPosition() {\n    if (!this._panel || !this._map) return;\n\n    // Detect attribution control at bottom (takes full width)\n    const mapContainer = this._map.getContainer();\n    const attributionControl = mapContainer.querySelector('.maplibregl-ctrl-attrib');\n\n    // Calculate available space\n    const viewportHeight = window.innerHeight;\n    let bottomOffset = 0;\n\n    // Check attribution control height\n    if (attributionControl) {\n      const attrHeight = attributionControl.offsetHeight;\n      bottomOffset += attrHeight + 10; // Add some padding\n    }\n\n    // Panel is at top (20px), so we just need to account for bottom space\n    // Use a minimum of 400px to ensure panel is usable\n    const availableHeight = Math.max(400, viewportHeight - 20 - bottomOffset - 40); // 20px top + 40px margin\n    this._panel.style.maxHeight = `${availableHeight}px`;\n\n    console.log(`[VideoExport] Panel adjusted - available space: ${availableHeight}px, bottom offset: ${bottomOffset}px`);\n  }\n\n  _updateStatus(message, className = '') {\n    if (!this._panel) return;\n    const status = this._panel.querySelector('#ve-status');\n    if (!status) return;\n    status.textContent = message;\n    status.className = 'status ' + className;\n  }\n\n  _estimateFileSize(bitrate, durationMs, format) {\n    // Calculate base size in MB\n    // bitrate is in kbps, duration in ms\n    // bitrate * (duration/1000) / 8 = size in KB\n    // Then divide by 1024 to get MB\n    const baseSizeMB = (bitrate * (durationMs / 1000)) / 8 / 1024;\n\n    // Use real recording parameters if available (more accurate), otherwise fall back to options\n    const width = this._recordingParams?.width || this.options.width || 1920;\n    const height = this._recordingParams?.height || this.options.height || 1080;\n    const fps = this._recordingParams?.fps || this.options.fps || 30;\n    const isHighQuality = (width >= 2560 || height >= 1440) && fps >= 60;\n\n    // Compression factors depend on resolution and framerate\n    // High quality video (4K 60fps) compresses less efficiently\n    if (format === 'webm-vp9') {\n      // VP9 compression varies significantly with quality\n      // High quality: less compression (container overhead dominates)\n      // Low quality: better compression\n      const compressionFactor = isHighQuality ? 1.1 : 0.75;\n      return baseSizeMB * compressionFactor;\n    } else if (format === 'webm-vp8' || format === 'webm') {\n      const compressionFactor = isHighQuality ? 1.15 : 0.80;\n      return baseSizeMB * compressionFactor;\n    }\n\n    // MP4 H.264: baseline (most predictable)\n    return baseSizeMB;\n  }\n\n  _formatSize(mb) {\n    if (mb < 1) {\n      return `${(mb * 1024).toFixed(0)} KB`;\n    } else if (mb < 100) {\n      return `${mb.toFixed(1)} MB`;\n    } else {\n      return `${mb.toFixed(0)} MB`;\n    }\n  }\n\n  _updateProgress(frameCount, totalFrames, bitrate, durationMs, status = 'Recording') {\n    // Use the widget in ctrl-group instead of panel progress\n    const statusSpan = this._progressWidget?.querySelector('#ve-progress-status');\n    const percentSpan = this._progressWidget?.querySelector('#ve-progress-percent');\n    const framesSpan = this._progressWidget?.querySelector('#ve-progress-frames');\n    const sizeSpan = this._progressWidget?.querySelector('#ve-progress-size');\n    const timeSpan = this._progressWidget?.querySelector('#ve-progress-time');\n\n    if (totalFrames > 0 && this._progressWidget) {\n      this._progressWidget.style.display = '';\n\n      // Initialize start time on first frame\n      if (frameCount === 0 || !this._recordingStartTime) {\n        this._recordingStartTime = Date.now();\n      }\n\n      // Update status\n      if (statusSpan) statusSpan.textContent = status;\n\n      // Calculate percentage\n      const percent = Math.round((frameCount / totalFrames) * 100);\n      if (percentSpan) percentSpan.textContent = `${percent}% complete`;\n\n      // Update frame count\n      if (framesSpan) {\n        framesSpan.textContent = `Frame ${frameCount.toLocaleString()} of ${totalFrames.toLocaleString()}`;\n      }\n\n      // Estimate final size\n      const estimatedMB = this._estimateFileSize(bitrate, durationMs, this.options.format);\n      if (sizeSpan) sizeSpan.textContent = `Size: ~${this._formatSize(estimatedMB)}`;\n\n      // Calculate and display time remaining\n      if (frameCount > 0 && timeSpan) {\n        const elapsedMs = Date.now() - this._recordingStartTime;\n        const msPerFrame = elapsedMs / frameCount;\n        const remainingFrames = totalFrames - frameCount;\n        const estimatedRemainingMs = msPerFrame * remainingFrames;\n\n        // Format time remaining\n        const seconds = Math.ceil(estimatedRemainingMs / 1000);\n        if (seconds < 60) {\n          timeSpan.textContent = `${seconds} second${seconds !== 1 ? 's' : ''} left`;\n        } else if (seconds < 3600) {\n          const minutes = Math.floor(seconds / 60);\n          const secs = seconds % 60;\n          if (secs === 0) {\n            timeSpan.textContent = `${minutes} minute${minutes !== 1 ? 's' : ''} left`;\n          } else {\n            timeSpan.textContent = `${minutes}m ${secs}s left`;\n          }\n        } else {\n          const hours = Math.floor(seconds / 3600);\n          const mins = Math.floor((seconds % 3600) / 60);\n          timeSpan.textContent = `${hours}h ${mins}m left`;\n        }\n      } else if (timeSpan) {\n        timeSpan.textContent = 'calculating time...';\n      }\n    }\n  }\n\n  _hideProgress() {\n    if (this._progressWidget) {\n      this._progressWidget.style.display = 'none';\n    }\n    // Reset timing for next recording\n    this._recordingStartTime = null;\n  }\n\n  _showFinalStats(stats) {\n    if (!this._progressWidget) return;\n\n    // Hide progress sections\n    const statusDiv = this._progressWidget.querySelector('.progress-status')?.parentElement;\n    const percentDiv = this._progressWidget.querySelector('.progress-percent')?.parentElement;\n    const sizeDiv = this._progressWidget.querySelector('.progress-secondary')?.parentElement;\n\n    if (statusDiv) statusDiv.style.display = 'none';\n    if (percentDiv) percentDiv.style.display = 'none';\n    if (sizeDiv) sizeDiv.style.display = 'none';\n\n    // Show summary section\n    const summaryDiv = asHTMLElement(this._progressWidget.querySelector('#ve-progress-summary'));\n    if (summaryDiv) {\n      summaryDiv.style.display = 'block';\n\n      // Fill in the stats\n      const videoSpan = asHTMLElement(this._progressWidget.querySelector('#ve-summary-video'));\n      const realtimeSpan = asHTMLElement(this._progressWidget.querySelector('#ve-summary-realtime'));\n      const speedSpan = asHTMLElement(this._progressWidget.querySelector('#ve-summary-speed'));\n      const sizeSpan = asHTMLElement(this._progressWidget.querySelector('#ve-summary-size'));\n\n      if (videoSpan) {\n        videoSpan.textContent = `${stats.videoDuration}s (${stats.frameCount} frames @ ${stats.fps} fps)`;\n      }\n      if (realtimeSpan) {\n        realtimeSpan.textContent = `${stats.realTime}s`;\n      }\n      if (speedSpan) {\n        const faster = parseFloat(stats.speedRatio) > 1;\n        speedSpan.textContent = `${stats.speedRatio}x (${faster ? 'faster' : 'slower'} than realtime)`;\n        speedSpan.style.color = faster ? '#4CAF50' : '#FF9800'; // Green if faster, orange if slower\n      }\n      if (sizeSpan) {\n        sizeSpan.textContent = `${stats.sizeMB} MB`;\n      }\n    }\n\n    // Keep widget visible\n    this._progressWidget.style.display = 'block';\n\n    console.log('[UI] Final stats displayed in widget');\n  }\n\n  _collapseInterface() {\n    if (!this._panel) return;\n\n    // Move panel to configured position (compact mode)\n    const compactClass = `compact-${this.options.compactPosition}`;\n    this._panel.classList.add(compactClass);\n\n    // Reset widget to show progress (hide summary from previous export)\n    if (this._progressWidget) {\n      // Show progress sections\n      const statusEl = this._progressWidget.querySelector('.progress-status');\n      const percentEl = this._progressWidget.querySelector('.progress-percent');\n      const sizeEl = this._progressWidget.querySelector('.progress-secondary');\n      const statusDiv = statusEl ? asHTMLElement(statusEl.parentElement) : null;\n      const percentDiv = percentEl ? asHTMLElement(percentEl.parentElement) : null;\n      const sizeDiv = sizeEl ? asHTMLElement(sizeEl.parentElement) : null;\n      if (statusDiv) statusDiv.style.display = '';\n      if (percentDiv) percentDiv.style.display = '';\n      if (sizeDiv) sizeDiv.style.display = '';\n\n      // Hide summary section\n      const summaryDiv = asHTMLElement(this._progressWidget.querySelector('#ve-progress-summary'));\n      if (summaryDiv) summaryDiv.style.display = 'none';\n\n      // Show widget\n      this._progressWidget.style.display = 'block';\n    }\n\n    // Hide all form groups during test/recording\n    const formGroups = this._panel.querySelectorAll('.form-group');\n    formGroups.forEach(group => {\n      /** @type {HTMLElement} */(group).style.display = 'none';\n    });\n\n    // Hide section headers (h3) and dividers (hr)\n    const headers = this._panel.querySelectorAll('h3, hr');\n    headers.forEach(element => {\n      /** @type {HTMLElement} */(element).style.display = 'none';\n    });\n\n    // Hide collapsible sections\n    const constraintsGroup = asHTMLElement(this._panel.querySelector('#ve-constraints-group'));\n    const waypointsGroup = asHTMLElement(this._panel.querySelector('#ve-waypoints-group'));\n    if (constraintsGroup) constraintsGroup.style.display = 'none';\n    if (waypointsGroup) waypointsGroup.style.display = 'none';\n\n    // Hide section contents\n    const sectionContents = this._panel.querySelectorAll('[data-section-content]');\n    sectionContents.forEach(content => {\n      /** @type {HTMLElement} */(content).style.display = 'none';\n    });\n\n    // Hide reset button div\n    const resetDiv = asHTMLElement(this._panel.querySelector('#ve-reset-message'));\n    if (resetDiv) resetDiv.style.display = 'none';\n\n    // Hide exploration limit checkbox\n    const explorationLimit = asHTMLElement(this._panel.querySelector('#ve-exploration-limit'));\n    if (explorationLimit) {\n      const explorationDiv = asHTMLElement(explorationLimit.closest('.form-group'));\n      if (explorationDiv) explorationDiv.style.display = 'none';\n    }\n\n    // Hide recording time display\n    const recordingTime = asHTMLElement(this._panel.querySelector('.recording-time-display'));\n    if (recordingTime) recordingTime.style.display = 'none';\n\n    console.log(`[UI] Interface collapsed and moved to ${this.options.compactPosition} corner`);\n  }\n\n  _expandInterface() {\n    if (!this._panel) return;\n    // Return panel to center (remove compact mode)\n    const compactClass = `compact-${this.options.compactPosition}`;\n    this._panel.classList.remove(compactClass);\n\n    // Hide progress widget when expanded\n    if (this._progressWidget) {\n      this._progressWidget.style.display = 'none';\n    }\n\n    // Show all form groups after test/recording (except conditional ones)\n    const formGroups = this._panel.querySelectorAll('.form-group');\n    formGroups.forEach(group => {\n      // Don't auto-show conditional groups, they'll be handled below\n      const el = asHTMLElement(group);\n      if (!el) return;\n      const isConditional = el.id === 've-resolution-custom-group' ||\n                                  el.id === 've-speed-custom-group' ||\n                                  el.id === 've-bitrate-custom-group';\n      if (!isConditional) {\n        el.style.display = '';\n      }\n    });\n\n    // Show section headers (h3) and dividers (hr)\n    const headers = this._panel.querySelectorAll('h3, hr');\n    headers.forEach(element => {\n      /** @type {HTMLElement} */(element).style.display = '';\n    });\n\n    // Show collapsible section groups (they were hidden during test/recording)\n    const constraintsGroup = asHTMLElement(this._panel.querySelector('#ve-constraints-group'));\n    const waypointsGroup = asHTMLElement(this._panel.querySelector('#ve-waypoints-group'));\n    if (constraintsGroup) constraintsGroup.style.display = '';\n    if (waypointsGroup) waypointsGroup.style.display = '';\n\n    // Restore format advanced group\n    const formatAdvancedToggle = asInput(this._panel.querySelector('#ve-format-advanced-toggle'));\n    const formatAdvancedGroup = asHTMLElement(this._panel.querySelector('#ve-format-advanced-group'));\n    if (formatAdvancedToggle && formatAdvancedGroup) {\n      formatAdvancedGroup.style.display = formatAdvancedToggle.checked ? '' : 'none';\n\n      // Restore mp4/webm specific advanced options\n      if (formatAdvancedToggle.checked) {\n        const mp4Advanced = asHTMLElement(this._panel.querySelector('#ve-mp4-advanced'));\n        const vp8Advanced = asHTMLElement(this._panel.querySelector('#ve-webm-vp8-advanced'));\n        const vp9Advanced = asHTMLElement(this._panel.querySelector('#ve-webm-vp9-advanced'));\n\n        if (mp4Advanced && vp8Advanced && vp9Advanced) {\n          mp4Advanced.style.display = 'none';\n          vp8Advanced.style.display = 'none';\n          vp9Advanced.style.display = 'none';\n\n          if (this.options.format === 'mp4') {\n            mp4Advanced.style.display = '';\n          } else if (this.options.format === 'webm-vp8') {\n            vp8Advanced.style.display = '';\n          } else if (this.options.format === 'webm-vp9') {\n            vp9Advanced.style.display = '';\n          }\n        }\n      }\n    }\n\n    // Restore custom resolution group\n    const resolutionSelect = asSelect(this._panel.querySelector('#ve-resolution'));\n    const customResGroup = asHTMLElement(this._panel.querySelector('#ve-resolution-custom-group'));\n    if (resolutionSelect && customResGroup) {\n      customResGroup.style.display = resolutionSelect.value === 'custom' ? '' : 'none';\n    }\n\n    // Restore custom speed group\n    const speedSelect = asSelect(this._panel.querySelector('#ve-speed'));\n    const customSpeedGroup = asHTMLElement(this._panel.querySelector('#ve-speed-custom-group'));\n    if (speedSelect && customSpeedGroup) {\n      customSpeedGroup.style.display = speedSelect.value === 'custom' ? '' : 'none';\n    }\n\n    // Restore custom bitrate group\n    const bitrateSelect = asSelect(this._panel.querySelector('#ve-bitrate'));\n    const bitrateCustomGroup = asHTMLElement(this._panel.querySelector('#ve-bitrate-custom-group'));\n    if (bitrateSelect && bitrateCustomGroup) {\n      bitrateCustomGroup.style.display = bitrateSelect.value === 'custom' ? '' : 'none';\n    }\n\n    // Restore section contents based on their collapsed state\n    const sections = this._panel.querySelectorAll('[data-section-toggle]');\n    sections.forEach(toggle => {\n      const toggleBtn = asHTMLElement(toggle);\n      if (!toggleBtn) return;\n      const sectionId = toggleBtn.getAttribute('data-section-toggle');\n      if (!sectionId) return;\n      const sectionContent = asHTMLElement(this._panel.querySelector(`[data-section-content=\"${sectionId}\"]`));\n      if (sectionContent) {\n        const isCollapsed = toggleBtn.getAttribute('data-collapsed') === 'true';\n        sectionContent.style.display = isCollapsed ? 'none' : '';\n      }\n    });\n\n    // Show recording time display\n    const recordingTime = asHTMLElement(this._panel.querySelector('.recording-time-display'));\n    if (recordingTime) recordingTime.style.display = '';\n\n    // Clear saved state - back to normal operation\n    this._savedWaypointsVisibility = undefined;\n\n    console.log('[UI] Interface expanded after recording');\n  }\n\n  async _preloadEncoder() {\n    if (this._encoderLoaded) return;\n\n    try {\n      // Try local files first, fallback to CDN\n      const sources = await this._detectEncoderSources();\n      const { encoderUrl, simdUrl } = sources.mp4;\n\n      console.log('Loading MP4 encoder from:', encoderUrl);\n\n      // Load mp4-encoder module\n      const encoderModule = await import(encoderUrl);\n      this._loadEncoder = encoderModule.default;\n\n      // Load SIMD detection\n      const simdModule = await import(simdUrl);\n      this._simd = simdModule.simd;\n\n      this._encoderLoaded = true;\n      console.log('‚úÖ Video encoder loaded from', encoderUrl.includes('unpkg') ? 'CDN' : 'local files');\n    } catch (error) {\n      console.warn('Failed to preload encoder:', error);\n      // Will try again when actually needed\n    }\n  }\n\n  /**\n     * Load encoder based on selected format\n     * @returns {Promise<Object>} Encoder instance with unified API\n     */\n  async _loadEncoderForFormat(width, height, fps, bitrate) {\n    console.log(`üîß Loading encoder for format: ${this.options.format}`);\n    const sources = await this._detectEncoderSources();\n\n    // Normalize format (backward compatibility: 'webm' ‚Üí 'webm-vp8')\n    let format = this.options.format;\n    if (format === 'webm') {\n      format = 'webm-vp8';\n      console.log('üìù Format normalized: webm ‚Üí webm-vp8 (backward compatibility)');\n    }\n\n    if (format === 'mp4') {\n      console.log('üì¶ Using MP4 encoder');\n      return this._loadMp4Encoder(sources.mp4, width, height, fps, bitrate);\n    } else if (format === 'webm-vp8') {\n      console.log('üì¶ Using WebM VP8 encoder (webm-wasm realtime)');\n      return this._loadWebmEncoder(sources.webm, width, height, fps, bitrate);\n    } else if (format === 'webm-vp9') {\n      console.log('üì¶ Using WebM VP9 encoder (WebCodecs)');\n      return this._loadWebCodecsVP9Encoder(width, height, fps, bitrate);\n    } else {\n      throw new Error(`Unknown format: ${format} (expected: 'webm-vp8', 'webm-vp9', or 'mp4')`);\n    }\n  }\n\n  /**\n     * Load MP4 encoder\n     */\n  async _loadMp4Encoder(sources, width, height, fps, bitrate) {\n    const { encoderUrl, simdUrl } = sources;\n\n    console.log(`[MP4 Encoder] Loading from: ${encoderUrl}`);\n\n    // Load encoder module if not already loaded\n    if (!this._loadEncoder) {\n      const encoderModule = await import(encoderUrl);\n      this._loadEncoder = encoderModule.default;\n    }\n\n    // Load SIMD detection if not already loaded\n    if (!this._simd) {\n      const simdModule = await import(simdUrl);\n      this._simd = simdModule.simd;\n    }\n\n    // Detect SIMD support\n    const simd = await this._simd();\n    console.log(`[MP4 Encoder] SIMD support: ${simd}`);\n\n    // Get advanced parameters if enabled\n    if (!this._panel) return null;\n    const speedEl = asInput(this._panel.querySelector('#ve-mp4-speed'));\n    const qpEl = asInput(this._panel.querySelector('#ve-mp4-qp'));\n    const gopEl = asInput(this._panel.querySelector('#ve-mp4-gop'));\n\n    let speed = 10; // default\n    let qpMin = 10; let qpMax = 42; // defaults\n    let gop = 30; // default\n\n    if (speedEl) speed = parseInt(speedEl.value, 10);\n    if (qpEl) {\n      const [min, max] = qpEl.value.split(',').map(v => parseInt(v, 10));\n      qpMin = min;\n      qpMax = max;\n    }\n    if (gopEl) gop = parseInt(gopEl.value, 10);\n\n    console.log(`[MP4 Encoder] Advanced params - Speed: ${speed}, QP: ${qpMin}-${qpMax}, GOP: ${gop}`);\n\n    // Create encoder directly (no cache)\n    console.log('[MP4 Encoder] Creating new MP4 encoder');\n    const encoderFactory = await this._loadEncoder({ simd });\n    const encoder = encoderFactory.create({\n      width,\n      height,\n      fps,\n      speed,\n      kbps: bitrate,\n      rgbFlipY: true,\n      quantizationParameter: qpMax,\n      groupOfPictures: gop\n    });\n\n    console.log(`[MP4 Encoder] Got encoder (${width}x${height}, ${fps}fps, ${bitrate}kbps)`);\n    return encoder;\n  }\n\n  /**\n     * Load WebM encoder (requires local files)\n     */\n  async _loadWebmEncoder(sources, width, height, fps, bitrate) {\n    // Check if WebM files were found\n    if (sources.error) {\n      throw new Error(sources.error);\n    }\n\n    const { workerUrl, wasmUrl } = sources;\n\n    if (!workerUrl || !wasmUrl) {\n      throw new Error(\n        'WebM encoder files not found. ' +\n                'Please deploy the vendor/webm/ directory alongside the plugin. ' +\n                'See vendor/README.md for deployment instructions.'\n      );\n    }\n\n    console.log(`[WebM Encoder] Loading from: ${workerUrl}`);\n\n    // Get advanced VP8 parameters if available\n    if (!this._panel) return null;\n    const vp8BitrateEl = asInput(this._panel.querySelector('#ve-vp8-bitrate-custom'));\n    const customBitrate = vp8BitrateEl && vp8BitrateEl.value ? parseInt(vp8BitrateEl.value, 10) : null;\n\n    // Use custom bitrate if specified, otherwise use auto-calculated\n    const finalBitrate = customBitrate || bitrate;\n\n    console.log(`[WebM Encoder] Bitrate: ${finalBitrate} kbps ${customBitrate ? '(custom)' : '(auto)'}`);\n\n    // IMPORTANT: realtime mode is ALWAYS true due to webm-wasm limitation\n    // Non-realtime mode blocks the worker thread and cannot receive frames\n    const realtime = true;\n\n    // Create encoder directly (no cache)\n    console.log('[WebM Encoder] Creating new WebM encoder');\n    const wrapper = new WebmEncoderWrapper();\n    await wrapper.create({\n      width,\n      height,\n      fps,\n      bitrate: finalBitrate,\n      wasmUrl,\n      workerUrl,\n      realtime\n    });\n\n    console.log(`[WebM Encoder] Got encoder (${width}x${height}, ${fps}fps, ${finalBitrate}kbps)`);\n    return wrapper;\n  }\n\n  /**\n     * Load WebCodecs VP9 encoder (Modern browsers only)\n     */\n  async _loadWebCodecsVP9Encoder(width, height, fps, bitrate) {\n    // Import WebCodecsVP9Encoder dynamically\n    if (!this._WebCodecsVP9Encoder) {\n      const module = await import('./webcodecs-vp9-encoder.js');\n      this._WebCodecsVP9Encoder = module.WebCodecsVP9Encoder;\n    }\n\n    // Check support\n    if (!this._WebCodecsVP9Encoder.isSupported()) {\n      throw new Error(\n        'WebCodecs API not supported in this browser. ' +\n                'Use a modern browser or select WebM (VP8) format.'\n      );\n    }\n\n    // Get advanced VP9 parameters if available\n    if (!this._panel) return null;\n    const qualityEl = asSelect(this._panel.querySelector('#ve-vp9-quality'));\n    const latencyEl = asSelect(this._panel.querySelector('#ve-vp9-latency'));\n    const bitrateModeEl = asSelect(this._panel.querySelector('#ve-vp9-bitrate-mode'));\n    const keyframeEl = asInput(this._panel.querySelector('#ve-vp9-keyframe'));\n    const contentHintEl = asSelect(this._panel.querySelector('#ve-vp9-content-hint'));\n\n    const quality = qualityEl ? qualityEl.value : 'high';\n    const latencyMode = latencyEl ? latencyEl.value : 'quality';\n    const bitrateMode = bitrateModeEl ? bitrateModeEl.value : 'variable';\n    const keyFrameInterval = keyframeEl ? parseInt(keyframeEl.value, 10) : 120;\n    const contentHint = contentHintEl ? contentHintEl.value : '';\n\n    console.log('[WebCodecs VP9] Advanced params:', {\n      quality,\n      latencyMode,\n      bitrateMode,\n      keyFrameInterval,\n      contentHint: contentHint || 'auto'\n    });\n\n    // Create and initialize encoder with all options\n    const encoder = new this._WebCodecsVP9Encoder();\n    await encoder.create({\n      width,\n      height,\n      fps,\n      bitrate,\n      quality,\n      latencyMode,\n      bitrateMode,\n      keyFrameInterval,\n      contentHint\n    });\n\n    console.log(`[WebCodecs VP9] Got encoder (${width}x${height}, ${fps}fps, ${bitrate}kbps, ${quality} quality)`);\n    return encoder;\n  }\n\n  async _detectEncoderSources() {\n    // Try locations in order:\n    // 1. Plugin's own vendor/ directory (same location as the plugin)\n    // 2. Custom encoderPath if specified\n    // 3. CDN fallback\n\n    const mp4PathsToTry = [];\n    const webmPathsToTry = [];\n\n    // 1. Try plugin's vendor directory\n    const pluginDir = getPluginDirectory();\n    if (pluginDir) {\n      mp4PathsToTry.push({\n        name: 'plugin vendor',\n        encoderUrl: pluginDir + 'vendor/mp4/mp4-encoder.js',\n        simdUrl: pluginDir + 'vendor/mp4/index.js'\n      });\n      webmPathsToTry.push({\n        name: 'plugin vendor',\n        workerUrl: pluginDir + 'vendor/webm/webm-worker.js',\n        wasmUrl: pluginDir + 'vendor/webm/webm-wasm.wasm'\n      });\n    }\n\n    // 2. Try custom path if specified\n    if (this.options.encoderPath) {\n      const customPath = this.options.encoderPath.endsWith('/')\n        ? this.options.encoderPath\n        : this.options.encoderPath + '/';\n\n      mp4PathsToTry.push({\n        name: 'custom path',\n        encoderUrl: customPath + 'mp4-encoder.js',\n        simdUrl: customPath + 'index.js'\n      });\n      webmPathsToTry.push({\n        name: 'custom path',\n        workerUrl: customPath + 'webm-worker.js',\n        wasmUrl: customPath + 'webm-wasm.wasm'\n      });\n    }\n\n    // Try to detect MP4 encoder\n    let mp4Source = null;\n    for (const path of mp4PathsToTry) {\n      try {\n        const response = await fetch(path.encoderUrl, { method: 'HEAD' });\n        if (response.ok) {\n          console.log(`‚úÖ Found MP4 encoder at ${path.name}: ${path.encoderUrl}`);\n          mp4Source = path;\n          break;\n        }\n      } catch (e) {\n        // Continue to next path\n      }\n    }\n\n    // Fallback to CDN for MP4\n    if (!mp4Source) {\n      console.log('‚ÑπÔ∏è Using CDN for MP4 encoder (no local files found)');\n      mp4Source = {\n        name: 'CDN',\n        encoderUrl: this.options.encoderCdn + 'mp4-encoder.js',\n        simdUrl: WASM_FEATURE_DETECT_URL\n      };\n    }\n\n    // Try to detect WebM encoder\n    let webmSource = null;\n    for (const path of webmPathsToTry) {\n      try {\n        const response = await fetch(path.workerUrl, { method: 'HEAD' });\n        if (response.ok) {\n          console.log(`‚úÖ Found WebM encoder at ${path.name}: ${path.workerUrl}`);\n          webmSource = path;\n          break;\n        }\n      } catch (e) {\n        // Continue to next path\n      }\n    }\n\n    // WebM requires local files - no CDN fallback\n    if (!webmSource) {\n      console.error('‚ùå WebM encoder files not found!');\n      webmSource = {\n        name: 'NOT_FOUND',\n        workerUrl: null,\n        wasmUrl: null,\n        error: 'WebM encoding requires local files. Please deploy the vendor/webm/ directory alongside the plugin.'\n      };\n    }\n\n    // Return both sources\n    return {\n      mp4: mp4Source,\n      webm: webmSource\n    };\n  }\n\n  /**\n   * Read all options from UI inputs\n   * This ensures we always have fresh values from the form\n   */\n  _readOptionsFromUI() {\n    if (!this._panel) return;\n\n    // Animation\n    const animationSelect = asSelect(this._panel.querySelector('#ve-animation'));\n    if (animationSelect) this.options.animation = animationSelect.value;\n\n    // Duration\n    const durationSelect = asSelect(this._panel.querySelector('#ve-duration'));\n    if (durationSelect) {\n      if (durationSelect.value === 'custom') {\n        const customInput = asInput(this._panel.querySelector('#ve-duration-custom'));\n        this.options.duration = customInput ? parseFloat(customInput.value) * 1000 : 30000;\n      } else {\n        this.options.duration = parseFloat(durationSelect.value) * 1000;\n      }\n    }\n\n    // Speed\n    const speedSelect = asSelect(this._panel.querySelector('#ve-speed'));\n    if (speedSelect) {\n      if (speedSelect.value === 'custom') {\n        const customInput = asInput(this._panel.querySelector('#ve-speed-custom'));\n        this.options.speedMultiplier = customInput ? parseFloat(customInput.value) : 1;\n      } else {\n        this.options.speedMultiplier = parseFloat(speedSelect.value);\n      }\n    }\n\n    // FPS\n    const fpsInput = asInput(this._panel.querySelector('#ve-fps'));\n    if (fpsInput) this.options.fps = parseFloat(fpsInput.value);\n\n    // Resolution\n    const resolutionSelect = asSelect(this._panel.querySelector('#ve-resolution'));\n    if (resolutionSelect) {\n      if (resolutionSelect.value === 'custom') {\n        const widthInput = asInput(this._panel.querySelector('#ve-resolution-width-custom'));\n        const heightInput = asInput(this._panel.querySelector('#ve-resolution-height-custom'));\n        this.options.resolution = {\n          width: widthInput ? parseInt(widthInput.value, 10) : 1920,\n          height: heightInput ? parseInt(heightInput.value, 10) : 1080\n        };\n      } else {\n        this.options.resolution = resolutionSelect.value;\n      }\n    }\n\n    // Cinematic bars\n    const cinematicBarsSelect = asSelect(this._panel.querySelector('#ve-cinematic-bars'));\n    if (cinematicBarsSelect) this.options.cinematicBars = cinematicBarsSelect.value;\n\n    // Format\n    const formatSelect = asSelect(this._panel.querySelector('#ve-format'));\n    if (formatSelect) this.options.format = formatSelect.value;\n\n    // Bitrate\n    const bitrateSelect = asSelect(this._panel.querySelector('#ve-bitrate'));\n    if (bitrateSelect) {\n      if (bitrateSelect.value === 'custom') {\n        const customInput = asInput(this._panel.querySelector('#ve-bitrate-custom'));\n        this.options.bitrate = customInput ? parseInt(customInput.value, 10) : 'auto';\n      } else {\n        this.options.bitrate = bitrateSelect.value === 'auto' ? 'auto' : parseInt(bitrateSelect.value, 10);\n      }\n    }\n\n    // Wait for tiles\n    const waitTilesCheckbox = asInput(this._panel.querySelector('#ve-wait-tiles'));\n    if (waitTilesCheckbox) this.options.waitForTiles = waitTilesCheckbox.checked;\n\n    // Loop\n    const loopSelect = asSelect(this._panel.querySelector('#ve-loop'));\n    if (loopSelect) {\n      this.options.loop = loopSelect.value === 'false' ? false : loopSelect.value;\n    }\n\n    // Geographic constraints - Bounds\n    const westInput = asInput(this._panel.querySelector('#ve-bounds-west'));\n    const eastInput = asInput(this._panel.querySelector('#ve-bounds-east'));\n    const southInput = asInput(this._panel.querySelector('#ve-bounds-south'));\n    const northInput = asInput(this._panel.querySelector('#ve-bounds-north'));\n\n    if (westInput && eastInput && southInput && northInput) {\n      const west = westInput.value;\n      const east = eastInput.value;\n      const south = southInput.value;\n      const north = northInput.value;\n\n      if (west && east && south && north) {\n        this.options.maxBounds = [[parseFloat(west), parseFloat(south)], [parseFloat(east), parseFloat(north)]];\n      } else {\n        this.options.maxBounds = null;\n      }\n    }\n\n    // Zoom constraints\n    const minZoomInput = asInput(this._panel.querySelector('#ve-zoom-min'));\n    const maxZoomInput = asInput(this._panel.querySelector('#ve-zoom-max'));\n\n    if (minZoomInput) {\n      this.options.minZoom = minZoomInput.value ? parseFloat(minZoomInput.value) : null;\n    }\n    if (maxZoomInput) {\n      this.options.maxZoom = maxZoomInput.value ? parseFloat(maxZoomInput.value) : null;\n    }\n\n    // Strict bounds\n    const strictBoundsCheckbox = asInput(this._panel.querySelector('#ve-strict-bounds'));\n    if (strictBoundsCheckbox) this.options.strictBounds = strictBoundsCheckbox.checked;\n\n    // Show bounds overlay\n    const showBoundsCheckbox = asInput(this._panel.querySelector('#ve-show-bounds'));\n    if (showBoundsCheckbox) this.options.showBoundsOverlay = showBoundsCheckbox.checked;\n\n    // Exploration limit\n    const explorationLimitCheckbox = asInput(this._panel.querySelector('#ve-exploration-limit'));\n    if (explorationLimitCheckbox) {\n      this.options.explorationLimitEnabled = explorationLimitCheckbox.checked;\n    }\n\n    // Waypoints are already managed via this.options.waypoints (no need to read from DOM)\n  }\n\n  async _getAnimation() {\n    let animation;\n\n    // Handle custom function animations\n    if (typeof this.options.animation === 'function') {\n      animation = this.options.animation;\n    } else if (typeof this.options.animation === 'object' && this.options.animation !== null) {\n      // Handle custom object with metadata\n      const animObj = this.options.animation;\n      // @ts-ignore - We already checked that animation is not null\n      if (animObj.func) {\n        // @ts-ignore - We already checked that animation is not null\n        animation = animObj.func;\n      }\n    } else if (typeof this.options.animation === 'string') {\n      // Handle built-in animations from ANIMATION_PROFILES\n      const profile = ANIMATION_PROFILES[this.options.animation];\n\n      if (profile) {\n        const director = new AnimationDirector(this._map);\n        // Call animation function with director for 'smart' animation\n        animation = (map, control) => profile.func(map, control, this.options, director);\n      } else {\n        // Fallback to 'smart' if animation key not found\n        console.warn(`Animation \"${this.options.animation}\" not found, falling back to \"smart\"`);\n        const director = new AnimationDirector(this._map);\n        animation = (map, control) => director.createAdaptiveAnimation(control, this.options);\n      }\n    } else {\n      // Fallback to 'smart' for unknown types\n      console.warn('Unknown animation type, falling back to \"smart\"');\n      const director = new AnimationDirector(this._map);\n      animation = (map, control) => director.createAdaptiveAnimation(control, this.options);\n    }\n\n    // All animations return { setup, animation } format\n    // - setup: optional function to run before recording (e.g., camera positioning)\n    // - animation: main animation function to run during recording\n    let setup = null;\n    let animationFn = null;\n\n    // Call the animation function to get { setup, animation }\n    const result = animation(this._map, this);\n\n    // Check if result is the new format with setup phase\n    if (typeof result === 'object' && result !== null && 'animation' in result) {\n      // Standard format: { setup, animation }\n      setup = result.setup || null;\n      animationFn = result.animation;\n\n      if (setup) {\n        console.log('üé¨ Animation with setup phase');\n      }\n    } else {\n      // Legacy custom animation (direct Promise) - wrap it\n      console.log('‚ö†Ô∏è Legacy animation format detected, wrapping');\n      setup = null;\n      animationFn = async () => result;\n    }\n\n    // Add loop functionality if enabled\n    if (this.options.loop) {\n      animationFn = this._addLoopToAnimation(animationFn);\n    }\n\n    // Apply constraints if defined\n    if (this.options.maxBounds || this.options.minZoom !== null || this.options.maxZoom !== null) {\n      const constraints = new AnimationConstraints({\n        maxBounds: this.options.maxBounds,\n        minZoom: this.options.minZoom,\n        maxZoom: this.options.maxZoom,\n        strictBounds: this.options.strictBounds\n      });\n\n      // Wrap the animation with constraints\n      animationFn = constraints.wrapAnimation(animationFn);\n\n      console.log('üîí Animation constraints applied:', {\n        maxBounds: this.options.maxBounds,\n        minZoom: this.options.minZoom,\n        maxZoom: this.options.maxZoom,\n        strictBounds: this.options.strictBounds\n      });\n    }\n\n    return { setup, animation: animationFn };\n  }\n\n  /**\n     * Add loop functionality to an animation\n     * Returns a new animation function that includes the return-to-start step\n     */\n  _addLoopToAnimation(originalAnimation) {\n    return async (map, control) => {\n      // Capture initial position\n      const initialState = {\n        center: map.getCenter(),\n        zoom: map.getZoom(),\n        pitch: map.getPitch(),\n        bearing: map.getBearing()\n      };\n      console.log('üìç Initial position captured:', initialState.center.lng.toFixed(6), initialState.center.lat.toFixed(6));\n\n      // Run the original animation\n      console.log('‚ñ∂Ô∏è Starting original animation...');\n      await originalAnimation(map, control);\n      console.log('‚úÖ Original animation complete');\n\n      // Check final position\n      const finalState = {\n        center: map.getCenter(),\n        zoom: map.getZoom(),\n        pitch: map.getPitch(),\n        bearing: map.getBearing()\n      };\n      console.log('üìç Final position:', finalState.center.lng.toFixed(6), finalState.center.lat.toFixed(6));\n\n      // Always add return step when loop is enabled\n      console.log('üîÑ Loop enabled, adding return step');\n\n      if (this.options.loop === 'smooth') {\n        // Calculate return duration (2 seconds or 20% of duration, whichever is less)\n        const returnDuration = Math.min(2000, this.options.duration * 0.2);\n        console.log('Smooth return, duration:', returnDuration);\n\n        // Update status if function is available\n        if (control.updateStatus) {\n          control.updateStatus('üîÑ Returning to start...');\n        }\n\n        // Launch easeTo and wait for completion\n        // This works with both real time and virtual time (like other animations)\n        map.easeTo({\n          center: initialState.center,\n          zoom: initialState.zoom,\n          pitch: initialState.pitch,\n          bearing: initialState.bearing,\n          duration: returnDuration,\n          essential: true\n        });\n\n        await map.once('moveend');\n        console.log('Return complete');\n      } else {\n        // Instant jump back\n        map.jumpTo({\n          center: initialState.center,\n          zoom: initialState.zoom,\n          pitch: initialState.pitch,\n          bearing: initialState.bearing\n        });\n      }\n    };\n  }\n\n  _updateExplorationUI() {\n    if (!this._panel) return;\n    // Check if current animation supports exploration\n    let supportsExploration = false;\n\n    // Handle string animation names (built-in animations)\n    if (typeof this.options.animation === 'string') {\n      const profile = ANIMATION_PROFILES[this.options.animation];\n      supportsExploration = profile ? profile.supportsExploration : false;\n    } else if (typeof this.options.animation === 'object' && this.options.animation !== null) {\n      // Handle custom object with metadata\n      const animObj = this.options.animation;\n      // @ts-ignore - We already checked that animation is not null\n      if (animObj.supportsExploration !== undefined) {\n        // @ts-ignore - We already checked that animation is not null\n        supportsExploration = animObj.supportsExploration;\n      }\n    }\n    // Custom functions don't support exploration by default\n\n    // Show/hide Explore button\n    const exploreBtn = asHTMLElement(this._panel.querySelector('#ve-explore'));\n    if (exploreBtn) {\n      exploreBtn.style.display = supportsExploration ? 'inline-block' : 'none';\n    }\n\n    // Show/hide Exploration limit checkbox container\n    const explorationLimitContainer = asHTMLElement(this._panel.querySelector('#ve-exploration-limit-container'));\n    if (explorationLimitContainer) {\n      explorationLimitContainer.style.display = supportsExploration ? 'block' : 'none';\n    }\n\n    console.log(`[UI] Animation ${supportsExploration ? 'supports' : 'does not support'} exploration`);\n  }\n\n  _updateAnimationDescription() {\n    if (!this._panel) return;\n\n    const descriptionDiv = asHTMLElement(this._panel.querySelector('#ve-animation-description'));\n    const descriptionSpan = descriptionDiv?.querySelector('span');\n\n    if (!descriptionDiv || !descriptionSpan) return;\n\n    // Get current animation\n    const animationName = typeof this.options.animation === 'string'\n      ? this.options.animation\n      : null;\n\n    if (animationName && ANIMATION_PROFILES[animationName]) {\n      const profile = ANIMATION_PROFILES[animationName];\n      if (profile.description) {\n        descriptionSpan.textContent = profile.description;\n        descriptionDiv.style.display = 'block';\n      } else {\n        descriptionDiv.style.display = 'none';\n      }\n    } else {\n      descriptionDiv.style.display = 'none';\n    }\n  }\n\n  /**\n     * Analyze map capabilities vs animation requirements\n     * Returns an object with missing capabilities and affected animations\n     */\n  _analyzeCapabilities() {\n    // Get capabilities from AnimationDirector\n    const director = new AnimationDirector(this._map);\n    const caps = director.capabilities;\n\n    const missing = {\n      required: {}, // { capabilityName: [animationNames] }\n      optional: {} // { capabilityName: [animationNames] }\n    };\n    const available = [];\n\n    // Analyze all animations\n    Object.entries(ANIMATION_PROFILES).forEach(([animKey, profile]) => {\n      if (!profile.requires || profile.requires.length === 0) return;\n\n      profile.requires.forEach(req => {\n        const isOptional = req.startsWith('?');\n        const capName = isOptional ? req.slice(1) : req;\n\n        // Check if capability is missing\n        if (!caps[capName]) {\n          const category = isOptional ? 'optional' : 'required';\n          if (!missing[category][capName]) {\n            missing[category][capName] = [];\n          }\n          missing[category][capName].push({\n            key: animKey,\n            label: profile.label\n          });\n        }\n      });\n    });\n\n    // Build available list (just the names for display)\n    const capabilityLabels = {\n      hasTerrain: 'Terrain 3D',\n      hasHillshade: 'Hillshade',\n      has3DBuildings: 'Buildings 3D',\n      hasRoads: 'Roads',\n      hasRailways: 'Railways',\n      hasWaterways: 'Waterways',\n      hasWater: 'Water bodies',\n      hasPlaces: 'Places/Cities',\n      hasGlyphs: 'Fonts/Glyphs',\n      hasSprites: 'Sprites/Icons'\n    };\n\n    Object.entries(caps).forEach(([capName, hasIt]) => {\n      if (hasIt && capabilityLabels[capName]) {\n        available.push(capabilityLabels[capName]);\n      }\n    });\n\n    return { missing, available, capabilityLabels };\n  }\n\n  _checkMapCapabilities() {\n    if (!this._panel) return;\n    // Check if OpenMapTiles source is available\n    const hasOpenMapTiles = this._map.getSource('openmaptiles') !== undefined;\n\n    const roadAnimationsGroup = asHTMLElement(this._panel.querySelector('#ve-road-animations-group'));\n    if (roadAnimationsGroup) {\n      if (hasOpenMapTiles) {\n        roadAnimationsGroup.style.display = '';\n        console.log('[UI] OpenMapTiles detected - road animations available');\n      } else {\n        roadAnimationsGroup.style.display = 'none';\n        console.log('[UI] OpenMapTiles not found - road animations hidden');\n      }\n    }\n\n    // Update capability feedback UI\n    this._updateCapabilityFeedback();\n  }\n\n  /**\n     * Update the capability feedback UI to show missing features\n     */\n  _updateCapabilityFeedback() {\n    if (!this._panel) return;\n    const feedbackDiv = asHTMLElement(this._panel.querySelector('#ve-capability-feedback'));\n    if (!feedbackDiv) return;\n\n    const analysis = this._analyzeCapabilities();\n    const { missing } = analysis;\n\n    const hasRequiredMissing = Object.keys(missing.required).length > 0;\n    const hasOptionalMissing = Object.keys(missing.optional).length > 0;\n\n    if (!hasRequiredMissing && !hasOptionalMissing) {\n      // Perfect map - show success message\n      feedbackDiv.innerHTML = `\n                <div style=\"padding: 8px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724; font-size: 12px;\">\n                    ‚úÖ <strong>Optimal map</strong> - All animations available\n                </div>\n            `;\n      feedbackDiv.style.display = 'block';\n      return;\n    }\n\n    // Build feedback HTML\n    let html = '<div style=\"padding: 8px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-size: 11px;\">';\n\n    // Show required missing capabilities\n    if (hasRequiredMissing) {\n      html += '<div style=\"color: #856404; margin-bottom: 6px;\">';\n      html += '<strong>‚ö†Ô∏è Missing required features:</strong><br>';\n      Object.entries(missing.required).forEach(([capName, animations]) => {\n        const label = analysis.capabilityLabels[capName] || capName;\n        html += `<span style=\"color: #d63384;\">‚Ä¢ ${label}</span> `;\n        html += `<span style=\"color: #6c757d; font-size: 10px;\">(${animations.length} animation${animations.length > 1 ? 's' : ''} disabled)</span><br>`;\n      });\n      html += '</div>';\n    }\n\n    // Show optional missing capabilities\n    if (hasOptionalMissing) {\n      html += '<div style=\"color: #856404; font-size: 10px;\">';\n      html += '<strong>üí° Optional enhancements missing:</strong><br>';\n      Object.entries(missing.optional).forEach(([capName, animations]) => {\n        const label = analysis.capabilityLabels[capName] || capName;\n        html += `<span>‚Ä¢ ${label}</span> `;\n        html += `<span style=\"color: #6c757d;\">(${animations.length} animation${animations.length > 1 ? 's' : ''} affected)</span><br>`;\n      });\n      html += '</div>';\n    }\n\n    html += '</div>';\n\n    feedbackDiv.innerHTML = html;\n    feedbackDiv.style.display = 'block';\n  }\n\n  async _testAnimation() {\n    if (!this._panel) return;\n    const testBtn = asButton(this._panel.querySelector('#ve-test'));\n    const recordBtn = asButton(this._panel.querySelector('#ve-record'));\n    if (!testBtn || !recordBtn) return;\n\n    // Save settings to localStorage\n    this._saveSettings();\n\n    // Hide reset message if visible\n    const resetMessage = this._panel.querySelector('#ve-reset-message');\n    if (resetMessage) resetMessage.style.display = 'none';\n\n    // If running, cancel it\n    if (this._animationController.running) {\n      this._animationController.cancel(this._map);\n\n      // Clear progress timer if exists\n      if (this._testProgressTimer) {\n        clearInterval(this._testProgressTimer);\n        this._testProgressTimer = null;\n      }\n\n      testBtn.innerHTML = '‚ñ∂Ô∏è Test';\n      testBtn.disabled = false;\n      recordBtn.disabled = false;\n      this._updateStatus('Cancelled', 'error');\n      this._expandInterface();\n      return;\n    }\n\n    testBtn.innerHTML = '‚èπÔ∏è Cancel';\n    recordBtn.disabled = true;\n    this._collapseInterface();\n\n    try {\n      this._updateStatus('Testing animation...', 'recording');\n\n      // Read fresh options from UI inputs\n      this._readOptionsFromUI();\n\n      // Get animation with optional setup phase\n      const { setup, animation } = await this._getAnimation();\n\n      // Execute setup phase first (e.g., camera repositioning)\n      if (setup) {\n        console.log('üé¨ Executing animation setup phase (for test)...');\n        this._updateStatus('Preparing animation...', 'recording');\n        await setup(this._map, this, {\n          checkAbort: () => {\n            if (this._animationController.aborted) {\n              throw new Error('Test cancelled');\n            }\n          },\n          updateStatus: (msg) => {\n            if (msg) this._updateStatus(msg, 'recording');\n          }\n        });\n        console.log('‚úì Setup phase complete');\n      }\n\n      // Start progress tracking\n      const startTime = performance.now();\n      const duration = this.options.duration;\n\n      // Show widget\n      if (this._progressWidget) {\n        this._progressWidget.style.display = 'block';\n      }\n\n      // Update widget every 100ms during test\n      this._testProgressTimer = setInterval(() => {\n        const elapsed = performance.now() - startTime;\n        const elapsedSeconds = (elapsed / 1000).toFixed(1);\n        const durationSeconds = (duration / 1000).toFixed(1);\n        const percent = Math.min(100, (elapsed / duration) * 100).toFixed(0);\n\n        // Update widget elements directly\n        const statusSpan = this._progressWidget?.querySelector('#ve-progress-status');\n        const percentSpan = this._progressWidget?.querySelector('#ve-progress-percent');\n        const timeSpan = this._progressWidget?.querySelector('#ve-progress-time');\n\n        if (statusSpan) statusSpan.textContent = '‚ñ∂Ô∏è Testing';\n        if (percentSpan) percentSpan.textContent = `${percent}% complete`;\n        if (timeSpan) timeSpan.textContent = `${elapsedSeconds}s / ${durationSeconds}s`;\n      }, 100);\n\n      // Run the actual animation\n      const result = await this._animationController.run(this._map, animation, {\n        updateStatus: (msg) => {\n          if (msg) this._updateStatus(msg, 'recording');\n        }\n      });\n\n      if (result.cancelled) {\n        this._updateStatus('Cancelled', 'error');\n      } else if (result.success) {\n        this._updateStatus('Test complete', 'success');\n      }\n    } catch (error) {\n      this._updateStatus('Test failed: ' + error.message, 'error');\n      this.options.onError(error);\n    } finally {\n      // Clear progress timer\n      if (this._testProgressTimer) {\n        clearInterval(this._testProgressTimer);\n        this._testProgressTimer = null;\n      }\n\n      testBtn.innerHTML = '‚ñ∂Ô∏è Test';\n      testBtn.disabled = false;\n      recordBtn.disabled = false;\n      this._expandInterface();\n    }\n  }\n\n  async _startExploration() {\n    if (!this._panel) return;\n    const exploreBtn = asButton(this._panel.querySelector('#ve-explore'));\n    const testBtn = asButton(this._panel.querySelector('#ve-test'));\n    const recordBtn = asButton(this._panel.querySelector('#ve-record'));\n    if (!exploreBtn || !testBtn || !recordBtn) return;\n\n    // Save settings to localStorage\n    this._saveSettings();\n\n    // Hide reset message if visible\n    const resetMessage = this._panel.querySelector('#ve-reset-message');\n    if (resetMessage) resetMessage.style.display = 'none';\n\n    // If running, cancel it\n    if (this._animationController.running) {\n      this._animationController.cancel(this._map);\n\n      // Clear progress timer if exists\n      if (this._exploreProgressTimer) {\n        clearInterval(this._exploreProgressTimer);\n        this._exploreProgressTimer = null;\n      }\n\n      exploreBtn.innerHTML = 'üó∫Ô∏è Explore';\n      testBtn.disabled = false;\n      recordBtn.innerHTML = 'üî¥ Record';\n      recordBtn.disabled = false;\n      this._updateStatus('Exploration stopped', 'error');\n      this._expandInterface();\n      // Clear exploration flag\n      this._isExploring = false;\n      return;\n    }\n\n    // Set exploration mode\n    this._isExploring = true;\n\n    exploreBtn.innerHTML = '‚èπÔ∏è Stop';\n    testBtn.disabled = true;\n    recordBtn.innerHTML = 'üìç Record from here';\n    recordBtn.disabled = false; // Keep record button active for \"record from here\"\n    this._collapseInterface();\n\n    try {\n      this._updateStatus('üó∫Ô∏è Exploring roads...', 'recording');\n      console.log('[Exploration] Starting infinite road exploration');\n\n      // Read fresh options from UI inputs\n      this._readOptionsFromUI();\n\n      // Get animation with setup phase\n      const { setup, animation } = await this._getAnimation();\n\n      // Execute setup phase\n      if (setup) {\n        console.log('üé¨ Executing animation setup phase (for exploration)...');\n        this._updateStatus('Preparing exploration...', 'recording');\n        await setup(this._map, this, {\n          checkAbort: () => {\n            if (this._animationController.aborted) {\n              throw new Error('Exploration cancelled');\n            }\n          },\n          updateStatus: (msg) => {\n            if (msg) this._updateStatus(msg, 'recording');\n          }\n        });\n        console.log('‚úì Setup complete - starting infinite exploration');\n      }\n\n      // Check if exploration limit is enabled via checkbox\n      const explorationLimitCheckbox = asInput(this._panel.querySelector('#ve-exploration-limit'));\n      const isLimitEnabled = explorationLimitCheckbox?.checked || false;\n\n      // Run animation with configurable duration limit\n      const originalDuration = this.options.duration;\n      if (isLimitEnabled) {\n        // Use configured max duration when limit is enabled\n        this.options.duration = this.options.explorationMaxDuration;\n        console.log(`üó∫Ô∏è Exploration limited to ${(this.options.explorationMaxDuration / 1000).toFixed(0)}s`);\n      } else {\n        // Infinite exploration (no limit)\n        this.options.duration = 999999999; // ~11.5 days (effectively infinite)\n        console.log('üó∫Ô∏è Infinite exploration (no duration limit)');\n      }\n\n      // Show widget\n      if (this._progressWidget) {\n        this._progressWidget.style.display = 'block';\n      }\n\n      // Start progress tracking for exploration\n      const startTime = performance.now();\n      const maxDuration = isLimitEnabled ? this.options.explorationMaxDuration : null;\n\n      // Update widget every 100ms during exploration\n      this._exploreProgressTimer = setInterval(() => {\n        const elapsed = performance.now() - startTime;\n        const elapsedSeconds = (elapsed / 1000).toFixed(1);\n\n        // Update widget elements directly\n        const statusSpan = this._progressWidget?.querySelector('#ve-progress-status');\n        const percentSpan = this._progressWidget?.querySelector('#ve-progress-percent');\n        const timeSpan = this._progressWidget?.querySelector('#ve-progress-time');\n\n        if (statusSpan) statusSpan.textContent = 'üó∫Ô∏è Exploring';\n\n        if (isLimitEnabled && maxDuration) {\n          // Show progress towards limit\n          const percent = Math.min(100, (elapsed / maxDuration) * 100).toFixed(0);\n          const remainingSeconds = Math.max(0, (maxDuration - elapsed) / 1000).toFixed(1);\n          if (percentSpan) percentSpan.textContent = `${percent}% complete`;\n          if (timeSpan) timeSpan.textContent = `${elapsedSeconds}s / ${(maxDuration / 1000).toFixed(0)}s (${remainingSeconds}s left)`;\n        } else {\n          // Infinite mode - just show elapsed time\n          if (percentSpan) percentSpan.textContent = 'Infinite exploration';\n          if (timeSpan) timeSpan.textContent = `${elapsedSeconds}s elapsed`;\n        }\n      }, 100);\n\n      const result = await this._animationController.run(this._map, animation, {\n        updateStatus: (msg) => {\n          if (msg) this._updateStatus(msg, 'recording');\n        }\n      });\n\n      // Restore original duration\n      this.options.duration = originalDuration;\n\n      if (result.cancelled) {\n        this._updateStatus('Exploration stopped', 'error');\n      } else {\n        this._updateStatus('Exploration complete', 'success');\n      }\n    } catch (error) {\n      this._updateStatus('Exploration failed: ' + error.message, 'error');\n      this.options.onError(error);\n    } finally {\n      // Clear progress timer\n      if (this._exploreProgressTimer) {\n        clearInterval(this._exploreProgressTimer);\n        this._exploreProgressTimer = null;\n      }\n\n      exploreBtn.innerHTML = 'üó∫Ô∏è Explore';\n      testBtn.disabled = false;\n      recordBtn.innerHTML = 'üî¥ Record';\n      recordBtn.disabled = false;\n      this._expandInterface();\n      this._isExploring = false;\n    }\n  }\n\n  async _startRecording() {\n    if (!this._panel) return;\n    const testBtn = asButton(this._panel.querySelector('#ve-test'));\n    const exploreBtn = asButton(this._panel.querySelector('#ve-explore'));\n    const recordBtn = asButton(this._panel.querySelector('#ve-record'));\n    if (!testBtn || !exploreBtn || !recordBtn) return;\n\n    // Save settings to localStorage\n    this._saveSettings();\n\n    // Hide reset message if visible\n    const resetMessage = this._panel.querySelector('#ve-reset-message');\n    if (resetMessage) resetMessage.style.display = 'none';\n\n    // SPECIAL CASE: If we're in exploration mode and click \"Record from here\"\n    if (this._isExploring && this._animationController.running) {\n      console.log('[Recording] üìç Starting recording from current exploration position');\n\n      // Stop exploration\n      this._animationController.cancel(this._map);\n      this._isExploring = false;\n\n      // Reset exploration UI\n      if (exploreBtn) exploreBtn.innerHTML = 'üó∫Ô∏è Explore';\n      if (testBtn) testBtn.disabled = true; // Disable test during recording\n      if (recordBtn) recordBtn.innerHTML = '‚èπÔ∏è Cancel';\n\n      this._updateStatus('Recording from current position...', 'recording');\n\n      // Small delay to let exploration cleanup\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Continue to normal recording flow\n      // The camera is already at the desired position from exploration\n    }\n\n    // If running, cancel it\n    if (this._animationController.running) {\n      this._animationController.cancel(this._map);\n\n      testBtn.disabled = false;\n      recordBtn.innerHTML = 'üî¥ Record';\n      recordBtn.disabled = false;\n      this._updateStatus('Cancelled', 'error');\n      this._hideProgress();\n      this._expandInterface();\n      // Clear recording flag immediately on cancel\n      this._isRecording = false;\n      console.log('[Recording] üîì Recording flag CLEARED on cancel');\n      // Restore time if needed\n      if (maplibregl.restoreNow) {\n        maplibregl.restoreNow();\n      }\n      return;\n    }\n\n    // Prevent starting new recording if cleanup from previous one isn't complete\n    if (this._isRecording) {\n      console.warn('[Recording] ‚ö†Ô∏è Cannot start new recording - previous recording still cleaning up');\n      this._updateStatus('Please wait...', 'error');\n      return;\n    }\n\n    // Check for time control\n    if (!window.maplibregl || typeof maplibregl.setNow !== 'function') {\n      this._updateStatus('Time control not available', 'error');\n      alert('MapLibre time control (setNow/restoreNow) is required for video export.\\n\\nPlease use MapLibre GL JS v5.10.0 or later.');\n      return;\n    }\n\n    testBtn.disabled = true;\n    recordBtn.innerHTML = '‚èπÔ∏è Cancel';\n    this._collapseInterface();\n\n    try {\n      // Read fresh options from UI inputs\n      this._readOptionsFromUI();\n\n      // Start recording directly (no test needed - helper map works in real-time)\n      console.log('[Recording] üî¥ Starting recording...');\n      await this._doRecording();\n    } catch (error) {\n      if (error.name === 'AbortError' || error.message === 'Recording cancelled') {\n        this._updateStatus('Cancelled', 'error');\n      } else {\n        console.error('Recording error:', error);\n        this._updateStatus('Recording failed', 'error');\n        this.options.onError(error);\n      }\n      this._hideProgress();\n    } finally {\n      testBtn.disabled = false;\n      recordBtn.innerHTML = 'üî¥ Record';\n      this._expandInterface();\n\n      // Always restore time\n      if (maplibregl.restoreNow) {\n        maplibregl.restoreNow();\n      }\n    }\n  }\n\n  /**\n     * Ensure camera is within configured constraints before recording\n     * If camera is outside bounds or zoom limits, animate it back to valid position\n     * @returns {Promise} Resolves when camera is within constraints\n     */\n  async _ensureCameraWithinConstraints() {\n    // Check if we have any constraints configured\n    if (!this.options.maxBounds && this.options.minZoom === null && this.options.maxZoom === null) {\n      console.log('[Constraints] No constraints configured, skipping camera check');\n      return;\n    }\n\n    console.log('[Constraints] Checking camera position against constraints...');\n\n    const currentCenter = this._map.getCenter();\n    const currentZoom = this._map.getZoom();\n    let needsCorrection = false;\n    let targetCenter = currentCenter;\n    let targetZoom = currentZoom;\n\n    // Check bounds constraint\n    if (this.options.maxBounds) {\n      const [[west, south], [east, north]] = this.options.maxBounds;\n      const lng = currentCenter.lng;\n      const lat = currentCenter.lat;\n\n      if (lng < west || lng > east || lat < south || lat > north) {\n        needsCorrection = true;\n        // Constrain to bounds\n        const constrainedLng = Math.max(west, Math.min(east, lng));\n        const constrainedLat = Math.max(south, Math.min(north, lat));\n        targetCenter = { lng: constrainedLng, lat: constrainedLat };\n        console.log(`[Constraints] Camera outside bounds: [${lng.toFixed(4)}, ${lat.toFixed(4)}] ‚Üí [${constrainedLng.toFixed(4)}, ${constrainedLat.toFixed(4)}]`);\n      }\n    }\n\n    // Check zoom constraints\n    if (this.options.minZoom !== null && currentZoom < this.options.minZoom) {\n      needsCorrection = true;\n      targetZoom = this.options.minZoom;\n      console.log(`[Constraints] Zoom below minimum: ${currentZoom.toFixed(2)} ‚Üí ${targetZoom.toFixed(2)}`);\n    } else if (this.options.maxZoom !== null && currentZoom > this.options.maxZoom) {\n      needsCorrection = true;\n      targetZoom = this.options.maxZoom;\n      console.log(`[Constraints] Zoom above maximum: ${currentZoom.toFixed(2)} ‚Üí ${targetZoom.toFixed(2)}`);\n    }\n\n    // If camera needs correction, animate it to valid position\n    if (needsCorrection) {\n      console.log('[Constraints] ‚ö†Ô∏è Camera outside constraints - correcting position...');\n\n      return /** @type {Promise<void>} */(new Promise((resolve) => {\n        this._map.easeTo({\n          center: targetCenter,\n          zoom: targetZoom,\n          duration: 1000, // 1 second animation\n          easing: (t) => t // Linear easing\n        });\n\n        // Wait for animation to complete\n        this._map.once('moveend', () => {\n          console.log('[Constraints] ‚úì Camera position corrected');\n          resolve();\n        });\n      }));\n    } else {\n      console.log('[Constraints] ‚úì Camera already within constraints');\n    }\n  }\n\n  /**\n     * Apply cinematic bars to pixel buffer\n     * @param {Uint8Array} pixels - RGBA pixel buffer\n     * @param {number} width - Image width\n     * @param {number} height - Image height\n     * @param {string} aspectRatio - Aspect ratio ('none', '2.39', '1.85', '2.33')\n     */\n  _applyCinematicBars(pixels, width, height, aspectRatio) {\n    if (aspectRatio === 'none') return;\n\n    // Calculate target aspect ratio\n    const targetRatio = parseFloat(aspectRatio);\n\n    // Calculate visible height for target aspect ratio\n    const visibleHeight = Math.floor(width / targetRatio);\n\n    // Check if aspect ratio is compatible with this resolution\n    if (visibleHeight >= height) {\n      console.warn(`üé¨ Cinematic bars skipped: aspect ratio ${aspectRatio}:1 requires height >= ${visibleHeight}px (current: ${height}px)`);\n      return;\n    }\n\n    // Calculate bar height (total bars split top and bottom)\n    const totalBarHeight = height - visibleHeight;\n    const topBarHeight = Math.floor(totalBarHeight / 2);\n    const bottomBarHeight = totalBarHeight - topBarHeight;\n\n    // Validate bar heights\n    if (topBarHeight < 0 || bottomBarHeight < 0) {\n      console.warn(`üé¨ Cinematic bars skipped: invalid bar heights (top: ${topBarHeight}px, bottom: ${bottomBarHeight}px)`);\n      return;\n    }\n\n    console.log(`üé¨ Applying cinematic bars: ${aspectRatio}:1 (visible: ${visibleHeight}px, bars: ${topBarHeight}px + ${bottomBarHeight}px)`);\n\n    // Fill top bar with black\n    const bytesPerPixel = 4; // RGBA\n    const bytesPerRow = width * bytesPerPixel;\n\n    for (let y = 0; y < topBarHeight; y++) {\n      const rowOffset = y * bytesPerRow;\n      for (let x = 0; x < width; x++) {\n        const pixelOffset = rowOffset + x * bytesPerPixel;\n        pixels[pixelOffset] = 0; // R\n        pixels[pixelOffset + 1] = 0; // G\n        pixels[pixelOffset + 2] = 0; // B\n        pixels[pixelOffset + 3] = 255; // A (opaque)\n      }\n    }\n\n    // Fill bottom bar with black\n    const bottomStartY = height - bottomBarHeight;\n    for (let y = bottomStartY; y < height; y++) {\n      const rowOffset = y * bytesPerRow;\n      for (let x = 0; x < width; x++) {\n        const pixelOffset = rowOffset + x * bytesPerPixel;\n        pixels[pixelOffset] = 0; // R\n        pixels[pixelOffset + 1] = 0; // G\n        pixels[pixelOffset + 2] = 0; // B\n        pixels[pixelOffset + 3] = 255; // A (opaque)\n      }\n    }\n  }\n\n  async _doRecording() {\n    if (!this._panel) return;\n    // Start real-time performance measurement\n    const realStartTime = performance.now();\n\n    console.log('üé¨ Starting recording with format:', this.options.format);\n\n    // Ensure camera is within constraints before starting\n    await this._ensureCameraWithinConstraints();\n\n    this._updateStatus(`Loading ${this.options.format.toUpperCase()} encoder...`, 'recording');\n\n    // Set recording flag to prevent waypoints layer recreation\n    this._isRecording = true;\n    console.log('[Recording] üîí Recording flag SET - layer updates blocked');\n\n    // Get resolution\n    const resolution = this._getResolution();\n    const { width, height } = resolution;\n\n    // Get cinematic bars setting\n    const cinematicBarsSelect = asSelect(this._panel.querySelector('#ve-cinematic-bars'));\n    const cinematicBars = cinematicBarsSelect ? cinematicBarsSelect.value : 'none';\n    console.log('üé¨ Cinematic bars:', cinematicBars);\n\n    // Calculate bitrate if auto\n    let bitrate = this.options.bitrate;\n    if (bitrate === 'auto') {\n      // Auto-calculate based on resolution and format\n      const pixels = width * height;\n      const isVP8Realtime = this.options.format === 'webm-vp8' || this.options.format === 'webm';\n\n      // VP8 realtime mode needs higher bitrate to compensate for simplified encoding\n      if (isVP8Realtime) {\n        if (pixels <= 1280 * 720) {\n          bitrate = 8000; // HD: 8 Mbps (vs 5 for VP9/MP4)\n        } else if (pixels <= 1920 * 1080) {\n          bitrate = 12000; // Full HD: 12 Mbps (vs 8)\n        } else if (pixels <= 2560 * 1440) {\n          bitrate = 16000; // 2K: 16 Mbps (vs 12)\n        } else {\n          bitrate = 25000; // 4K+: 25 Mbps (vs 20)\n        }\n        console.log(`Auto bitrate (VP8 realtime): ${bitrate} kbps for ${width}√ó${height}`);\n      } else {\n        // VP9 and MP4 use standard bitrates\n        if (pixels <= 1280 * 720) {\n          bitrate = 5000; // HD: 5 Mbps\n        } else if (pixels <= 1920 * 1080) {\n          bitrate = 8000; // Full HD: 8 Mbps\n        } else if (pixels <= 2560 * 1440) {\n          bitrate = 12000; // 2K: 12 Mbps\n        } else {\n          bitrate = 20000; // 4K+: 20 Mbps\n        }\n        console.log(`Auto bitrate (${this.options.format}): ${bitrate} kbps for ${width}√ó${height}`);\n      }\n    }\n\n    this._updateStatus(`Initializing ${width}√ó${height}...`, 'recording');\n\n    // Save original size and camera state\n    const container = this._map.getContainer();\n    const originalSize = {\n      width: container.style.width,\n      height: container.style.height\n    };\n    const originalCamera = {\n      center: this._map.getCenter(),\n      zoom: this._map.getZoom(),\n      pitch: this._map.getPitch(),\n      bearing: this._map.getBearing()\n    };\n\n    // Resize if needed\n    if (this.options.resolution !== 'auto') {\n      container.style.width = width + 'px';\n      container.style.height = height + 'px';\n      this._map.resize();\n\n      // Restore camera position after resize\n      this._map.jumpTo({\n        center: originalCamera.center,\n        zoom: originalCamera.zoom,\n        pitch: originalCamera.pitch,\n        bearing: originalCamera.bearing\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 500)); // Wait for resize\n    }\n\n    // Hide waypoint markers during recording (they are DOM elements that would appear in the video)\n    this._hideWaypointMarkers();\n\n    // Create temporary WebGL layer for waypoints (will be captured in video)\n    // Wait for icon to load if needed (important when time is frozen with setNow)\n    await this._createWaypointsWebGLLayer();\n\n    // Store real recording parameters for accurate size estimation\n    this._recordingParams = { width, height, fps: this.options.fps, bitrate };\n\n    // Create encoder for the selected format\n    let encoder = null;\n    try {\n      encoder = await this._loadEncoderForFormat(width, height, this.options.fps, bitrate);\n      this._encoder = encoder; // Store for cleanup if needed\n\n      // Setup capture\n      const gl = this._map.painter.context.gl;\n      let ptr = null; // Only used for MP4\n      if (this.options.format === 'mp4') {\n        ptr = encoder.getRGBPointer();\n      }\n      let frameCount = 0;\n      let virtualTime = 0;\n\n      // Calculate time advance based on fps and speed multiplier\n      // Real-time = 1000/fps ms per frame\n      // speedMultiplier: 1 = real-time, 2 = twice as fast, 0.5 = half speed\n      const realTimeAdvance = 1000 / this.options.fps;\n      const timeAdvance = realTimeAdvance * this.options.speedMultiplier;\n\n      console.log(`Time advance: ${timeAdvance.toFixed(2)}ms per frame (${this.options.speedMultiplier}x speed at ${this.options.fps} fps)`);\n      console.log(`‚è≥ Wait for tiles: ${this.options.waitForTiles ? 'enabled (slower, better quality)' : 'disabled (faster)'}`);\n\n      // Get animation with optional setup phase\n      const { setup, animation } = await this._getAnimation();\n\n      // Execute setup phase BEFORE freezing time (e.g., camera repositioning)\n      if (setup) {\n        console.log('üé¨ Executing animation setup phase (before time freeze)...');\n        this._updateStatus('Preparing animation...', 'recording');\n        await setup(this._map, this, {\n          checkAbort: () => {\n            if (this._animationController.aborted) {\n              throw new Error('Recording cancelled');\n            }\n          },\n          updateStatus: (msg) => {\n            if (msg) this._updateStatus(msg, 'recording');\n          }\n        });\n        console.log('‚úì Setup phase complete');\n      }\n\n      // Freeze time AFTER setup\n      maplibregl.setNow(virtualTime);\n\n      // Helper to wait for tiles to load\n      // With frozen time (setNow), events don't fire normally, so we use a simple approach:\n      // Force multiple repaints and check tiles status\n      const waitForTilesLoaded = async () => {\n        // Quick check first\n        if (this._map.areTilesLoaded()) {\n          return;\n        }\n\n        // Force multiple render cycles to give tiles time to load\n        // With frozen time, we need to manually trigger repaints\n        const maxAttempts = 5;\n        for (let i = 0; i < maxAttempts; i++) {\n          this._map.triggerRepaint();\n\n          // Wait a tiny bit for the browser to process\n          await new Promise(resolve => setTimeout(resolve, 20));\n\n          // Check if tiles loaded\n          if (this._map.areTilesLoaded()) {\n            return;\n          }\n        }\n\n        // Continue anyway after max attempts\n      };\n\n      // Calculate recording duration (needed for metrics later)\n      let recordingDuration = this.options.duration / this.options.speedMultiplier;\n\n      // Single capture loop that optionally waits for tiles\n      {\n        // Calculate frames needed to complete animation at the given speed\n        // If speedMultiplier = 0.25 (very slow), we need 4x more frames to complete the animation\n        // If speedMultiplier = 2 (fast), we need 2x fewer frames\n\n        // Add extra time for loop return if enabled (update shared variable)\n        if (this.options.loop) {\n          // Add maximum return duration (2s or 20% of duration, whichever is less)\n          const returnDuration = Math.min(2000, this.options.duration * 0.2);\n          recordingDuration += returnDuration / this.options.speedMultiplier;\n          console.log('Loop enabled, adding', returnDuration, 'ms for return. Total duration:', recordingDuration);\n        }\n\n        const targetFrames = Math.floor((recordingDuration / 1000) * this.options.fps);\n\n        // Initialize progress display\n        this._updateProgress(0, targetFrames, bitrate, recordingDuration);\n\n        // Start animation (don't await - let it run in background)\n        this._updateStatus('Recording animation...', 'recording');\n\n        // Launch animation and track when it's complete\n        let animationComplete = false;\n        this._animationController.run(this._map, animation, {\n          updateStatus: (msg) => {\n            if (msg) this._updateStatus(msg, 'recording');\n          }\n        }).then(() => {\n          animationComplete = true;\n          console.log('üé¨ Animation wrapper complete (including return)');\n        }).catch(error => {\n          if (error.name !== 'AbortError') {\n            console.error('Animation error:', error);\n          }\n          animationComplete = true;\n        });\n\n        // Small delay to let animation start\n        await new Promise(resolve => setTimeout(resolve, 100));\n\n        // Single capture loop - continue until animation is complete BUT limit frames\n        try {\n          // eslint-disable-next-line no-unmodified-loop-condition -- animationComplete is modified asynchronously in Promise callbacks above\n          while (!animationComplete && frameCount < targetFrames) {\n            // Advance time\n            virtualTime += timeAdvance;\n            maplibregl.setNow(virtualTime);\n            this._map.triggerRepaint();\n\n            // Wait for tiles if option enabled\n            if (this.options.waitForTiles) {\n              await waitForTilesLoaded();\n            }\n\n            // Wait for render\n            await new Promise(resolve => this._map.once('render', resolve));\n\n            // Capture frame\n            if (this.options.format === 'mp4') {\n              // MP4: Direct memory access (synchronous)\n              const pixels = encoder.memory().subarray(ptr);\n              gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n              // Apply cinematic bars if enabled\n              this._applyCinematicBars(pixels, width, height, cinematicBars);\n\n              encoder.encodeRGBPointer();\n            } else {\n              // WebM: Copy to new buffer and send to worker (asynchronous)\n              // Create a new ArrayBuffer to ensure data is properly transferred\n              const buffer = new ArrayBuffer(width * height * 4);\n              const pixels = new Uint8Array(buffer);\n              gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n              // Flip vertically (WebGL coordinates are bottom-up, video expects top-down)\n              const flipped = new Uint8Array(width * height * 4);\n              const bytesPerRow = width * 4;\n              for (let y = 0; y < height; y++) {\n                const srcOffset = y * bytesPerRow;\n                const dstOffset = (height - 1 - y) * bytesPerRow;\n                flipped.set(pixels.subarray(srcOffset, srcOffset + bytesPerRow), dstOffset);\n              }\n\n              // Apply cinematic bars if enabled (after flipping)\n              this._applyCinematicBars(flipped, width, height, cinematicBars);\n\n              // Debug first frame\n              if (frameCount === 1) {\n                console.log('[WebM] First frame captured and flipped:', {\n                  width,\n                  height,\n                  bufferSize: flipped.byteLength,\n                  firstPixels: Array.from(flipped.slice(0, 16))\n                });\n              }\n\n              // Note: await needed for WebCodecs VP9 (async), doesn't hurt webm-wasm VP8 (sync)\n              await encoder.addFrame(flipped);\n            }\n\n            frameCount++;\n\n            // Update progress bar on every frame\n            this._updateProgress(frameCount, targetFrames, bitrate, recordingDuration);\n\n            // Update status and call onProgress every second\n            if (frameCount % this.options.fps === 0) {\n              const seconds = Math.floor(frameCount / this.options.fps);\n              this._updateStatus(`Recording... ${seconds}s`, 'recording');\n              this.options.onProgress(frameCount, virtualTime);\n            }\n          }\n\n          if (animationComplete) {\n            console.log('‚úÖ Animation complete, captured', frameCount, 'frames');\n          } else {\n            console.log('‚ö†Ô∏è Reached target frames (', frameCount, '), stopping capture');\n          }\n        } catch (error) {\n          maplibregl.restoreNow();\n          if (this.options.resolution !== 'auto') {\n            container.style.width = originalSize.width;\n            container.style.height = originalSize.height;\n            this._map.resize();\n          }\n          throw error;\n        }\n      }\n\n      // Restore time\n      maplibregl.restoreNow();\n\n      // Encode\n      this._updateStatus('Encoding video...', 'recording');\n      // Update progress widget to show encoding status\n      const statusSpan = this._progressWidget?.querySelector('#ve-progress-status');\n      if (statusSpan) statusSpan.textContent = 'Encoding';\n      const videoData = await encoder.end();\n      const mimeType = this.options.format === 'mp4' ? 'video/mp4' : 'video/webm';\n      const blob = new Blob([videoData], { type: mimeType });\n\n      // Restore size and camera\n      if (this.options.resolution !== 'auto') {\n        container.style.width = originalSize.width;\n        container.style.height = originalSize.height;\n        this._map.resize();\n\n        // Restore camera position after resize\n        this._map.jumpTo({\n          center: originalCamera.center,\n          zoom: originalCamera.zoom,\n          pitch: originalCamera.pitch,\n          bearing: originalCamera.bearing\n        });\n      }\n\n      // Download\n      const a = document.createElement('a');\n      a.href = URL.createObjectURL(blob);\n      const extension = this.options.format === 'mp4' ? 'mp4' : 'webm';\n      a.download = `maplibre-video-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${extension}`;\n      a.click();\n\n      const sizeMB = (blob.size / 1024 / 1024).toFixed(2);\n\n      // Calculate and log performance metrics\n      const realElapsedSeconds = ((performance.now() - realStartTime) / 1000).toFixed(1);\n      const videoDurationSeconds = (recordingDuration / 1000).toFixed(1);\n      const speedRatio = (recordingDuration / (performance.now() - realStartTime)).toFixed(2);\n\n      console.log('‚úÖ Export complete!');\n      console.log(`   üìπ Video: ${videoDurationSeconds}s (${frameCount} frames @ ${this.options.fps} fps)`);\n      console.log(`   ‚è±Ô∏è  Real time: ${realElapsedSeconds}s`);\n      console.log(`   ‚ö° Speed: ${speedRatio}x realtime (${(parseFloat(speedRatio) > 1 ? 'faster' : 'slower')} than realtime)`);\n      console.log(`   üíæ Size: ${sizeMB} MB`);\n\n      // Show final stats in UI widget\n      this._showFinalStats({\n        videoDuration: videoDurationSeconds,\n        frameCount,\n        fps: this.options.fps,\n        realTime: realElapsedSeconds,\n        speedRatio,\n        sizeMB\n      });\n\n      this._updateStatus(`‚úÖ Complete! ${sizeMB} MB`, 'success');\n      this.options.onComplete(blob, frameCount);\n    } finally {\n      // Always cleanup encoder\n      if (encoder) {\n        if (encoder.destroy) {\n          encoder.destroy(); // WebM encoder\n          console.log('WebM encoder destroyed');\n        } else if (encoder.delete) {\n          encoder.delete(); // MP4 encoder\n          console.log('MP4 encoder deleted');\n        }\n      }\n      this._encoder = null; // Clear reference\n      this._recordingParams = null; // Clear recording params\n\n      // Clear recording flag to allow marker updates again\n      this._isRecording = false;\n      console.log('[Recording] üîì Recording flag CLEARED - marker updates enabled');\n\n      // Remove temporary WebGL layer (no longer needed)\n      this._removeWaypointsWebGLLayer();\n\n      // Restore waypoint markers visibility\n      this._showWaypointMarkers();\n    }\n  }\n\n  _getResolution() {\n    const resolutions = {\n      auto: null,\n      hd: { width: 1280, height: 720 },\n      fullhd: { width: 1920, height: 1080 },\n      '4k': { width: 3840, height: 2160 },\n      '8k': { width: 7680, height: 4320 }\n    };\n\n    // Handle 'auto' resolution\n    if (this.options.resolution === 'auto') {\n      const container = this._map.getContainer();\n      return {\n        width: Math.floor(container.offsetWidth / 16) * 16,\n        height: Math.floor(container.offsetHeight / 16) * 16\n      };\n    }\n\n    // Handle custom resolution (object with width/height)\n    if (typeof this.options.resolution === 'object' && this.options.resolution.width) {\n      return {\n        width: Math.floor(this.options.resolution.width / 16) * 16,\n        height: Math.floor(this.options.resolution.height / 16) * 16\n      };\n    }\n\n    // Handle preset resolutions\n    const res = resolutions[this.options.resolution] || resolutions.fullhd;\n    return {\n      width: Math.floor(res.width / 16) * 16,\n      height: Math.floor(res.height / 16) * 16\n    };\n  }\n}\n\n// Version number (automatically injected from package.json during build)\n// @ts-ignore - __VERSION__ is replaced at build time\nVideoExportControl.version = __VERSION__;\n\n// Auto-register with MapLibre if available\nif (typeof window !== 'undefined' && window.maplibregl) {\n  // @ts-ignore - Dynamically adding VideoExportControl to maplibregl global\n  window.maplibregl.VideoExportControl = VideoExportControl;\n}\n\nexport { VideoExportControl as default };\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport function assert(x) {\n    if (!x) {\n        throw new Error('Assertion failed.');\n    }\n}\nexport const normalizeRotation = (rotation) => {\n    const mappedRotation = (rotation % 360 + 360) % 360;\n    if (mappedRotation === 0 || mappedRotation === 90 || mappedRotation === 180 || mappedRotation === 270) {\n        return mappedRotation;\n    }\n    else {\n        throw new Error(`Invalid rotation ${rotation}.`);\n    }\n};\nexport const last = (arr) => {\n    return arr && arr[arr.length - 1];\n};\nexport const isU32 = (value) => {\n    return value >= 0 && value < 2 ** 32;\n};\nexport class Bitstream {\n    constructor(bytes) {\n        this.bytes = bytes;\n        /** Current offset in bits. */\n        this.pos = 0;\n    }\n    seekToByte(byteOffset) {\n        this.pos = 8 * byteOffset;\n    }\n    readBit() {\n        const byteIndex = Math.floor(this.pos / 8);\n        const byte = this.bytes[byteIndex] ?? 0;\n        const bitIndex = 0b111 - (this.pos & 0b111);\n        const bit = (byte & (1 << bitIndex)) >> bitIndex;\n        this.pos++;\n        return bit;\n    }\n    readBits(n) {\n        if (n === 1) {\n            return this.readBit();\n        }\n        let result = 0;\n        for (let i = 0; i < n; i++) {\n            result <<= 1;\n            result |= this.readBit();\n        }\n        return result;\n    }\n    writeBits(n, value) {\n        const end = this.pos + n;\n        for (let i = this.pos; i < end; i++) {\n            const byteIndex = Math.floor(i / 8);\n            let byte = this.bytes[byteIndex];\n            const bitIndex = 0b111 - (i & 0b111);\n            byte &= ~(1 << bitIndex);\n            byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n            this.bytes[byteIndex] = byte;\n        }\n        this.pos = end;\n    }\n    ;\n    readAlignedByte() {\n        // Ensure we're byte-aligned\n        if (this.pos % 8 !== 0) {\n            throw new Error('Bitstream is not byte-aligned.');\n        }\n        const byteIndex = this.pos / 8;\n        const byte = this.bytes[byteIndex] ?? 0;\n        this.pos += 8;\n        return byte;\n    }\n    skipBits(n) {\n        this.pos += n;\n    }\n    getBitsLeft() {\n        return this.bytes.length * 8 - this.pos;\n    }\n    clone() {\n        const clone = new Bitstream(this.bytes);\n        clone.pos = this.pos;\n        return clone;\n    }\n}\n/** Reads an exponential-Golomb universal code from a Bitstream.  */\nexport const readExpGolomb = (bitstream) => {\n    let leadingZeroBits = 0;\n    while (bitstream.readBits(1) === 0 && leadingZeroBits < 32) {\n        leadingZeroBits++;\n    }\n    if (leadingZeroBits >= 32) {\n        throw new Error('Invalid exponential-Golomb code.');\n    }\n    const result = (1 << leadingZeroBits) - 1 + bitstream.readBits(leadingZeroBits);\n    return result;\n};\n/** Reads a signed exponential-Golomb universal code from a Bitstream. */\nexport const readSignedExpGolomb = (bitstream) => {\n    const codeNum = readExpGolomb(bitstream);\n    return ((codeNum & 1) === 0)\n        ? -(codeNum >> 1)\n        : ((codeNum + 1) >> 1);\n};\nexport const writeBits = (bytes, start, end, value) => {\n    for (let i = start; i < end; i++) {\n        const byteIndex = Math.floor(i / 8);\n        let byte = bytes[byteIndex];\n        const bitIndex = 0b111 - (i & 0b111);\n        byte &= ~(1 << bitIndex);\n        byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n        bytes[byteIndex] = byte;\n    }\n};\nexport const toUint8Array = (source) => {\n    if (source.constructor === Uint8Array) { // We want a true Uint8Array, not something that extends it like Buffer\n        return source;\n    }\n    else if (source instanceof ArrayBuffer) {\n        return new Uint8Array(source);\n    }\n    else {\n        return new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    }\n};\nexport const toDataView = (source) => {\n    if (source.constructor === DataView) {\n        return source;\n    }\n    else if (source instanceof ArrayBuffer) {\n        return new DataView(source);\n    }\n    else {\n        return new DataView(source.buffer, source.byteOffset, source.byteLength);\n    }\n};\nexport const textDecoder = new TextDecoder();\nexport const textEncoder = new TextEncoder();\nexport const isIso88591Compatible = (text) => {\n    for (let i = 0; i < text.length; i++) {\n        const code = text.charCodeAt(i);\n        if (code > 255) {\n            return false;\n        }\n    }\n    return true;\n};\nconst invertObject = (object) => {\n    return Object.fromEntries(Object.entries(object).map(([key, value]) => [value, key]));\n};\n// For the color space mappings, see Rec. ITU-T H.273.\nexport const COLOR_PRIMARIES_MAP = {\n    bt709: 1, // ITU-R BT.709\n    bt470bg: 5, // ITU-R BT.470BG\n    smpte170m: 6, // ITU-R BT.601 525 - SMPTE 170M\n    bt2020: 9, // ITU-R BT.202\n    smpte432: 12, // SMPTE EG 432-1\n};\nexport const COLOR_PRIMARIES_MAP_INVERSE = invertObject(COLOR_PRIMARIES_MAP);\nexport const TRANSFER_CHARACTERISTICS_MAP = {\n    'bt709': 1, // ITU-R BT.709\n    'smpte170m': 6, // SMPTE 170M\n    'linear': 8, // Linear transfer characteristics\n    'iec61966-2-1': 13, // IEC 61966-2-1\n    'pq': 16, // Rec. ITU-R BT.2100-2 perceptual quantization (PQ) system\n    'hlg': 18, // Rec. ITU-R BT.2100-2 hybrid loggamma (HLG) system\n};\nexport const TRANSFER_CHARACTERISTICS_MAP_INVERSE = invertObject(TRANSFER_CHARACTERISTICS_MAP);\nexport const MATRIX_COEFFICIENTS_MAP = {\n    'rgb': 0, // Identity\n    'bt709': 1, // ITU-R BT.709\n    'bt470bg': 5, // ITU-R BT.470BG\n    'smpte170m': 6, // SMPTE 170M\n    'bt2020-ncl': 9, // ITU-R BT.2020-2 (non-constant luminance)\n};\nexport const MATRIX_COEFFICIENTS_MAP_INVERSE = invertObject(MATRIX_COEFFICIENTS_MAP);\nexport const colorSpaceIsComplete = (colorSpace) => {\n    return (!!colorSpace\n        && !!colorSpace.primaries\n        && !!colorSpace.transfer\n        && !!colorSpace.matrix\n        && colorSpace.fullRange !== undefined);\n};\nexport const isAllowSharedBufferSource = (x) => {\n    return (x instanceof ArrayBuffer\n        || (typeof SharedArrayBuffer !== 'undefined' && x instanceof SharedArrayBuffer)\n        || ArrayBuffer.isView(x));\n};\nexport class AsyncMutex {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    async acquire() {\n        let resolver;\n        const nextPromise = new Promise((resolve) => {\n            resolver = resolve;\n        });\n        const currentPromiseAlias = this.currentPromise;\n        this.currentPromise = nextPromise;\n        await currentPromiseAlias;\n        return resolver;\n    }\n}\nexport const bytesToHexString = (bytes) => {\n    return [...bytes].map(x => x.toString(16).padStart(2, '0')).join('');\n};\nexport const reverseBitsU32 = (x) => {\n    x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n    x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n    x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n    x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n    return x >>> 0; // Ensure it's treated as an unsigned 32-bit integer\n};\n/** Returns the smallest index i such that val[i] === key, or -1 if no such index exists. */\nexport const binarySearchExact = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + high) >> 1;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal === key) {\n            ans = mid;\n            high = mid - 1; // Continue searching left to find the lowest index\n        }\n        else if (midVal < key) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Returns the largest index i such that val[i] <= key, or -1 if no such index exists. */\nexport const binarySearchLessOrEqual = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + (high - low + 1) / 2) | 0;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal <= key) {\n            ans = mid;\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Assumes the array is already sorted. */\nexport const insertSorted = (arr, item, valueGetter) => {\n    const insertionIndex = binarySearchLessOrEqual(arr, valueGetter(item), valueGetter);\n    arr.splice(insertionIndex + 1, 0, item); // This even behaves correctly for the -1 case\n};\nexport const promiseWithResolvers = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve: resolve, reject: reject };\n};\nexport const removeItem = (arr, item) => {\n    const index = arr.indexOf(item);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n};\nexport const findLast = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return arr[i];\n        }\n    }\n    return undefined;\n};\nexport const findLastIndex = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n};\nexport const toAsyncIterator = async function* (source) {\n    if (Symbol.iterator in source) {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.iterator]();\n    }\n    else {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.asyncIterator]();\n    }\n};\nexport const validateAnyIterable = (iterable) => {\n    if (!(Symbol.iterator in iterable) && !(Symbol.asyncIterator in iterable)) {\n        throw new TypeError('Argument must be an iterable or async iterable.');\n    }\n};\nexport const assertNever = (x) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Unexpected value: ${x}`);\n};\nexport const getUint24 = (view, byteOffset, littleEndian) => {\n    const byte1 = view.getUint8(byteOffset);\n    const byte2 = view.getUint8(byteOffset + 1);\n    const byte3 = view.getUint8(byteOffset + 2);\n    if (littleEndian) {\n        return byte1 | (byte2 << 8) | (byte3 << 16);\n    }\n    else {\n        return (byte1 << 16) | (byte2 << 8) | byte3;\n    }\n};\nexport const getInt24 = (view, byteOffset, littleEndian) => {\n    // The left shift pushes the most significant bit into the sign bit region, and the subsequent right shift\n    // then correctly interprets the sign bit.\n    return getUint24(view, byteOffset, littleEndian) << 8 >> 8;\n};\nexport const setUint24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit unsigned range (0 to 16777215)\n    value = value >>> 0; // Convert to unsigned 32-bit\n    value = value & 0xFFFFFF; // Mask to 24 bits\n    if (littleEndian) {\n        view.setUint8(byteOffset, value & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, (value >>> 16) & 0xFF);\n    }\n    else {\n        view.setUint8(byteOffset, (value >>> 16) & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, value & 0xFF);\n    }\n};\nexport const setInt24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit signed range (-8388608 to 8388607)\n    value = clamp(value, -8388608, 8388607);\n    // Convert negative values to their 24-bit representation\n    if (value < 0) {\n        value = (value + 0x1000000) & 0xFFFFFF;\n    }\n    setUint24(view, byteOffset, value, littleEndian);\n};\nexport const setInt64 = (view, byteOffset, value, littleEndian) => {\n    if (littleEndian) {\n        view.setUint32(byteOffset + 0, value, true);\n        view.setInt32(byteOffset + 4, Math.floor(value / 2 ** 32), true);\n    }\n    else {\n        view.setInt32(byteOffset + 0, Math.floor(value / 2 ** 32), true);\n        view.setUint32(byteOffset + 4, value, true);\n    }\n};\n/**\n * Calls a function on each value spat out by an async generator. The reason for writing this manually instead of\n * using a generator function is that the generator function queues return() calls - here, we forward them immediately.\n */\nexport const mapAsyncGenerator = (generator, map) => {\n    return {\n        async next() {\n            const result = await generator.next();\n            if (result.done) {\n                return { value: undefined, done: true };\n            }\n            else {\n                return { value: map(result.value), done: false };\n            }\n        },\n        return() {\n            return generator.return();\n        },\n        throw(error) {\n            return generator.throw(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n};\nexport const clamp = (value, min, max) => {\n    return Math.max(min, Math.min(max, value));\n};\nexport const UNDETERMINED_LANGUAGE = 'und';\nexport const roundToPrecision = (value, digits) => {\n    const factor = 10 ** digits;\n    return Math.round(value * factor) / factor;\n};\nexport const roundToMultiple = (value, multiple) => {\n    return Math.round(value / multiple) * multiple;\n};\nexport const ilog = (x) => {\n    let ret = 0;\n    while (x) {\n        ret++;\n        x >>= 1;\n    }\n    return ret;\n};\nconst ISO_639_2_REGEX = /^[a-z]{3}$/;\nexport const isIso639Dash2LanguageCode = (x) => {\n    return ISO_639_2_REGEX.test(x);\n};\n// Since the result will be truncated, add a bit of eps to compensate for floating point errors\nexport const SECOND_TO_MICROSECOND_FACTOR = 1e6 * (1 + Number.EPSILON);\n/**\n * Merges two RequestInit objects with special handling for headers.\n * Headers are merged case-insensitively, but original casing is preserved.\n * init2 headers take precedence and will override case-insensitive matches from init1.\n */\nexport const mergeRequestInit = (init1, init2) => {\n    const merged = { ...init1, ...init2 };\n    // Special handling for headers\n    if (init1.headers || init2.headers) {\n        const headers1 = init1.headers ? normalizeHeaders(init1.headers) : {};\n        const headers2 = init2.headers ? normalizeHeaders(init2.headers) : {};\n        const mergedHeaders = { ...headers1 };\n        // For each header in headers2, check if a case-insensitive match exists in mergedHeaders\n        Object.entries(headers2).forEach(([key2, value2]) => {\n            const existingKey = Object.keys(mergedHeaders).find(key1 => key1.toLowerCase() === key2.toLowerCase());\n            if (existingKey) {\n                delete mergedHeaders[existingKey];\n            }\n            mergedHeaders[key2] = value2;\n        });\n        merged.headers = mergedHeaders;\n    }\n    return merged;\n};\n/** Normalizes HeadersInit to a Record<string, string> format. */\nconst normalizeHeaders = (headers) => {\n    if (headers instanceof Headers) {\n        const result = {};\n        headers.forEach((value, key) => {\n            result[key] = value;\n        });\n        return result;\n    }\n    if (Array.isArray(headers)) {\n        const result = {};\n        headers.forEach(([key, value]) => {\n            result[key] = value;\n        });\n        return result;\n    }\n    return headers;\n};\nexport const retriedFetch = async (fetchFn, url, requestInit, getRetryDelay) => {\n    let attempts = 0;\n    while (true) {\n        try {\n            return await fetchFn(url, requestInit);\n        }\n        catch (error) {\n            attempts++;\n            const retryDelayInSeconds = getRetryDelay(attempts, error, url);\n            if (retryDelayInSeconds === null) {\n                throw error;\n            }\n            console.error('Retrying failed fetch. Error:', error);\n            if (!Number.isFinite(retryDelayInSeconds) || retryDelayInSeconds < 0) {\n                throw new TypeError('Retry delay must be a non-negative finite number.');\n            }\n            if (retryDelayInSeconds > 0) {\n                await new Promise(resolve => setTimeout(resolve, 1000 * retryDelayInSeconds));\n            }\n        }\n    }\n};\nexport const computeRationalApproximation = (x, maxDenominator) => {\n    // Handle negative numbers\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let prevNumerator = 0, prevDenominator = 1;\n    let currNumerator = 1, currDenominator = 0;\n    // Continued fraction algorithm\n    let remainder = x;\n    while (true) {\n        const integer = Math.floor(remainder);\n        // Calculate next convergent\n        const nextNumerator = integer * currNumerator + prevNumerator;\n        const nextDenominator = integer * currDenominator + prevDenominator;\n        if (nextDenominator > maxDenominator) {\n            return {\n                numerator: sign * currNumerator,\n                denominator: currDenominator,\n            };\n        }\n        prevNumerator = currNumerator;\n        prevDenominator = currDenominator;\n        currNumerator = nextNumerator;\n        currDenominator = nextDenominator;\n        remainder = 1 / (remainder - integer);\n        // Guard against precision issues\n        if (!isFinite(remainder)) {\n            break;\n        }\n    }\n    return {\n        numerator: sign * currNumerator,\n        denominator: currDenominator,\n    };\n};\nexport class CallSerializer {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    call(fn) {\n        return this.currentPromise = this.currentPromise.then(fn);\n    }\n}\nlet isSafariCache = null;\nexport const isSafari = () => {\n    if (isSafariCache !== null) {\n        return isSafariCache;\n    }\n    const result = !!(typeof navigator !== 'undefined'\n        && navigator.vendor?.match(/apple/i)\n        && !navigator.userAgent?.match(/crios/i)\n        && !navigator.userAgent?.match(/fxios/i)\n        && !navigator.userAgent?.match(/Opera|OPT\\//));\n    isSafariCache = result;\n    return result;\n};\nlet isFirefoxCache = null;\nexport const isFirefox = () => {\n    if (isFirefoxCache !== null) {\n        return isFirefoxCache;\n    }\n    return isFirefoxCache = typeof navigator !== 'undefined' && navigator.userAgent?.includes('Firefox');\n};\n/** Acts like `??` except the condition is -1 and not null/undefined. */\nexport const coalesceIndex = (a, b) => {\n    return a !== -1 ? a : b;\n};\nexport const closedIntervalsOverlap = (startA, endA, startB, endB) => {\n    return startA <= endB && startB <= endA;\n};\nexport const keyValueIterator = function* (object) {\n    for (const key in object) {\n        const value = object[key];\n        if (value === undefined) {\n            continue;\n        }\n        yield { key, value };\n    }\n};\nexport const imageMimeTypeToExtension = (mimeType) => {\n    switch (mimeType.toLowerCase()) {\n        case 'image/jpeg':\n        case 'image/jpg':\n            return '.jpg';\n        case 'image/png':\n            return '.png';\n        case 'image/gif':\n            return '.gif';\n        case 'image/webp':\n            return '.webp';\n        case 'image/bmp':\n            return '.bmp';\n        case 'image/svg+xml':\n            return '.svg';\n        case 'image/tiff':\n            return '.tiff';\n        case 'image/avif':\n            return '.avif';\n        case 'image/x-icon':\n        case 'image/vnd.microsoft.icon':\n            return '.ico';\n        default:\n            return null;\n    }\n};\nexport const base64ToBytes = (base64) => {\n    const decoded = atob(base64);\n    const bytes = new Uint8Array(decoded.length);\n    for (let i = 0; i < decoded.length; i++) {\n        bytes[i] = decoded.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const bytesToBase64 = (bytes) => {\n    let string = '';\n    for (let i = 0; i < bytes.length; i++) {\n        string += String.fromCharCode(bytes[i]);\n    }\n    return btoa(string);\n};\nexport const uint8ArraysAreEqual = (a, b) => {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n};\nexport const polyfillSymbolDispose = () => {\n    // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html\n    // @ts-expect-error Readonly\n    Symbol.dispose ??= Symbol('Symbol.dispose');\n};\nexport const isNumber = (x) => {\n    return typeof x === 'number' && !Number.isNaN(x);\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Image data with additional metadata.\n *\n * @group Metadata tags\n * @public\n */\nexport class RichImageData {\n    /** Creates a new {@link RichImageData}. */\n    constructor(\n    /** The raw image data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, etc.) */\n    mimeType) {\n        this.data = data;\n        this.mimeType = mimeType;\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (typeof mimeType !== 'string') {\n            throw new TypeError('mimeType must be a string.');\n        }\n    }\n}\n/**\n * A file attached to a media file.\n *\n * @group Metadata tags\n * @public\n */\nexport class AttachedFile {\n    /** Creates a new {@link AttachedFile}. */\n    constructor(\n    /** The raw file data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, font/ttf, etc.) */\n    mimeType, \n    /** The name of the file. */\n    name, \n    /** A description of the file. */\n    description) {\n        this.data = data;\n        this.mimeType = mimeType;\n        this.name = name;\n        this.description = description;\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (mimeType !== undefined && typeof mimeType !== 'string') {\n            throw new TypeError('mimeType, when provided, must be a string.');\n        }\n        if (name !== undefined && typeof name !== 'string') {\n            throw new TypeError('name, when provided, must be a string.');\n        }\n        if (description !== undefined && typeof description !== 'string') {\n            throw new TypeError('description, when provided, must be a string.');\n        }\n    }\n}\n;\nexport const validateMetadataTags = (tags) => {\n    if (!tags || typeof tags !== 'object') {\n        throw new TypeError('tags must be an object.');\n    }\n    if (tags.title !== undefined && typeof tags.title !== 'string') {\n        throw new TypeError('tags.title, when provided, must be a string.');\n    }\n    if (tags.description !== undefined && typeof tags.description !== 'string') {\n        throw new TypeError('tags.description, when provided, must be a string.');\n    }\n    if (tags.artist !== undefined && typeof tags.artist !== 'string') {\n        throw new TypeError('tags.artist, when provided, must be a string.');\n    }\n    if (tags.album !== undefined && typeof tags.album !== 'string') {\n        throw new TypeError('tags.album, when provided, must be a string.');\n    }\n    if (tags.albumArtist !== undefined && typeof tags.albumArtist !== 'string') {\n        throw new TypeError('tags.albumArtist, when provided, must be a string.');\n    }\n    if (tags.trackNumber !== undefined && (!Number.isInteger(tags.trackNumber) || tags.trackNumber <= 0)) {\n        throw new TypeError('tags.trackNumber, when provided, must be a positive integer.');\n    }\n    if (tags.tracksTotal !== undefined\n        && (!Number.isInteger(tags.tracksTotal) || tags.tracksTotal <= 0)) {\n        throw new TypeError('tags.tracksTotal, when provided, must be a positive integer.');\n    }\n    if (tags.discNumber !== undefined && (!Number.isInteger(tags.discNumber) || tags.discNumber <= 0)) {\n        throw new TypeError('tags.discNumber, when provided, must be a positive integer.');\n    }\n    if (tags.discsTotal !== undefined\n        && (!Number.isInteger(tags.discsTotal) || tags.discsTotal <= 0)) {\n        throw new TypeError('tags.discsTotal, when provided, must be a positive integer.');\n    }\n    if (tags.genre !== undefined && typeof tags.genre !== 'string') {\n        throw new TypeError('tags.genre, when provided, must be a string.');\n    }\n    if (tags.date !== undefined && (!(tags.date instanceof Date) || Number.isNaN(tags.date.getTime()))) {\n        throw new TypeError('tags.date, when provided, must be a valid Date.');\n    }\n    if (tags.lyrics !== undefined && typeof tags.lyrics !== 'string') {\n        throw new TypeError('tags.lyrics, when provided, must be a string.');\n    }\n    if (tags.images !== undefined) {\n        if (!Array.isArray(tags.images)) {\n            throw new TypeError('tags.images, when provided, must be an array.');\n        }\n        for (const image of tags.images) {\n            if (!image || typeof image !== 'object') {\n                throw new TypeError('Each image in tags.images must be an object.');\n            }\n            if (!(image.data instanceof Uint8Array)) {\n                throw new TypeError('Each image.data must be a Uint8Array.');\n            }\n            if (typeof image.mimeType !== 'string') {\n                throw new TypeError('Each image.mimeType must be a string.');\n            }\n            if (!['coverFront', 'coverBack', 'unknown'].includes(image.kind)) {\n                throw new TypeError('Each image.kind must be \\'coverFront\\', \\'coverBack\\', or \\'unknown\\'.');\n            }\n        }\n    }\n    if (tags.comment !== undefined && typeof tags.comment !== 'string') {\n        throw new TypeError('tags.comment, when provided, must be a string.');\n    }\n    if (tags.raw !== undefined) {\n        if (!tags.raw || typeof tags.raw !== 'object') {\n            throw new TypeError('tags.raw, when provided, must be an object.');\n        }\n        for (const value of Object.values(tags.raw)) {\n            if (value !== null\n                && typeof value !== 'string'\n                && !(value instanceof Uint8Array)\n                && !(value instanceof RichImageData)\n                && !(value instanceof AttachedFile)) {\n                throw new TypeError('Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.');\n            }\n        }\n    }\n};\nexport const metadataTagsAreEmpty = (tags) => {\n    return tags.title === undefined\n        && tags.description === undefined\n        && tags.artist === undefined\n        && tags.album === undefined\n        && tags.albumArtist === undefined\n        && tags.trackNumber === undefined\n        && tags.tracksTotal === undefined\n        && tags.discNumber === undefined\n        && tags.discsTotal === undefined\n        && tags.genre === undefined\n        && tags.date === undefined\n        && tags.lyrics === undefined\n        && (!tags.images || tags.images.length === 0)\n        && tags.comment === undefined\n        && (tags.raw === undefined || Object.keys(tags.raw).length === 0);\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, assert, bytesToHexString, isAllowSharedBufferSource, last, reverseBitsU32, toDataView, } from './misc.js';\n/**\n * List of known video codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const VIDEO_CODECS = [\n    'avc',\n    'hevc',\n    'vp9',\n    'av1',\n    'vp8',\n];\n/**\n * List of known PCM (uncompressed) audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const PCM_AUDIO_CODECS = [\n    'pcm-s16', // We don't prefix 'le' so we're compatible with the WebCodecs-registered PCM codec strings\n    'pcm-s16be',\n    'pcm-s24',\n    'pcm-s24be',\n    'pcm-s32',\n    'pcm-s32be',\n    'pcm-f32',\n    'pcm-f32be',\n    'pcm-f64',\n    'pcm-f64be',\n    'pcm-u8',\n    'pcm-s8',\n    'ulaw',\n    'alaw',\n];\n/**\n * List of known compressed audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const NON_PCM_AUDIO_CODECS = [\n    'aac',\n    'opus',\n    'mp3',\n    'vorbis',\n    'flac',\n];\n/**\n * List of known audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const AUDIO_CODECS = [\n    ...NON_PCM_AUDIO_CODECS,\n    ...PCM_AUDIO_CODECS,\n];\n/**\n * List of known subtitle codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const SUBTITLE_CODECS = [\n    'webvtt',\n]; // TODO add the rest\n// https://en.wikipedia.org/wiki/Advanced_Video_Coding\nconst AVC_LEVEL_TABLE = [\n    { maxMacroblocks: 99, maxBitrate: 64000, level: 0x0A }, // Level 1\n    { maxMacroblocks: 396, maxBitrate: 192000, level: 0x0B }, // Level 1.1\n    { maxMacroblocks: 396, maxBitrate: 384000, level: 0x0C }, // Level 1.2\n    { maxMacroblocks: 396, maxBitrate: 768000, level: 0x0D }, // Level 1.3\n    { maxMacroblocks: 396, maxBitrate: 2000000, level: 0x14 }, // Level 2\n    { maxMacroblocks: 792, maxBitrate: 4000000, level: 0x15 }, // Level 2.1\n    { maxMacroblocks: 1620, maxBitrate: 4000000, level: 0x16 }, // Level 2.2\n    { maxMacroblocks: 1620, maxBitrate: 10000000, level: 0x1E }, // Level 3\n    { maxMacroblocks: 3600, maxBitrate: 14000000, level: 0x1F }, // Level 3.1\n    { maxMacroblocks: 5120, maxBitrate: 20000000, level: 0x20 }, // Level 3.2\n    { maxMacroblocks: 8192, maxBitrate: 20000000, level: 0x28 }, // Level 4\n    { maxMacroblocks: 8192, maxBitrate: 50000000, level: 0x29 }, // Level 4.1\n    { maxMacroblocks: 8704, maxBitrate: 50000000, level: 0x2A }, // Level 4.2\n    { maxMacroblocks: 22080, maxBitrate: 135000000, level: 0x32 }, // Level 5\n    { maxMacroblocks: 36864, maxBitrate: 240000000, level: 0x33 }, // Level 5.1\n    { maxMacroblocks: 36864, maxBitrate: 240000000, level: 0x34 }, // Level 5.2\n    { maxMacroblocks: 139264, maxBitrate: 240000000, level: 0x3C }, // Level 6\n    { maxMacroblocks: 139264, maxBitrate: 480000000, level: 0x3D }, // Level 6.1\n    { maxMacroblocks: 139264, maxBitrate: 800000000, level: 0x3E }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding\nconst HEVC_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 128000, tier: 'L', level: 30 }, // Level 1 (Low Tier)\n    { maxPictureSize: 122880, maxBitrate: 1500000, tier: 'L', level: 60 }, // Level 2 (Low Tier)\n    { maxPictureSize: 245760, maxBitrate: 3000000, tier: 'L', level: 63 }, // Level 2.1 (Low Tier)\n    { maxPictureSize: 552960, maxBitrate: 6000000, tier: 'L', level: 90 }, // Level 3 (Low Tier)\n    { maxPictureSize: 983040, maxBitrate: 10000000, tier: 'L', level: 93 }, // Level 3.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 12000000, tier: 'L', level: 120 }, // Level 4 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 30000000, tier: 'H', level: 120 }, // Level 4 (High Tier)\n    { maxPictureSize: 2228224, maxBitrate: 20000000, tier: 'L', level: 123 }, // Level 4.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 50000000, tier: 'H', level: 123 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 25000000, tier: 'L', level: 150 }, // Level 5 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 150 }, // Level 5 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'L', level: 153 }, // Level 5.1 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 153 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'L', level: 156 }, // Level 5.2 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 156 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'L', level: 180 }, // Level 6 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 180 }, // Level 6 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 120000000, tier: 'L', level: 183 }, // Level 6.1 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 183 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'L', level: 186 }, // Level 6.2 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 186 }, // Level 6.2 (High Tier)\n];\n// https://en.wikipedia.org/wiki/VP9\nexport const VP9_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 200000, level: 10 }, // Level 1\n    { maxPictureSize: 73728, maxBitrate: 800000, level: 11 }, // Level 1.1\n    { maxPictureSize: 122880, maxBitrate: 1800000, level: 20 }, // Level 2\n    { maxPictureSize: 245760, maxBitrate: 3600000, level: 21 }, // Level 2.1\n    { maxPictureSize: 552960, maxBitrate: 7200000, level: 30 }, // Level 3\n    { maxPictureSize: 983040, maxBitrate: 12000000, level: 31 }, // Level 3.1\n    { maxPictureSize: 2228224, maxBitrate: 18000000, level: 40 }, // Level 4\n    { maxPictureSize: 2228224, maxBitrate: 30000000, level: 41 }, // Level 4.1\n    { maxPictureSize: 8912896, maxBitrate: 60000000, level: 50 }, // Level 5\n    { maxPictureSize: 8912896, maxBitrate: 120000000, level: 51 }, // Level 5.1\n    { maxPictureSize: 8912896, maxBitrate: 180000000, level: 52 }, // Level 5.2\n    { maxPictureSize: 35651584, maxBitrate: 180000000, level: 60 }, // Level 6\n    { maxPictureSize: 35651584, maxBitrate: 240000000, level: 61 }, // Level 6.1\n    { maxPictureSize: 35651584, maxBitrate: 480000000, level: 62 }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/AV1\nconst AV1_LEVEL_TABLE = [\n    { maxPictureSize: 147456, maxBitrate: 1500000, tier: 'M', level: 0 }, // Level 2.0 (Main Tier)\n    { maxPictureSize: 278784, maxBitrate: 3000000, tier: 'M', level: 1 }, // Level 2.1 (Main Tier)\n    { maxPictureSize: 665856, maxBitrate: 6000000, tier: 'M', level: 4 }, // Level 3.0 (Main Tier)\n    { maxPictureSize: 1065024, maxBitrate: 10000000, tier: 'M', level: 5 }, // Level 3.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 12000000, tier: 'M', level: 8 }, // Level 4.0 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 30000000, tier: 'H', level: 8 }, // Level 4.0 (High Tier)\n    { maxPictureSize: 2359296, maxBitrate: 20000000, tier: 'M', level: 9 }, // Level 4.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 50000000, tier: 'H', level: 9 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 30000000, tier: 'M', level: 12 }, // Level 5.0 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 12 }, // Level 5.0 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'M', level: 13 }, // Level 5.1 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 13 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'M', level: 14 }, // Level 5.2 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 14 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 15 }, // Level 5.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 15 }, // Level 5.3 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 16 }, // Level 6.0 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 16 }, // Level 6.0 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 100000000, tier: 'M', level: 17 }, // Level 6.1 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 17 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 18 }, // Level 6.2 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 18 }, // Level 6.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 19 }, // Level 6.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 19 }, // Level 6.3 (High Tier)\n];\nconst VP9_DEFAULT_SUFFIX = '.01.01.01.01.00';\nconst AV1_DEFAULT_SUFFIX = '.0.110.01.01.01.0';\nexport const buildVideoCodecString = (codec, width, height, bitrate) => {\n    if (codec === 'avc') {\n        const profileIndication = 0x64; // High Profile\n        const totalMacroblocks = Math.ceil(width / 16) * Math.ceil(height / 16);\n        // Determine the level based on the table\n        const levelInfo = AVC_LEVEL_TABLE.find(level => totalMacroblocks <= level.maxMacroblocks && bitrate <= level.maxBitrate) ?? last(AVC_LEVEL_TABLE);\n        const levelIndication = levelInfo ? levelInfo.level : 0;\n        const hexProfileIndication = profileIndication.toString(16).padStart(2, '0');\n        const hexProfileCompatibility = '00';\n        const hexLevelIndication = levelIndication.toString(16).padStart(2, '0');\n        return `avc1.${hexProfileIndication}${hexProfileCompatibility}${hexLevelIndication}`;\n    }\n    else if (codec === 'hevc') {\n        const profilePrefix = ''; // Profile space 0\n        const profileIdc = 1; // Main Profile\n        const compatibilityFlags = '6'; // Taken from the example in ISO 14496-15\n        const pictureSize = width * height;\n        const levelInfo = HEVC_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(HEVC_LEVEL_TABLE);\n        const constraintFlags = 'B0'; // Progressive source flag\n        return 'hev1.'\n            + `${profilePrefix}${profileIdc}.`\n            + `${compatibilityFlags}.`\n            + `${levelInfo.tier}${levelInfo.level}.`\n            + `${constraintFlags}`;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        const profile = '00'; // Profile 0\n        const pictureSize = width * height;\n        const levelInfo = VP9_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(VP9_LEVEL_TABLE);\n        const bitDepth = '08'; // 8-bit\n        return `vp09.${profile}.${levelInfo.level.toString().padStart(2, '0')}.${bitDepth}`;\n    }\n    else if (codec === 'av1') {\n        const profile = 0; // Main Profile, single digit\n        const pictureSize = width * height;\n        const levelInfo = AV1_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(AV1_LEVEL_TABLE);\n        const level = levelInfo.level.toString().padStart(2, '0');\n        const bitDepth = '08'; // 8-bit\n        return `av01.${profile}.${level}${levelInfo.tier}.${bitDepth}`;\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const generateVp9CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://www.webmproject.org/docs/container/#vp9-codec-feature-metadata-codecprivate\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1;\n    return [\n        1, 1, profile,\n        2, 1, level,\n        3, 1, bitDepth,\n        4, 1, chromaSubsampling,\n    ];\n};\nexport const generateAv1CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://aomediacodec.github.io/av1-isobmff/\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const marker = 1;\n    const version = 1;\n    const firstByte = (marker << 7) + version;\n    const profile = Number(parts[1]);\n    const levelAndTier = parts[2];\n    const level = Number(levelAndTier.slice(0, -1));\n    const secondByte = (profile << 5) + level;\n    const tier = levelAndTier.slice(-1) === 'H' ? 1 : 0;\n    const bitDepth = Number(parts[3]);\n    const highBitDepth = bitDepth === 8 ? 0 : 1;\n    const twelveBit = 0;\n    const monochrome = parts[4] ? Number(parts[4]) : 0;\n    const chromaSubsamplingX = parts[5] ? Number(parts[5][0]) : 1;\n    const chromaSubsamplingY = parts[5] ? Number(parts[5][1]) : 1;\n    const chromaSamplePosition = parts[5] ? Number(parts[5][2]) : 0; // CSP_UNKNOWN\n    const thirdByte = (tier << 7)\n        + (highBitDepth << 6)\n        + (twelveBit << 5)\n        + (monochrome << 4)\n        + (chromaSubsamplingX << 3)\n        + (chromaSubsamplingY << 2)\n        + chromaSamplePosition;\n    const initialPresentationDelayPresent = 0; // Should be fine\n    const fourthByte = initialPresentationDelayPresent;\n    return [firstByte, secondByte, thirdByte, fourthByte];\n};\nexport const extractVideoCodecString = (trackInfo) => {\n    const { codec, codecDescription, colorSpace, avcCodecInfo, hevcCodecInfo, vp9CodecInfo, av1CodecInfo } = trackInfo;\n    if (codec === 'avc') {\n        if (avcCodecInfo) {\n            const bytes = new Uint8Array([\n                avcCodecInfo.avcProfileIndication,\n                avcCodecInfo.profileCompatibility,\n                avcCodecInfo.avcLevelIndication,\n            ]);\n            return `avc1.${bytesToHexString(bytes)}`;\n        }\n        if (!codecDescription || codecDescription.byteLength < 4) {\n            throw new TypeError('AVC decoder description is not provided or is not at least 4 bytes long.');\n        }\n        return `avc1.${bytesToHexString(codecDescription.subarray(1, 4))}`;\n    }\n    else if (codec === 'hevc') {\n        let generalProfileSpace;\n        let generalProfileIdc;\n        let compatibilityFlags;\n        let generalTierFlag;\n        let generalLevelIdc;\n        let constraintFlags;\n        if (hevcCodecInfo) {\n            generalProfileSpace = hevcCodecInfo.generalProfileSpace;\n            generalProfileIdc = hevcCodecInfo.generalProfileIdc;\n            compatibilityFlags = reverseBitsU32(hevcCodecInfo.generalProfileCompatibilityFlags);\n            generalTierFlag = hevcCodecInfo.generalTierFlag;\n            generalLevelIdc = hevcCodecInfo.generalLevelIdc;\n            constraintFlags = [...hevcCodecInfo.generalConstraintIndicatorFlags];\n        }\n        else {\n            if (!codecDescription || codecDescription.byteLength < 23) {\n                throw new TypeError('HEVC decoder description is not provided or is not at least 23 bytes long.');\n            }\n            const view = toDataView(codecDescription);\n            const profileByte = view.getUint8(1);\n            generalProfileSpace = (profileByte >> 6) & 0x03;\n            generalProfileIdc = profileByte & 0x1F;\n            compatibilityFlags = reverseBitsU32(view.getUint32(2));\n            generalTierFlag = (profileByte >> 5) & 0x01;\n            generalLevelIdc = view.getUint8(12);\n            constraintFlags = [];\n            for (let i = 0; i < 6; i++) {\n                constraintFlags.push(view.getUint8(6 + i));\n            }\n        }\n        let codecString = 'hev1.';\n        codecString += ['', 'A', 'B', 'C'][generalProfileSpace] + generalProfileIdc;\n        codecString += '.';\n        codecString += compatibilityFlags.toString(16).toUpperCase();\n        codecString += '.';\n        codecString += generalTierFlag === 0 ? 'L' : 'H';\n        codecString += generalLevelIdc;\n        while (constraintFlags.length > 0 && constraintFlags[constraintFlags.length - 1] === 0) {\n            constraintFlags.pop();\n        }\n        if (constraintFlags.length > 0) {\n            codecString += '.';\n            codecString += constraintFlags.map(x => x.toString(16).toUpperCase()).join('.');\n        }\n        return codecString;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        if (!vp9CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `vp09.00.${level.toString().padStart(2, '0')}.08`;\n        }\n        const profile = vp9CodecInfo.profile.toString().padStart(2, '0');\n        const level = vp9CodecInfo.level.toString().padStart(2, '0');\n        const bitDepth = vp9CodecInfo.bitDepth.toString().padStart(2, '0');\n        const chromaSubsampling = vp9CodecInfo.chromaSubsampling.toString().padStart(2, '0');\n        const colourPrimaries = vp9CodecInfo.colourPrimaries.toString().padStart(2, '0');\n        const transferCharacteristics = vp9CodecInfo.transferCharacteristics.toString().padStart(2, '0');\n        const matrixCoefficients = vp9CodecInfo.matrixCoefficients.toString().padStart(2, '0');\n        const videoFullRangeFlag = vp9CodecInfo.videoFullRangeFlag.toString().padStart(2, '0');\n        let string = `vp09.${profile}.${level}.${bitDepth}.${chromaSubsampling}`;\n        string += `.${colourPrimaries}.${transferCharacteristics}.${matrixCoefficients}.${videoFullRangeFlag}`;\n        if (string.endsWith(VP9_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -VP9_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    else if (codec === 'av1') {\n        if (!av1CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `av01.0.${level.toString().padStart(2, '0')}M.08`;\n        }\n        // https://aomediacodec.github.io/av1-isobmff/#codecsparam\n        const profile = av1CodecInfo.profile; // Single digit\n        const level = av1CodecInfo.level.toString().padStart(2, '0');\n        const tier = av1CodecInfo.tier ? 'H' : 'M';\n        const bitDepth = av1CodecInfo.bitDepth.toString().padStart(2, '0');\n        const monochrome = av1CodecInfo.monochrome ? '1' : '0';\n        const chromaSubsampling = 100 * av1CodecInfo.chromaSubsamplingX\n            + 10 * av1CodecInfo.chromaSubsamplingY\n            + 1 * (av1CodecInfo.chromaSubsamplingX && av1CodecInfo.chromaSubsamplingY\n                ? av1CodecInfo.chromaSamplePosition\n                : 0);\n        // The defaults are 1 (ITU-R BT.709)\n        const colorPrimaries = colorSpace?.primaries ? COLOR_PRIMARIES_MAP[colorSpace.primaries] : 1;\n        const transferCharacteristics = colorSpace?.transfer ? TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer] : 1;\n        const matrixCoefficients = colorSpace?.matrix ? MATRIX_COEFFICIENTS_MAP[colorSpace.matrix] : 1;\n        const videoFullRangeFlag = colorSpace?.fullRange ? 1 : 0;\n        let string = `av01.${profile}.${level}${tier}.${bitDepth}`;\n        string += `.${monochrome}.${chromaSubsampling.toString().padStart(3, '0')}`;\n        string += `.${colorPrimaries.toString().padStart(2, '0')}`;\n        string += `.${transferCharacteristics.toString().padStart(2, '0')}`;\n        string += `.${matrixCoefficients.toString().padStart(2, '0')}`;\n        string += `.${videoFullRangeFlag}`;\n        if (string.endsWith(AV1_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -AV1_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const buildAudioCodecString = (codec, numberOfChannels, sampleRate) => {\n    if (codec === 'aac') {\n        // If stereo or higher channels and lower sample rate, likely using HE-AAC v2 with PS\n        if (numberOfChannels >= 2 && sampleRate <= 24000) {\n            return 'mp4a.40.29'; // HE-AAC v2 (AAC LC + SBR + PS)\n        }\n        // If sample rate is low, likely using HE-AAC v1 with SBR\n        if (sampleRate <= 24000) {\n            return 'mp4a.40.5'; // HE-AAC v1 (AAC LC + SBR)\n        }\n        // Default to standard AAC-LC for higher sample rates\n        return 'mp4a.40.2'; // AAC-LC\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const extractAudioCodecString = (trackInfo) => {\n    const { codec, codecDescription, aacCodecInfo } = trackInfo;\n    if (codec === 'aac') {\n        if (!aacCodecInfo) {\n            throw new TypeError('AAC codec info must be provided.');\n        }\n        if (aacCodecInfo.isMpeg2) {\n            return 'mp4a.67';\n        }\n        else {\n            const audioSpecificConfig = parseAacAudioSpecificConfig(codecDescription);\n            return `mp4a.40.${audioSpecificConfig.objectType}`;\n        }\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (codec && PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const aacFrequencyTable = [\n    96000, 88200, 64000, 48000, 44100, 32000,\n    24000, 22050, 16000, 12000, 11025, 8000, 7350,\n];\nexport const aacChannelMap = [-1, 1, 2, 3, 4, 5, 6, 8];\nexport const parseAacAudioSpecificConfig = (bytes) => {\n    if (!bytes || bytes.byteLength < 2) {\n        throw new TypeError('AAC description must be at least 2 bytes long.');\n    }\n    const bitstream = new Bitstream(bytes);\n    let objectType = bitstream.readBits(5);\n    if (objectType === 31) {\n        objectType = 32 + bitstream.readBits(6);\n    }\n    const frequencyIndex = bitstream.readBits(4);\n    let sampleRate = null;\n    if (frequencyIndex === 15) {\n        sampleRate = bitstream.readBits(24);\n    }\n    else {\n        if (frequencyIndex < aacFrequencyTable.length) {\n            sampleRate = aacFrequencyTable[frequencyIndex];\n        }\n    }\n    const channelConfiguration = bitstream.readBits(4);\n    let numberOfChannels = null;\n    if (channelConfiguration >= 1 && channelConfiguration <= 7) {\n        numberOfChannels = aacChannelMap[channelConfiguration];\n    }\n    return {\n        objectType,\n        frequencyIndex,\n        sampleRate,\n        channelConfiguration,\n        numberOfChannels,\n    };\n};\nexport const OPUS_SAMPLE_RATE = 48_000;\nconst PCM_CODEC_REGEX = /^pcm-([usf])(\\d+)+(be)?$/;\nexport const parsePcmCodec = (codec) => {\n    assert(PCM_AUDIO_CODECS.includes(codec));\n    if (codec === 'ulaw') {\n        return { dataType: 'ulaw', sampleSize: 1, littleEndian: true, silentValue: 255 };\n    }\n    else if (codec === 'alaw') {\n        return { dataType: 'alaw', sampleSize: 1, littleEndian: true, silentValue: 213 };\n    }\n    const match = PCM_CODEC_REGEX.exec(codec);\n    assert(match);\n    let dataType;\n    if (match[1] === 'u') {\n        dataType = 'unsigned';\n    }\n    else if (match[1] === 's') {\n        dataType = 'signed';\n    }\n    else {\n        dataType = 'float';\n    }\n    const sampleSize = (Number(match[2]) / 8);\n    const littleEndian = match[3] !== 'be';\n    const silentValue = codec === 'pcm-u8' ? 2 ** 7 : 0;\n    return { dataType, sampleSize, littleEndian, silentValue };\n};\nexport const inferCodecFromCodecString = (codecString) => {\n    // Video codecs\n    if (codecString.startsWith('avc1') || codecString.startsWith('avc3')) {\n        return 'avc';\n    }\n    else if (codecString.startsWith('hev1') || codecString.startsWith('hvc1')) {\n        return 'hevc';\n    }\n    else if (codecString === 'vp8') {\n        return 'vp8';\n    }\n    else if (codecString.startsWith('vp09')) {\n        return 'vp9';\n    }\n    else if (codecString.startsWith('av01')) {\n        return 'av1';\n    }\n    // Audio codecs\n    if (codecString.startsWith('mp4a.40') || codecString === 'mp4a.67') {\n        return 'aac';\n    }\n    else if (codecString === 'mp3'\n        || codecString === 'mp4a.69'\n        || codecString === 'mp4a.6B'\n        || codecString === 'mp4a.6b') {\n        return 'mp3';\n    }\n    else if (codecString === 'opus') {\n        return 'opus';\n    }\n    else if (codecString === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codecString === 'flac') {\n        return 'flac';\n    }\n    else if (codecString === 'ulaw') {\n        return 'ulaw';\n    }\n    else if (codecString === 'alaw') {\n        return 'alaw';\n    }\n    else if (PCM_CODEC_REGEX.test(codecString)) {\n        return codecString;\n    }\n    // Subtitle codecs\n    if (codecString === 'webvtt') {\n        return 'webvtt';\n    }\n    return null;\n};\nexport const getVideoEncoderConfigExtension = (codec) => {\n    if (codec === 'avc') {\n        return {\n            avc: {\n                format: 'avc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    else if (codec === 'hevc') {\n        return {\n            hevc: {\n                format: 'hevc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    return {};\n};\nexport const getAudioEncoderConfigExtension = (codec) => {\n    if (codec === 'aac') {\n        return {\n            aac: {\n                format: 'aac', // Ensure the format is not ADTS\n            },\n        };\n    }\n    else if (codec === 'opus') {\n        return {\n            opus: {\n                format: 'opus',\n            },\n        };\n    }\n    return {};\n};\nconst VALID_VIDEO_CODEC_STRING_PREFIXES = ['avc1', 'avc3', 'hev1', 'hvc1', 'vp8', 'vp09', 'av01'];\nconst AVC_CODEC_STRING_REGEX = /^(avc1|avc3)\\.[0-9a-fA-F]{6}$/;\nconst HEVC_CODEC_STRING_REGEX = /^(hev1|hvc1)\\.(?:[ABC]?\\d+)\\.[0-9a-fA-F]{1,8}\\.[LH]\\d+(?:\\.[0-9a-fA-F]{1,2}){0,6}$/;\nconst VP9_CODEC_STRING_REGEX = /^vp09(?:\\.\\d{2}){3}(?:(?:\\.\\d{2}){5})?$/;\nconst AV1_CODEC_STRING_REGEX = /^av01\\.\\d\\.\\d{2}[MH]\\.\\d{2}(?:\\.\\d\\.\\d{3}\\.\\d{2}\\.\\d{2}\\.\\d{2}\\.\\d)?$/;\nexport const validateVideoChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Video chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Video chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Video chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Video chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_VIDEO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedWidth) || metadata.decoderConfig.codedWidth <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedHeight) || metadata.decoderConfig.codedHeight <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.colorSpace !== undefined) {\n        const { colorSpace } = metadata.decoderConfig;\n        if (typeof colorSpace !== 'object') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace, when provided, must be an object.');\n        }\n        const primariesValues = Object.keys(COLOR_PRIMARIES_MAP);\n        if (colorSpace.primaries != null && !primariesValues.includes(colorSpace.primaries)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of`\n                + ` ${primariesValues.join(', ')}.`);\n        }\n        const transferValues = Object.keys(TRANSFER_CHARACTERISTICS_MAP);\n        if (colorSpace.transfer != null && !transferValues.includes(colorSpace.transfer)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of`\n                + ` ${transferValues.join(', ')}.`);\n        }\n        const matrixValues = Object.keys(MATRIX_COEFFICIENTS_MAP);\n        if (colorSpace.matrix != null && !matrixValues.includes(colorSpace.matrix)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of`\n                + ` ${matrixValues.join(', ')}.`);\n        }\n        if (colorSpace.fullRange != null && typeof colorSpace.fullRange !== 'boolean') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('avc1') || metadata.decoderConfig.codec.startsWith('avc3')) {\n        // AVC-specific validation\n        if (!AVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as'\n                + ' specified in Section 3.4 of RFC 6381.');\n        }\n        // `description` may or may not be set, depending on if the format is AVCC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-avc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('hev1') || metadata.decoderConfig.codec.startsWith('hvc1')) {\n        // HEVC-specific validation\n        if (!HEVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as'\n                + ' specified in Section E.3 of ISO 14496-15.');\n        }\n        // `description` may or may not be set, depending on if the format is HEVC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-hevc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp8')) {\n        // VP8-specific validation\n        if (metadata.decoderConfig.codec !== 'vp8') {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be \"vp8\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp09')) {\n        // VP9-specific validation\n        if (!VP9_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://www.webmproject.org/vp9/mp4/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('av01')) {\n        // AV1-specific validation\n        if (!AV1_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://aomediacodec.github.io/av1-isobmff/.');\n        }\n    }\n};\nconst VALID_AUDIO_CODEC_STRING_PREFIXES = ['mp4a', 'mp3', 'opus', 'vorbis', 'flac', 'ulaw', 'alaw', 'pcm'];\nexport const validateAudioChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Audio chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Audio chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Audio chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Audio chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_AUDIO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.sampleRate) || metadata.decoderConfig.sampleRate <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.numberOfChannels) || metadata.decoderConfig.numberOfChannels <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('mp4a')\n        // These three refer to MP3:\n        && metadata.decoderConfig.codec !== 'mp4a.69'\n        && metadata.decoderConfig.codec !== 'mp4a.6B'\n        && metadata.decoderConfig.codec !== 'mp4a.6b') {\n        // AAC-specific validation\n        const validStrings = ['mp4a.40.2', 'mp4a.40.02', 'mp4a.40.5', 'mp4a.40.05', 'mp4a.40.29', 'mp4a.67'];\n        if (!validStrings.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as'\n                + ' specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be'\n                + ' an AudioSpecificConfig as specified in ISO 14496-3.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('mp3') || metadata.decoderConfig.codec.startsWith('mp4a')) {\n        // MP3-specific validation\n        if (metadata.decoderConfig.codec !== 'mp3'\n            && metadata.decoderConfig.codec !== 'mp4a.69'\n            && metadata.decoderConfig.codec !== 'mp4a.6B'\n            && metadata.decoderConfig.codec !== 'mp4a.6b') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be \"mp3\", \"mp4a.69\" or'\n                + ' \"mp4a.6B\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('opus')) {\n        // Opus-specific validation\n        if (metadata.decoderConfig.codec !== 'opus') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be \"opus\".');\n        }\n        if (metadata.decoderConfig.description && metadata.decoderConfig.description.byteLength < 18) {\n            // Description is optional for Opus per-spec, so we shouldn't enforce it\n            throw new TypeError('Audio chunk metadata decoder configuration description, when specified, is expected to be an'\n                + ' Identification Header as specified in Section 5.1 of RFC 7845.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vorbis')) {\n        // Vorbis-specific validation\n        if (metadata.decoderConfig.codec !== 'vorbis') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be \"vorbis\".');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('flac')) {\n        // FLAC-specific validation\n        if (metadata.decoderConfig.codec !== 'flac') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be \"flac\".');\n        }\n        const minDescriptionSize = 4 + 4 + 34; // 'fLaC' + metadata block header + STREAMINFO block\n        if (!metadata.decoderConfig.description || metadata.decoderConfig.description.byteLength < minDescriptionSize) {\n            throw new TypeError('Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('pcm')\n        || metadata.decoderConfig.codec.startsWith('ulaw')\n        || metadata.decoderConfig.codec.startsWith('alaw')) {\n        // PCM-specific validation\n        if (!PCM_AUDIO_CODECS.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM'\n                + ` codecs (${PCM_AUDIO_CODECS.join(', ')}).`);\n        }\n    }\n};\nexport const validateSubtitleMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Subtitle metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Subtitle metadata must be an object.');\n    }\n    if (!metadata.config) {\n        throw new TypeError('Subtitle metadata must include a config object.');\n    }\n    if (typeof metadata.config !== 'object') {\n        throw new TypeError('Subtitle metadata config must be an object.');\n    }\n    if (typeof metadata.config.description !== 'string') {\n        throw new TypeError('Subtitle metadata config description must be a string.');\n    }\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex } from './misc.js';\nexport class Muxer {\n    constructor(output) {\n        this.mutex = new AsyncMutex();\n        /**\n         * This field is used to synchronize multiple MediaStreamTracks. They use the same time coordinate system across\n         * tracks, and to ensure correct audio-video sync, we must use the same offset for all of them. The reason an offset\n         * is needed at all is because the timestamps typically don't start at zero.\n         */\n        this.firstMediaStreamTimestamp = null;\n        this.trackTimestampInfo = new WeakMap();\n        this.output = output;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTrackClose(track) { }\n    validateAndNormalizeTimestamp(track, timestampInSeconds, isKeyFrame) {\n        timestampInSeconds += track.source._timestampOffset;\n        let timestampInfo = this.trackTimestampInfo.get(track);\n        if (!timestampInfo) {\n            if (!isKeyFrame) {\n                throw new Error('First frame must be a key frame.');\n            }\n            timestampInfo = {\n                maxTimestamp: timestampInSeconds,\n                maxTimestampBeforeLastKeyFrame: timestampInSeconds,\n            };\n            this.trackTimestampInfo.set(track, timestampInfo);\n        }\n        if (timestampInSeconds < 0) {\n            throw new Error(`Timestamps must be non-negative (got ${timestampInSeconds}s).`);\n        }\n        if (isKeyFrame) {\n            timestampInfo.maxTimestampBeforeLastKeyFrame = timestampInfo.maxTimestamp;\n        }\n        if (timestampInSeconds < timestampInfo.maxTimestampBeforeLastKeyFrame) {\n            throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous GOP (a GOP begins with a key`\n                + ` frame and ends right before the next key frame). Got ${timestampInSeconds}s, but highest timestamp`\n                + ` is ${timestampInfo.maxTimestampBeforeLastKeyFrame}s.`);\n        }\n        timestampInfo.maxTimestamp = Math.max(timestampInfo.maxTimestamp, timestampInSeconds);\n        return timestampInSeconds;\n    }\n}\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { VP9_LEVEL_TABLE } from './codec.js';\nimport { assert, assertNever, base64ToBytes, Bitstream, bytesToBase64, keyValueIterator, getUint24, last, readExpGolomb, readSignedExpGolomb, textDecoder, textEncoder, toDataView, toUint8Array, } from './misc.js';\n// References for AVC/HEVC code:\n// ISO 14496-15\n// Rec. ITU-T H.264\n// Rec. ITU-T H.265\n// https://stackoverflow.com/questions/24884827\nexport var AvcNalUnitType;\n(function (AvcNalUnitType) {\n    AvcNalUnitType[AvcNalUnitType[\"IDR\"] = 5] = \"IDR\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS\"] = 7] = \"SPS\";\n    AvcNalUnitType[AvcNalUnitType[\"PPS\"] = 8] = \"PPS\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS_EXT\"] = 13] = \"SPS_EXT\";\n})(AvcNalUnitType || (AvcNalUnitType = {}));\nexport var HevcNalUnitType;\n(function (HevcNalUnitType) {\n    HevcNalUnitType[HevcNalUnitType[\"RASL_N\"] = 8] = \"RASL_N\";\n    HevcNalUnitType[HevcNalUnitType[\"RASL_R\"] = 9] = \"RASL_R\";\n    HevcNalUnitType[HevcNalUnitType[\"BLA_W_LP\"] = 16] = \"BLA_W_LP\";\n    HevcNalUnitType[HevcNalUnitType[\"RSV_IRAP_VCL23\"] = 23] = \"RSV_IRAP_VCL23\";\n    HevcNalUnitType[HevcNalUnitType[\"VPS_NUT\"] = 32] = \"VPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SPS_NUT\"] = 33] = \"SPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PPS_NUT\"] = 34] = \"PPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PREFIX_SEI_NUT\"] = 39] = \"PREFIX_SEI_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SUFFIX_SEI_NUT\"] = 40] = \"SUFFIX_SEI_NUT\";\n})(HevcNalUnitType || (HevcNalUnitType = {}));\n/** Finds all NAL units in an AVC packet in Annex B format. */\nexport const findNalUnitsInAnnexB = (packetData) => {\n    const nalUnits = [];\n    let i = 0;\n    while (i < packetData.length) {\n        let startCodePos = -1;\n        let startCodeLength = 0;\n        for (let j = i; j < packetData.length - 3; j++) {\n            // Check for 3-byte start code (0x000001)\n            if (packetData[j] === 0 && packetData[j + 1] === 0 && packetData[j + 2] === 1) {\n                startCodePos = j;\n                startCodeLength = 3;\n                break;\n            }\n            // Check for 4-byte start code (0x00000001)\n            if (j < packetData.length - 4\n                && packetData[j] === 0\n                && packetData[j + 1] === 0\n                && packetData[j + 2] === 0\n                && packetData[j + 3] === 1) {\n                startCodePos = j;\n                startCodeLength = 4;\n                break;\n            }\n        }\n        if (startCodePos === -1) {\n            break; // No more start codes found\n        }\n        // If this isn't the first start code, extract the previous NAL unit\n        if (i > 0 && startCodePos > i) {\n            const nalData = packetData.subarray(i, startCodePos);\n            if (nalData.length > 0) {\n                nalUnits.push(nalData);\n            }\n        }\n        i = startCodePos + startCodeLength;\n    }\n    // Extract the last NAL unit if there is one\n    if (i < packetData.length) {\n        const nalData = packetData.subarray(i);\n        if (nalData.length > 0) {\n            nalUnits.push(nalData);\n        }\n    }\n    return nalUnits;\n};\n/** Finds all NAL units in an AVC packet in length-prefixed format. */\nconst findNalUnitsInLengthPrefixed = (packetData, lengthSize) => {\n    const nalUnits = [];\n    let offset = 0;\n    const dataView = new DataView(packetData.buffer, packetData.byteOffset, packetData.byteLength);\n    while (offset + lengthSize <= packetData.length) {\n        let nalUnitLength;\n        if (lengthSize === 1) {\n            nalUnitLength = dataView.getUint8(offset);\n        }\n        else if (lengthSize === 2) {\n            nalUnitLength = dataView.getUint16(offset, false);\n        }\n        else if (lengthSize === 3) {\n            nalUnitLength = getUint24(dataView, offset, false);\n        }\n        else if (lengthSize === 4) {\n            nalUnitLength = dataView.getUint32(offset, false);\n        }\n        else {\n            assertNever(lengthSize);\n            assert(false);\n        }\n        offset += lengthSize;\n        const nalUnit = packetData.subarray(offset, offset + nalUnitLength);\n        nalUnits.push(nalUnit);\n        offset += nalUnitLength;\n    }\n    return nalUnits;\n};\nconst removeEmulationPreventionBytes = (data) => {\n    const result = [];\n    const len = data.length;\n    for (let i = 0; i < len; i++) {\n        // Look for the 0x000003 pattern\n        if (i + 2 < len && data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x03) {\n            result.push(0x00, 0x00); // Push the first two bytes\n            i += 2; // Skip the 0x03 byte\n        }\n        else {\n            result.push(data[i]);\n        }\n    }\n    return new Uint8Array(result);\n};\n/** Converts an AVC packet in Annex B format to length-prefixed format. */\nexport const transformAnnexBToLengthPrefixed = (packetData) => {\n    const NAL_UNIT_LENGTH_SIZE = 4;\n    const nalUnits = findNalUnitsInAnnexB(packetData);\n    if (nalUnits.length === 0) {\n        // If no NAL units were found, it's not valid Annex B data\n        return null;\n    }\n    let totalSize = 0;\n    for (const nalUnit of nalUnits) {\n        totalSize += NAL_UNIT_LENGTH_SIZE + nalUnit.byteLength;\n    }\n    const avccData = new Uint8Array(totalSize);\n    const dataView = new DataView(avccData.buffer);\n    let offset = 0;\n    // Write each NAL unit with its length prefix\n    for (const nalUnit of nalUnits) {\n        const length = nalUnit.byteLength;\n        dataView.setUint32(offset, length, false);\n        offset += 4;\n        avccData.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return avccData;\n};\nexport const extractAvcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[4] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return findNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return findNalUnitsInAnnexB(packetData);\n    }\n};\nconst extractNalUnitTypeForAvc = (data) => {\n    return data[0] & 0x1F;\n};\n/** Builds an AvcDecoderConfigurationRecord from an AVC packet in Annex B format. */\nexport const extractAvcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const nalUnits = findNalUnitsInAnnexB(packetData);\n        const spsUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.SPS);\n        const ppsUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.PPS);\n        const spsExtUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.SPS_EXT);\n        if (spsUnits.length === 0) {\n            return null;\n        }\n        if (ppsUnits.length === 0) {\n            return null;\n        }\n        // Let's get the first SPS for profile and level information\n        const spsData = spsUnits[0];\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(spsData));\n        bitstream.skipBits(1); // forbidden_zero_bit\n        bitstream.skipBits(2); // nal_ref_idc\n        const nal_unit_type = bitstream.readBits(5);\n        if (nal_unit_type !== 7) { // SPS NAL unit type is 7\n            console.error('Invalid SPS NAL unit type');\n            return null;\n        }\n        const profile_idc = bitstream.readAlignedByte();\n        const constraint_flags = bitstream.readAlignedByte();\n        const level_idc = bitstream.readAlignedByte();\n        const record = {\n            configurationVersion: 1,\n            avcProfileIndication: profile_idc,\n            profileCompatibility: constraint_flags,\n            avcLevelIndication: level_idc,\n            lengthSizeMinusOne: 3, // Typically 4 bytes for length field\n            sequenceParameterSets: spsUnits,\n            pictureParameterSets: ppsUnits,\n            chromaFormat: null,\n            bitDepthLumaMinus8: null,\n            bitDepthChromaMinus8: null,\n            sequenceParameterSetExt: null,\n        };\n        if (profile_idc === 100\n            || profile_idc === 110\n            || profile_idc === 122\n            || profile_idc === 144) {\n            readExpGolomb(bitstream); // seq_parameter_set_id\n            const chroma_format_idc = readExpGolomb(bitstream);\n            if (chroma_format_idc === 3) {\n                bitstream.skipBits(1); // separate_colour_plane_flag\n            }\n            const bit_depth_luma_minus8 = readExpGolomb(bitstream);\n            const bit_depth_chroma_minus8 = readExpGolomb(bitstream);\n            record.chromaFormat = chroma_format_idc;\n            record.bitDepthLumaMinus8 = bit_depth_luma_minus8;\n            record.bitDepthChromaMinus8 = bit_depth_chroma_minus8;\n            record.sequenceParameterSetExt = spsExtUnits;\n        }\n        return record;\n    }\n    catch (error) {\n        console.error('Error building AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Serializes an AvcDecoderConfigurationRecord into the format specified in Section 5.3.3.1 of ISO 14496-15. */\nexport const serializeAvcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    // Write header\n    bytes.push(record.configurationVersion);\n    bytes.push(record.avcProfileIndication);\n    bytes.push(record.profileCompatibility);\n    bytes.push(record.avcLevelIndication);\n    bytes.push(0xFC | (record.lengthSizeMinusOne & 0x03)); // Reserved bits (6) + lengthSizeMinusOne (2)\n    // Reserved bits (3) + numOfSequenceParameterSets (5)\n    bytes.push(0xE0 | (record.sequenceParameterSets.length & 0x1F));\n    // Write SPS\n    for (const sps of record.sequenceParameterSets) {\n        const length = sps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(sps[i]);\n        }\n    }\n    bytes.push(record.pictureParameterSets.length);\n    // Write PPS\n    for (const pps of record.pictureParameterSets) {\n        const length = pps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(pps[i]);\n        }\n    }\n    if (record.avcProfileIndication === 100\n        || record.avcProfileIndication === 110\n        || record.avcProfileIndication === 122\n        || record.avcProfileIndication === 144) {\n        assert(record.chromaFormat !== null);\n        assert(record.bitDepthLumaMinus8 !== null);\n        assert(record.bitDepthChromaMinus8 !== null);\n        assert(record.sequenceParameterSetExt !== null);\n        bytes.push(0xFC | (record.chromaFormat & 0x03)); // Reserved bits + chroma_format\n        bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07)); // Reserved bits + bit_depth_luma_minus8\n        bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07)); // Reserved bits + bit_depth_chroma_minus8\n        bytes.push(record.sequenceParameterSetExt.length);\n        // Write SPS Ext\n        for (const spsExt of record.sequenceParameterSetExt) {\n            const length = spsExt.byteLength;\n            bytes.push(length >> 8); // High byte\n            bytes.push(length & 0xFF); // Low byte\n            for (let i = 0; i < length; i++) {\n                bytes.push(spsExt[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\nexport const extractHevcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[21] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return findNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return findNalUnitsInAnnexB(packetData);\n    }\n};\nexport const extractNalUnitTypeForHevc = (data) => {\n    return (data[0] >> 1) & 0x3F;\n};\n/** Builds a HevcDecoderConfigurationRecord from an HEVC packet in Annex B format. */\nexport const extractHevcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const nalUnits = findNalUnitsInAnnexB(packetData);\n        const vpsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.VPS_NUT);\n        const spsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.SPS_NUT);\n        const ppsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.PPS_NUT);\n        const seiUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.PREFIX_SEI_NUT\n            || extractNalUnitTypeForHevc(unit) === HevcNalUnitType.SUFFIX_SEI_NUT);\n        if (spsUnits.length === 0 || ppsUnits.length === 0)\n            return null;\n        const sps = spsUnits[0];\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(16); // NAL header\n        bitstream.readBits(4); // sps_video_parameter_set_id\n        const sps_max_sub_layers_minus1 = bitstream.readBits(3);\n        const sps_temporal_id_nesting_flag = bitstream.readBits(1);\n        const { general_profile_space, general_tier_flag, general_profile_idc, general_profile_compatibility_flags, general_constraint_indicator_flags, general_level_idc, } = parseProfileTierLevel(bitstream, sps_max_sub_layers_minus1);\n        readExpGolomb(bitstream); // sps_seq_parameter_set_id\n        const chroma_format_idc = readExpGolomb(bitstream);\n        if (chroma_format_idc === 3)\n            bitstream.skipBits(1); // separate_colour_plane_flag\n        readExpGolomb(bitstream); // pic_width_in_luma_samples\n        readExpGolomb(bitstream); // pic_height_in_luma_samples\n        if (bitstream.readBits(1)) { // conformance_window_flag\n            readExpGolomb(bitstream); // conf_win_left_offset\n            readExpGolomb(bitstream); // conf_win_right_offset\n            readExpGolomb(bitstream); // conf_win_top_offset\n            readExpGolomb(bitstream); // conf_win_bottom_offset\n        }\n        const bit_depth_luma_minus8 = readExpGolomb(bitstream);\n        const bit_depth_chroma_minus8 = readExpGolomb(bitstream);\n        readExpGolomb(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        const sps_sub_layer_ordering_info_present_flag = bitstream.readBits(1);\n        const maxNum = sps_sub_layer_ordering_info_present_flag ? 0 : sps_max_sub_layers_minus1;\n        for (let i = maxNum; i <= sps_max_sub_layers_minus1; i++) {\n            readExpGolomb(bitstream); // sps_max_dec_pic_buffering_minus1[i]\n            readExpGolomb(bitstream); // sps_max_num_reorder_pics[i]\n            readExpGolomb(bitstream); // sps_max_latency_increase_plus1[i]\n        }\n        readExpGolomb(bitstream); // log2_min_luma_coding_block_size_minus3\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_coding_block_size\n        readExpGolomb(bitstream); // log2_min_luma_transform_block_size_minus2\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_transform_block_size\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_inter\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_intra\n        if (bitstream.readBits(1)) { // scaling_list_enabled_flag\n            if (bitstream.readBits(1)) {\n                skipScalingListData(bitstream);\n            }\n        }\n        bitstream.skipBits(1); // amp_enabled_flag\n        bitstream.skipBits(1); // sample_adaptive_offset_enabled_flag\n        if (bitstream.readBits(1)) { // pcm_enabled_flag\n            bitstream.skipBits(4); // pcm_sample_bit_depth_luma_minus1\n            bitstream.skipBits(4); // pcm_sample_bit_depth_chroma_minus1\n            readExpGolomb(bitstream); // log2_min_pcm_luma_coding_block_size_minus3\n            readExpGolomb(bitstream); // log2_diff_max_min_pcm_luma_coding_block_size\n            bitstream.skipBits(1); // pcm_loop_filter_disabled_flag\n        }\n        const num_short_term_ref_pic_sets = readExpGolomb(bitstream);\n        skipAllStRefPicSets(bitstream, num_short_term_ref_pic_sets);\n        if (bitstream.readBits(1)) { // long_term_ref_pics_present_flag\n            const num_long_term_ref_pics_sps = readExpGolomb(bitstream);\n            for (let i = 0; i < num_long_term_ref_pics_sps; i++) {\n                readExpGolomb(bitstream); // lt_ref_pic_poc_lsb_sps[i]\n                bitstream.skipBits(1); // used_by_curr_pic_lt_sps_flag[i]\n            }\n        }\n        bitstream.skipBits(1); // sps_temporal_mvp_enabled_flag\n        bitstream.skipBits(1); // strong_intra_smoothing_enabled_flag\n        let min_spatial_segmentation_idc = 0;\n        if (bitstream.readBits(1)) { // vui_parameters_present_flag\n            min_spatial_segmentation_idc = parseVuiForMinSpatialSegmentationIdc(bitstream, sps_max_sub_layers_minus1);\n        }\n        // Parse PPS for parallelismType\n        let parallelismType = 0;\n        if (ppsUnits.length > 0) {\n            const pps = ppsUnits[0];\n            const ppsBitstream = new Bitstream(removeEmulationPreventionBytes(pps));\n            ppsBitstream.skipBits(16); // NAL header\n            readExpGolomb(ppsBitstream); // pps_pic_parameter_set_id\n            readExpGolomb(ppsBitstream); // pps_seq_parameter_set_id\n            ppsBitstream.skipBits(1); // dependent_slice_segments_enabled_flag\n            ppsBitstream.skipBits(1); // output_flag_present_flag\n            ppsBitstream.skipBits(3); // num_extra_slice_header_bits\n            ppsBitstream.skipBits(1); // sign_data_hiding_enabled_flag\n            ppsBitstream.skipBits(1); // cabac_init_present_flag\n            readExpGolomb(ppsBitstream); // num_ref_idx_l0_default_active_minus1\n            readExpGolomb(ppsBitstream); // num_ref_idx_l1_default_active_minus1\n            readSignedExpGolomb(ppsBitstream); // init_qp_minus26\n            ppsBitstream.skipBits(1); // constrained_intra_pred_flag\n            ppsBitstream.skipBits(1); // transform_skip_enabled_flag\n            if (ppsBitstream.readBits(1)) { // cu_qp_delta_enabled_flag\n                readExpGolomb(ppsBitstream); // diff_cu_qp_delta_depth\n            }\n            readSignedExpGolomb(ppsBitstream); // pps_cb_qp_offset\n            readSignedExpGolomb(ppsBitstream); // pps_cr_qp_offset\n            ppsBitstream.skipBits(1); // pps_slice_chroma_qp_offsets_present_flag\n            ppsBitstream.skipBits(1); // weighted_pred_flag\n            ppsBitstream.skipBits(1); // weighted_bipred_flag\n            ppsBitstream.skipBits(1); // transquant_bypass_enabled_flag\n            const tiles_enabled_flag = ppsBitstream.readBits(1);\n            const entropy_coding_sync_enabled_flag = ppsBitstream.readBits(1);\n            if (!tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 0;\n            else if (tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 2;\n            else if (!tiles_enabled_flag && entropy_coding_sync_enabled_flag)\n                parallelismType = 3;\n            else\n                parallelismType = 0;\n        }\n        const arrays = [\n            ...(vpsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.VPS_NUT,\n                        nalUnits: vpsUnits,\n                    },\n                ]\n                : []),\n            ...(spsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.SPS_NUT,\n                        nalUnits: spsUnits,\n                    },\n                ]\n                : []),\n            ...(ppsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.PPS_NUT,\n                        nalUnits: ppsUnits,\n                    },\n                ]\n                : []),\n            ...(seiUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: extractNalUnitTypeForHevc(seiUnits[0]),\n                        nalUnits: seiUnits,\n                    },\n                ]\n                : []),\n        ];\n        const record = {\n            configurationVersion: 1,\n            generalProfileSpace: general_profile_space,\n            generalTierFlag: general_tier_flag,\n            generalProfileIdc: general_profile_idc,\n            generalProfileCompatibilityFlags: general_profile_compatibility_flags,\n            generalConstraintIndicatorFlags: general_constraint_indicator_flags,\n            generalLevelIdc: general_level_idc,\n            minSpatialSegmentationIdc: min_spatial_segmentation_idc,\n            parallelismType,\n            chromaFormatIdc: chroma_format_idc,\n            bitDepthLumaMinus8: bit_depth_luma_minus8,\n            bitDepthChromaMinus8: bit_depth_chroma_minus8,\n            avgFrameRate: 0,\n            constantFrameRate: 0,\n            numTemporalLayers: sps_max_sub_layers_minus1 + 1,\n            temporalIdNested: sps_temporal_id_nesting_flag,\n            lengthSizeMinusOne: 3,\n            arrays,\n        };\n        return record;\n    }\n    catch (error) {\n        console.error('Error building HEVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\nconst parseProfileTierLevel = (bitstream, maxNumSubLayersMinus1) => {\n    const general_profile_space = bitstream.readBits(2);\n    const general_tier_flag = bitstream.readBits(1);\n    const general_profile_idc = bitstream.readBits(5);\n    let general_profile_compatibility_flags = 0;\n    for (let i = 0; i < 32; i++) {\n        general_profile_compatibility_flags = (general_profile_compatibility_flags << 1) | bitstream.readBits(1);\n    }\n    const general_constraint_indicator_flags = new Uint8Array(6);\n    for (let i = 0; i < 6; i++) {\n        general_constraint_indicator_flags[i] = bitstream.readBits(8);\n    }\n    const general_level_idc = bitstream.readBits(8);\n    const sub_layer_profile_present_flag = [];\n    const sub_layer_level_present_flag = [];\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        sub_layer_profile_present_flag.push(bitstream.readBits(1));\n        sub_layer_level_present_flag.push(bitstream.readBits(1));\n    }\n    if (maxNumSubLayersMinus1 > 0) {\n        for (let i = maxNumSubLayersMinus1; i < 8; i++) {\n            bitstream.skipBits(2); // reserved_zero_2bits\n        }\n    }\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        if (sub_layer_profile_present_flag[i])\n            bitstream.skipBits(88);\n        if (sub_layer_level_present_flag[i])\n            bitstream.skipBits(8);\n    }\n    return {\n        general_profile_space,\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_compatibility_flags,\n        general_constraint_indicator_flags,\n        general_level_idc,\n    };\n};\nconst skipScalingListData = (bitstream) => {\n    for (let sizeId = 0; sizeId < 4; sizeId++) {\n        for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n            const scaling_list_pred_mode_flag = bitstream.readBits(1);\n            if (!scaling_list_pred_mode_flag) {\n                readExpGolomb(bitstream); // scaling_list_pred_matrix_id_delta\n            }\n            else {\n                const coefNum = Math.min(64, 1 << (4 + (sizeId << 1)));\n                if (sizeId > 1) {\n                    readSignedExpGolomb(bitstream); // scaling_list_dc_coef_minus8\n                }\n                for (let i = 0; i < coefNum; i++) {\n                    readSignedExpGolomb(bitstream); // scaling_list_delta_coef\n                }\n            }\n        }\n    }\n};\nconst skipAllStRefPicSets = (bitstream, num_short_term_ref_pic_sets) => {\n    const NumDeltaPocs = [];\n    for (let stRpsIdx = 0; stRpsIdx < num_short_term_ref_pic_sets; stRpsIdx++) {\n        NumDeltaPocs[stRpsIdx] = skipStRefPicSet(bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs);\n    }\n};\nconst skipStRefPicSet = (bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs) => {\n    let NumDeltaPocsThis = 0;\n    let inter_ref_pic_set_prediction_flag = 0;\n    let RefRpsIdx = 0;\n    if (stRpsIdx !== 0) {\n        inter_ref_pic_set_prediction_flag = bitstream.readBits(1);\n    }\n    if (inter_ref_pic_set_prediction_flag) {\n        if (stRpsIdx === num_short_term_ref_pic_sets) {\n            const delta_idx_minus1 = readExpGolomb(bitstream);\n            RefRpsIdx = stRpsIdx - (delta_idx_minus1 + 1);\n        }\n        else {\n            RefRpsIdx = stRpsIdx - 1;\n        }\n        bitstream.readBits(1); // delta_rps_sign\n        readExpGolomb(bitstream); // abs_delta_rps_minus1\n        // The number of iterations is NumDeltaPocs[RefRpsIdx] + 1\n        const numDelta = NumDeltaPocs[RefRpsIdx] ?? 0;\n        for (let j = 0; j <= numDelta; j++) {\n            const used_by_curr_pic_flag = bitstream.readBits(1);\n            if (!used_by_curr_pic_flag) {\n                bitstream.readBits(1); // use_delta_flag\n            }\n        }\n        NumDeltaPocsThis = NumDeltaPocs[RefRpsIdx];\n    }\n    else {\n        const num_negative_pics = readExpGolomb(bitstream);\n        const num_positive_pics = readExpGolomb(bitstream);\n        for (let i = 0; i < num_negative_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s0_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s0_flag[i]\n        }\n        for (let i = 0; i < num_positive_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s1_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s1_flag[i]\n        }\n        NumDeltaPocsThis = num_negative_pics + num_positive_pics;\n    }\n    return NumDeltaPocsThis;\n};\nconst parseVuiForMinSpatialSegmentationIdc = (bitstream, sps_max_sub_layers_minus1) => {\n    if (bitstream.readBits(1)) { // aspect_ratio_info_present_flag\n        const aspect_ratio_idc = bitstream.readBits(8);\n        if (aspect_ratio_idc === 255) {\n            bitstream.readBits(16); // sar_width\n            bitstream.readBits(16); // sar_height\n        }\n    }\n    if (bitstream.readBits(1)) { // overscan_info_present_flag\n        bitstream.readBits(1); // overscan_appropriate_flag\n    }\n    if (bitstream.readBits(1)) { // video_signal_type_present_flag\n        bitstream.readBits(3); // video_format\n        bitstream.readBits(1); // video_full_range_flag\n        if (bitstream.readBits(1)) {\n            bitstream.readBits(8); // colour_primaries\n            bitstream.readBits(8); // transfer_characteristics\n            bitstream.readBits(8); // matrix_coeffs\n        }\n    }\n    if (bitstream.readBits(1)) { // chroma_loc_info_present_flag\n        readExpGolomb(bitstream); // chroma_sample_loc_type_top_field\n        readExpGolomb(bitstream); // chroma_sample_loc_type_bottom_field\n    }\n    bitstream.readBits(1); // neutral_chroma_indication_flag\n    bitstream.readBits(1); // field_seq_flag\n    bitstream.readBits(1); // frame_field_info_present_flag\n    if (bitstream.readBits(1)) { // default_display_window_flag\n        readExpGolomb(bitstream); // def_disp_win_left_offset\n        readExpGolomb(bitstream); // def_disp_win_right_offset\n        readExpGolomb(bitstream); // def_disp_win_top_offset\n        readExpGolomb(bitstream); // def_disp_win_bottom_offset\n    }\n    if (bitstream.readBits(1)) { // vui_timing_info_present_flag\n        bitstream.readBits(32); // vui_num_units_in_tick\n        bitstream.readBits(32); // vui_time_scale\n        if (bitstream.readBits(1)) { // vui_poc_proportional_to_timing_flag\n            readExpGolomb(bitstream); // vui_num_ticks_poc_diff_one_minus1\n        }\n        if (bitstream.readBits(1)) {\n            skipHrdParameters(bitstream, true, sps_max_sub_layers_minus1);\n        }\n    }\n    if (bitstream.readBits(1)) { // bitstream_restriction_flag\n        bitstream.readBits(1); // tiles_fixed_structure_flag\n        bitstream.readBits(1); // motion_vectors_over_pic_boundaries_flag\n        bitstream.readBits(1); // restricted_ref_pic_lists_flag\n        const min_spatial_segmentation_idc = readExpGolomb(bitstream);\n        // skip the rest\n        readExpGolomb(bitstream); // max_bytes_per_pic_denom\n        readExpGolomb(bitstream); // max_bits_per_min_cu_denom\n        readExpGolomb(bitstream); // log2_max_mv_length_horizontal\n        readExpGolomb(bitstream); // log2_max_mv_length_vertical\n        return min_spatial_segmentation_idc;\n    }\n    return 0;\n};\nconst skipHrdParameters = (bitstream, commonInfPresentFlag, maxNumSubLayersMinus1) => {\n    let nal_hrd_parameters_present_flag = false;\n    let vcl_hrd_parameters_present_flag = false;\n    let sub_pic_hrd_params_present_flag = false;\n    if (commonInfPresentFlag) {\n        nal_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        vcl_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n            sub_pic_hrd_params_present_flag = bitstream.readBits(1) === 1;\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(8); // tick_divisor_minus2\n                bitstream.readBits(5); // du_cpb_removal_delay_increment_length_minus1\n                bitstream.readBits(1); // sub_pic_cpb_params_in_pic_timing_sei_flag\n                bitstream.readBits(5); // dpb_output_delay_du_length_minus1\n            }\n            bitstream.readBits(4); // bit_rate_scale\n            bitstream.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(4); // cpb_size_du_scale\n            }\n            bitstream.readBits(5); // initial_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // au_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // dpb_output_delay_length_minus1\n        }\n    }\n    for (let i = 0; i <= maxNumSubLayersMinus1; i++) {\n        const fixed_pic_rate_general_flag = bitstream.readBits(1) === 1;\n        let fixed_pic_rate_within_cvs_flag = true; // Default assumption if general is true\n        if (!fixed_pic_rate_general_flag) {\n            fixed_pic_rate_within_cvs_flag = bitstream.readBits(1) === 1;\n        }\n        let low_delay_hrd_flag = false; // Default assumption\n        if (fixed_pic_rate_within_cvs_flag) {\n            readExpGolomb(bitstream); // elemental_duration_in_tc_minus1[i]\n        }\n        else {\n            low_delay_hrd_flag = bitstream.readBits(1) === 1;\n        }\n        let CpbCnt = 1; // Default if low_delay is true\n        if (!low_delay_hrd_flag) {\n            const cpb_cnt_minus1 = readExpGolomb(bitstream); // cpb_cnt_minus1[i]\n            CpbCnt = cpb_cnt_minus1 + 1;\n        }\n        if (nal_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n        if (vcl_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n    }\n};\nconst skipSubLayerHrdParameters = (bitstream, CpbCnt, sub_pic_hrd_params_present_flag) => {\n    for (let i = 0; i < CpbCnt; i++) {\n        readExpGolomb(bitstream); // bit_rate_value_minus1[i]\n        readExpGolomb(bitstream); // cpb_size_value_minus1[i]\n        if (sub_pic_hrd_params_present_flag) {\n            readExpGolomb(bitstream); // cpb_size_du_value_minus1[i]\n            readExpGolomb(bitstream); // bit_rate_du_value_minus1[i]\n        }\n        bitstream.readBits(1); // cbr_flag[i]\n    }\n};\n/** Serializes an HevcDecoderConfigurationRecord into the format specified in Section 8.3.3.1 of ISO 14496-15. */\nexport const serializeHevcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    bytes.push(record.configurationVersion);\n    bytes.push(((record.generalProfileSpace & 0x3) << 6)\n        | ((record.generalTierFlag & 0x1) << 5)\n        | (record.generalProfileIdc & 0x1F));\n    bytes.push((record.generalProfileCompatibilityFlags >>> 24) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 16) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 8) & 0xFF);\n    bytes.push(record.generalProfileCompatibilityFlags & 0xFF);\n    bytes.push(...record.generalConstraintIndicatorFlags);\n    bytes.push(record.generalLevelIdc & 0xFF);\n    bytes.push(0xF0 | ((record.minSpatialSegmentationIdc >> 8) & 0x0F)); // Reserved + high nibble\n    bytes.push(record.minSpatialSegmentationIdc & 0xFF); // Low byte\n    bytes.push(0xFC | (record.parallelismType & 0x03));\n    bytes.push(0xFC | (record.chromaFormatIdc & 0x03));\n    bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07));\n    bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07));\n    bytes.push((record.avgFrameRate >> 8) & 0xFF); // High byte\n    bytes.push(record.avgFrameRate & 0xFF); // Low byte\n    bytes.push(((record.constantFrameRate & 0x03) << 6)\n        | ((record.numTemporalLayers & 0x07) << 3)\n        | ((record.temporalIdNested & 0x01) << 2)\n        | (record.lengthSizeMinusOne & 0x03));\n    bytes.push(record.arrays.length & 0xFF);\n    for (const arr of record.arrays) {\n        bytes.push(((arr.arrayCompleteness & 0x01) << 7)\n            | (0 << 6)\n            | (arr.nalUnitType & 0x3F));\n        bytes.push((arr.nalUnits.length >> 8) & 0xFF); // High byte\n        bytes.push(arr.nalUnits.length & 0xFF); // Low byte\n        for (const nal of arr.nalUnits) {\n            bytes.push((nal.length >> 8) & 0xFF); // High byte\n            bytes.push(nal.length & 0xFF); // Low byte\n            for (let i = 0; i < nal.length; i++) {\n                bytes.push(nal[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\nexport const extractVp9CodecInfoFromPacket = (packet) => {\n    // eslint-disable-next-line @stylistic/max-len\n    // https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.7-20170222-draft.pdf\n    // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n    const bitstream = new Bitstream(packet);\n    // Frame marker (0b10)\n    const frameMarker = bitstream.readBits(2);\n    if (frameMarker !== 2) {\n        return null;\n    }\n    // Profile\n    const profileLowBit = bitstream.readBits(1);\n    const profileHighBit = bitstream.readBits(1);\n    const profile = (profileHighBit << 1) + profileLowBit;\n    // Skip reserved bit for profile 3\n    if (profile === 3) {\n        bitstream.skipBits(1);\n    }\n    // show_existing_frame\n    const showExistingFrame = bitstream.readBits(1);\n    if (showExistingFrame === 1) {\n        return null;\n    }\n    // frame_type (0 = key frame)\n    const frameType = bitstream.readBits(1);\n    if (frameType !== 0) {\n        return null;\n    }\n    // Skip show_frame and error_resilient_mode\n    bitstream.skipBits(2);\n    // Sync code (0x498342)\n    const syncCode = bitstream.readBits(24);\n    if (syncCode !== 0x498342) {\n        return null;\n    }\n    // Color config\n    let bitDepth = 8;\n    if (profile >= 2) {\n        const tenOrTwelveBit = bitstream.readBits(1);\n        bitDepth = tenOrTwelveBit ? 12 : 10;\n    }\n    // Color space\n    const colorSpace = bitstream.readBits(3);\n    let chromaSubsampling = 0;\n    let videoFullRangeFlag = 0;\n    if (colorSpace !== 7) { // 7 is CS_RGB\n        const colorRange = bitstream.readBits(1);\n        videoFullRangeFlag = colorRange;\n        if (profile === 1 || profile === 3) {\n            const subsamplingX = bitstream.readBits(1);\n            const subsamplingY = bitstream.readBits(1);\n            // 0 = 4:2:0 vertical\n            // 1 = 4:2:0 colocated\n            // 2 = 4:2:2\n            // 3 = 4:4:4\n            chromaSubsampling = !subsamplingX && !subsamplingY\n                ? 3 // 0,0 = 4:4:4\n                : subsamplingX && !subsamplingY\n                    ? 2 // 1,0 = 4:2:2\n                    : 1; // 1,1 = 4:2:0 colocated (default)\n            // Skip reserved bit\n            bitstream.skipBits(1);\n        }\n        else {\n            // For profile 0 and 2, always 4:2:0\n            chromaSubsampling = 1; // Using colocated as default\n        }\n    }\n    else {\n        // RGB is always 4:4:4\n        chromaSubsampling = 3;\n        videoFullRangeFlag = 1;\n    }\n    // Parse frame size\n    const widthMinusOne = bitstream.readBits(16);\n    const heightMinusOne = bitstream.readBits(16);\n    const width = widthMinusOne + 1;\n    const height = heightMinusOne + 1;\n    // Calculate level based on dimensions\n    const pictureSize = width * height;\n    let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n    for (const entry of VP9_LEVEL_TABLE) {\n        if (pictureSize <= entry.maxPictureSize) {\n            level = entry.level;\n            break;\n        }\n    }\n    // Map color_space to standard values\n    const matrixCoefficients = colorSpace === 7\n        ? 0\n        : colorSpace === 2\n            ? 1\n            : colorSpace === 1\n                ? 6\n                : 2;\n    const colourPrimaries = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    const transferCharacteristics = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    return {\n        profile,\n        level,\n        bitDepth,\n        chromaSubsampling,\n        videoFullRangeFlag,\n        colourPrimaries,\n        transferCharacteristics,\n        matrixCoefficients,\n    };\n};\n/** Iterates over all OBUs in an AV1 packet bistream. */\nexport const iterateAv1PacketObus = function* (packet) {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    const bitstream = new Bitstream(packet);\n    const readLeb128 = () => {\n        let value = 0;\n        for (let i = 0; i < 8; i++) {\n            const byte = bitstream.readAlignedByte();\n            value |= ((byte & 0x7f) << (i * 7));\n            if (!(byte & 0x80)) {\n                break;\n            }\n            // Spec requirement\n            if (i === 7 && (byte & 0x80)) {\n                return null;\n            }\n        }\n        // Spec requirement\n        if (value >= 2 ** 32 - 1) {\n            return null;\n        }\n        return value;\n    };\n    while (bitstream.getBitsLeft() >= 8) {\n        // Parse OBU header\n        bitstream.skipBits(1);\n        const obuType = bitstream.readBits(4);\n        const obuExtension = bitstream.readBits(1);\n        const obuHasSizeField = bitstream.readBits(1);\n        bitstream.skipBits(1);\n        // Skip extension header if present\n        if (obuExtension) {\n            bitstream.skipBits(8);\n        }\n        // Read OBU size if present\n        let obuSize;\n        if (obuHasSizeField) {\n            const obuSizeValue = readLeb128();\n            if (obuSizeValue === null)\n                return; // It was invalid\n            obuSize = obuSizeValue;\n        }\n        else {\n            // Calculate remaining bits and convert to bytes, rounding down\n            obuSize = Math.floor(bitstream.getBitsLeft() / 8);\n        }\n        assert(bitstream.pos % 8 === 0);\n        yield {\n            type: obuType,\n            data: packet.subarray(bitstream.pos / 8, bitstream.pos / 8 + obuSize),\n        };\n        // Move to next OBU\n        bitstream.skipBits(obuSize * 8);\n    }\n};\n/**\n * When AV1 codec information is not provided by the container, we can still try to extract the information by digging\n * into the AV1 bitstream.\n */\nexport const extractAv1CodecInfoFromPacket = (packet) => {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    for (const { type, data } of iterateAv1PacketObus(packet)) {\n        if (type !== 1) {\n            continue; // 1 == OBU_SEQUENCE_HEADER\n        }\n        const bitstream = new Bitstream(data);\n        // Read sequence header fields\n        const seqProfile = bitstream.readBits(3);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const stillPicture = bitstream.readBits(1);\n        const reducedStillPictureHeader = bitstream.readBits(1);\n        let seqLevel = 0;\n        let seqTier = 0;\n        let bufferDelayLengthMinus1 = 0;\n        if (reducedStillPictureHeader) {\n            seqLevel = bitstream.readBits(5);\n        }\n        else {\n            // Parse timing_info_present_flag\n            const timingInfoPresentFlag = bitstream.readBits(1);\n            if (timingInfoPresentFlag) {\n                // Skip timing info (num_units_in_display_tick, time_scale, equal_picture_interval)\n                bitstream.skipBits(32); // num_units_in_display_tick\n                bitstream.skipBits(32); // time_scale\n                const equalPictureInterval = bitstream.readBits(1);\n                if (equalPictureInterval) {\n                    // Skip num_ticks_per_picture_minus_1 (uvlc)\n                    // Since this is variable length, we'd need to implement uvlc reading\n                    // For now, we'll return null as this is rare\n                    return null;\n                }\n            }\n            // Parse decoder_model_info_present_flag\n            const decoderModelInfoPresentFlag = bitstream.readBits(1);\n            if (decoderModelInfoPresentFlag) {\n                // Store buffer_delay_length_minus_1 instead of just skipping\n                bufferDelayLengthMinus1 = bitstream.readBits(5);\n                bitstream.skipBits(32); // num_units_in_decoding_tick\n                bitstream.skipBits(5); // buffer_removal_time_length_minus_1\n                bitstream.skipBits(5); // frame_presentation_time_length_minus_1\n            }\n            // Parse operating_points_cnt_minus_1\n            const operatingPointsCntMinus1 = bitstream.readBits(5);\n            // For each operating point\n            for (let i = 0; i <= operatingPointsCntMinus1; i++) {\n                // operating_point_idc[i]\n                bitstream.skipBits(12);\n                // seq_level_idx[i]\n                const seqLevelIdx = bitstream.readBits(5);\n                if (i === 0) {\n                    seqLevel = seqLevelIdx;\n                }\n                if (seqLevelIdx > 7) {\n                    // seq_tier[i]\n                    const seqTierTemp = bitstream.readBits(1);\n                    if (i === 0) {\n                        seqTier = seqTierTemp;\n                    }\n                }\n                if (decoderModelInfoPresentFlag) {\n                    // decoder_model_present_for_this_op[i]\n                    const decoderModelPresentForThisOp = bitstream.readBits(1);\n                    if (decoderModelPresentForThisOp) {\n                        const n = bufferDelayLengthMinus1 + 1;\n                        bitstream.skipBits(n); // decoder_buffer_delay[op]\n                        bitstream.skipBits(n); // encoder_buffer_delay[op]\n                        bitstream.skipBits(1); // low_delay_mode_flag[op]\n                    }\n                }\n                // initial_display_delay_present_flag\n                const initialDisplayDelayPresentFlag = bitstream.readBits(1);\n                if (initialDisplayDelayPresentFlag) {\n                    // initial_display_delay_minus_1[i]\n                    bitstream.skipBits(4);\n                }\n            }\n        }\n        const highBitdepth = bitstream.readBits(1);\n        let bitDepth = 8;\n        if (seqProfile === 2 && highBitdepth) {\n            const twelveBit = bitstream.readBits(1);\n            bitDepth = twelveBit ? 12 : 10;\n        }\n        else if (seqProfile <= 2) {\n            bitDepth = highBitdepth ? 10 : 8;\n        }\n        let monochrome = 0;\n        if (seqProfile !== 1) {\n            monochrome = bitstream.readBits(1);\n        }\n        let chromaSubsamplingX = 1;\n        let chromaSubsamplingY = 1;\n        let chromaSamplePosition = 0;\n        if (!monochrome) {\n            if (seqProfile === 0) {\n                chromaSubsamplingX = 1;\n                chromaSubsamplingY = 1;\n            }\n            else if (seqProfile === 1) {\n                chromaSubsamplingX = 0;\n                chromaSubsamplingY = 0;\n            }\n            else {\n                if (bitDepth === 12) {\n                    chromaSubsamplingX = bitstream.readBits(1);\n                    if (chromaSubsamplingX) {\n                        chromaSubsamplingY = bitstream.readBits(1);\n                    }\n                }\n            }\n            if (chromaSubsamplingX && chromaSubsamplingY) {\n                chromaSamplePosition = bitstream.readBits(2);\n            }\n        }\n        return {\n            profile: seqProfile,\n            level: seqLevel,\n            tier: seqTier,\n            bitDepth,\n            monochrome,\n            chromaSubsamplingX,\n            chromaSubsamplingY,\n            chromaSamplePosition,\n        };\n    }\n    return null;\n};\nexport const parseOpusIdentificationHeader = (bytes) => {\n    const view = toDataView(bytes);\n    const outputChannelCount = view.getUint8(9);\n    const preSkip = view.getUint16(10, true);\n    const inputSampleRate = view.getUint32(12, true);\n    const outputGain = view.getInt16(16, true);\n    const channelMappingFamily = view.getUint8(18);\n    let channelMappingTable = null;\n    if (channelMappingFamily) {\n        channelMappingTable = bytes.subarray(19, 19 + 2 + outputChannelCount);\n    }\n    return {\n        outputChannelCount,\n        preSkip,\n        inputSampleRate,\n        outputGain,\n        channelMappingFamily,\n        channelMappingTable,\n    };\n};\n// From https://datatracker.ietf.org/doc/html/rfc6716, in 48 kHz samples\nconst OPUS_FRAME_DURATION_TABLE = [\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960,\n    480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n];\nexport const parseOpusTocByte = (packet) => {\n    const config = packet[0] >> 3;\n    return {\n        durationInSamples: OPUS_FRAME_DURATION_TABLE[config],\n    };\n};\n// Based on vorbis_parser.c from FFmpeg.\nexport const parseModesFromVorbisSetupPacket = (setupHeader) => {\n    // Verify that this is a Setup header.\n    if (setupHeader.length < 7) {\n        throw new Error('Setup header is too short.');\n    }\n    if (setupHeader[0] !== 5) {\n        throw new Error('Wrong packet type in Setup header.');\n    }\n    const signature = String.fromCharCode(...setupHeader.slice(1, 7));\n    if (signature !== 'vorbis') {\n        throw new Error('Invalid packet signature in Setup header.');\n    }\n    // Reverse the entire buffer.\n    const bufSize = setupHeader.length;\n    const revBuffer = new Uint8Array(bufSize);\n    for (let i = 0; i < bufSize; i++) {\n        revBuffer[i] = setupHeader[bufSize - 1 - i];\n    }\n    // Initialize a Bitstream on the reversed buffer.\n    const bitstream = new Bitstream(revBuffer);\n    // --- Find the framing bit.\n    // In FFmpeg code, we scan until get_bits1() returns 1.\n    let gotFramingBit = 0;\n    while (bitstream.getBitsLeft() > 97) {\n        if (bitstream.readBits(1) === 1) {\n            gotFramingBit = bitstream.pos;\n            break;\n        }\n    }\n    if (gotFramingBit === 0) {\n        throw new Error('Invalid Setup header: framing bit not found.');\n    }\n    // --- Search backwards for a valid mode header.\n    // We try to ‚Äúguess‚Äù the number of modes by reading a fixed pattern.\n    let modeCount = 0;\n    let gotModeHeader = false;\n    let lastModeCount = 0;\n    while (bitstream.getBitsLeft() >= 97) {\n        const tempPos = bitstream.pos;\n        const a = bitstream.readBits(8);\n        const b = bitstream.readBits(16);\n        const c = bitstream.readBits(16);\n        // If a > 63 or b or c nonzero, assume we‚Äôve gone too far.\n        if (a > 63 || b !== 0 || c !== 0) {\n            bitstream.pos = tempPos;\n            break;\n        }\n        bitstream.skipBits(1);\n        modeCount++;\n        if (modeCount > 64) {\n            break;\n        }\n        const bsClone = bitstream.clone();\n        const candidate = bsClone.readBits(6) + 1;\n        if (candidate === modeCount) {\n            gotModeHeader = true;\n            lastModeCount = modeCount;\n        }\n    }\n    if (!gotModeHeader) {\n        throw new Error('Invalid Setup header: mode header not found.');\n    }\n    if (lastModeCount > 63) {\n        throw new Error(`Unsupported mode count: ${lastModeCount}.`);\n    }\n    const finalModeCount = lastModeCount;\n    // --- Reinitialize the bitstream.\n    bitstream.pos = 0;\n    // Skip the bits up to the found framing bit.\n    bitstream.skipBits(gotFramingBit);\n    // --- Now read, for each mode (in reverse order), 40 bits then one bit.\n    // That one bit is the mode blockflag.\n    const modeBlockflags = Array(finalModeCount).fill(0);\n    for (let i = finalModeCount - 1; i >= 0; i--) {\n        bitstream.skipBits(40);\n        modeBlockflags[i] = bitstream.readBits(1);\n    }\n    return { modeBlockflags };\n};\n/** Determines a packet's type (key or delta) by digging into the packet bitstream. */\nexport const determineVideoPacketType = (codec, decoderConfig, packetData) => {\n    switch (codec) {\n        case 'avc':\n            {\n                const nalUnits = extractAvcNalUnits(packetData, decoderConfig);\n                const isKeyframe = nalUnits.some(x => extractNalUnitTypeForAvc(x) === AvcNalUnitType.IDR);\n                return isKeyframe ? 'key' : 'delta';\n            }\n            ;\n        case 'hevc':\n            {\n                const nalUnits = extractHevcNalUnits(packetData, decoderConfig);\n                const isKeyframe = nalUnits.some((x) => {\n                    const type = extractNalUnitTypeForHevc(x);\n                    return HevcNalUnitType.BLA_W_LP <= type && type <= HevcNalUnitType.RSV_IRAP_VCL23;\n                });\n                return isKeyframe ? 'key' : 'delta';\n            }\n            ;\n        case 'vp8':\n            {\n                // VP8, once again, by far the easiest to deal with.\n                const frameType = packetData[0] & 0b1;\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'vp9':\n            {\n                const bitstream = new Bitstream(packetData);\n                if (bitstream.readBits(2) !== 2) {\n                    return null;\n                }\n                ;\n                const profileLowBit = bitstream.readBits(1);\n                const profileHighBit = bitstream.readBits(1);\n                const profile = (profileHighBit << 1) + profileLowBit;\n                // Skip reserved bit for profile 3\n                if (profile === 3) {\n                    bitstream.skipBits(1);\n                }\n                const showExistingFrame = bitstream.readBits(1);\n                if (showExistingFrame) {\n                    return null;\n                }\n                const frameType = bitstream.readBits(1);\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'av1':\n            {\n                let reducedStillPictureHeader = false;\n                for (const { type, data } of iterateAv1PacketObus(packetData)) {\n                    if (type === 1) { // OBU_SEQUENCE_HEADER\n                        const bitstream = new Bitstream(data);\n                        bitstream.skipBits(4);\n                        reducedStillPictureHeader = !!bitstream.readBits(1);\n                    }\n                    else if (type === 3 // OBU_FRAME_HEADER\n                        || type === 6 // OBU_FRAME\n                        || type === 7 // OBU_REDUNDANT_FRAME_HEADER\n                    ) {\n                        if (reducedStillPictureHeader) {\n                            return 'key';\n                        }\n                        const bitstream = new Bitstream(data);\n                        const showExistingFrame = bitstream.readBits(1);\n                        if (showExistingFrame) {\n                            return null;\n                        }\n                        const frameType = bitstream.readBits(2);\n                        return frameType === 0 ? 'key' : 'delta';\n                    }\n                }\n                return null;\n            }\n            ;\n        default:\n            {\n                assertNever(codec);\n                assert(false);\n            }\n            ;\n    }\n};\nexport var FlacBlockType;\n(function (FlacBlockType) {\n    FlacBlockType[FlacBlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    FlacBlockType[FlacBlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    FlacBlockType[FlacBlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(FlacBlockType || (FlacBlockType = {}));\nexport const readVorbisComments = (bytes, metadataTags) => {\n    // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n    const commentView = toDataView(bytes);\n    let commentPos = 0;\n    const vendorStringLength = commentView.getUint32(commentPos, true);\n    commentPos += 4;\n    const vendorString = textDecoder.decode(bytes.subarray(commentPos, commentPos + vendorStringLength));\n    commentPos += vendorStringLength;\n    if (vendorStringLength > 0) {\n        // Expose the vendor string in the raw metadata\n        metadataTags.raw ??= {};\n        metadataTags.raw['vendor'] ??= vendorString;\n    }\n    const listLength = commentView.getUint32(commentPos, true);\n    commentPos += 4;\n    // Loop over all metadata tags\n    for (let i = 0; i < listLength; i++) {\n        const stringLength = commentView.getUint32(commentPos, true);\n        commentPos += 4;\n        const string = textDecoder.decode(bytes.subarray(commentPos, commentPos + stringLength));\n        commentPos += stringLength;\n        const separatorIndex = string.indexOf('=');\n        if (separatorIndex === -1) {\n            continue;\n        }\n        const key = string.slice(0, separatorIndex).toUpperCase();\n        const value = string.slice(separatorIndex + 1);\n        metadataTags.raw ??= {};\n        metadataTags.raw[key] ??= value;\n        switch (key) {\n            case 'TITLE':\n                {\n                    metadataTags.title ??= value;\n                }\n                ;\n                break;\n            case 'DESCRIPTION':\n                {\n                    metadataTags.description ??= value;\n                }\n                ;\n                break;\n            case 'ARTIST':\n                {\n                    metadataTags.artist ??= value;\n                }\n                ;\n                break;\n            case 'ALBUM':\n                {\n                    metadataTags.album ??= value;\n                }\n                ;\n                break;\n            case 'ALBUMARTIST':\n                {\n                    metadataTags.albumArtist ??= value;\n                }\n                ;\n                break;\n            case 'COMMENT':\n                {\n                    metadataTags.comment ??= value;\n                }\n                ;\n                break;\n            case 'LYRICS':\n                {\n                    metadataTags.lyrics ??= value;\n                }\n                ;\n                break;\n            case 'TRACKNUMBER':\n                {\n                    const parts = value.split('/');\n                    const trackNum = Number.parseInt(parts[0], 10);\n                    const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(trackNum) && trackNum > 0) {\n                        metadataTags.trackNumber ??= trackNum;\n                    }\n                    if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        metadataTags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'TRACKTOTAL':\n                {\n                    const tracksTotal = Number.parseInt(value, 10);\n                    if (Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        metadataTags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DISCNUMBER':\n                {\n                    const parts = value.split('/');\n                    const discNum = Number.parseInt(parts[0], 10);\n                    const discsTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(discNum) && discNum > 0) {\n                        metadataTags.discNumber ??= discNum;\n                    }\n                    if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {\n                        metadataTags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DISCTOTAL':\n                {\n                    const discsTotal = Number.parseInt(value, 10);\n                    if (Number.isInteger(discsTotal) && discsTotal > 0) {\n                        metadataTags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DATE':\n                {\n                    const date = new Date(value);\n                    if (!Number.isNaN(date.getTime())) {\n                        metadataTags.date ??= date;\n                    }\n                }\n                ;\n                break;\n            case 'GENRE':\n                {\n                    metadataTags.genre ??= value;\n                }\n                ;\n                break;\n            case 'METADATA_BLOCK_PICTURE':\n                {\n                    // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                    const decoded = base64ToBytes(value);\n                    const view = toDataView(decoded);\n                    const pictureType = view.getUint32(0, false);\n                    const mediaTypeLength = view.getUint32(4, false);\n                    const mediaType = String.fromCharCode(...decoded.subarray(8, 8 + mediaTypeLength)); // ASCII\n                    const descriptionLength = view.getUint32(8 + mediaTypeLength, false);\n                    const description = textDecoder.decode(decoded.subarray(12 + mediaTypeLength, 12 + mediaTypeLength + descriptionLength));\n                    const dataLength = view.getUint32(mediaTypeLength + descriptionLength + 28);\n                    const data = decoded.subarray(mediaTypeLength + descriptionLength + 32, mediaTypeLength + descriptionLength + 32 + dataLength);\n                    metadataTags.images ??= [];\n                    metadataTags.images.push({\n                        data,\n                        mimeType: mediaType,\n                        kind: pictureType === 3 ? 'coverFront' : pictureType === 4 ? 'coverBack' : 'unknown',\n                        name: undefined,\n                        description: description || undefined,\n                    });\n                }\n                ;\n                break;\n        }\n    }\n};\nexport const createVorbisComments = (headerBytes, tags, writeImages) => {\n    // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n    const commentHeaderParts = [\n        headerBytes,\n    ];\n    const vendorString = 'Mediabunny';\n    const encodedVendorString = textEncoder.encode(vendorString);\n    let currentBuffer = new Uint8Array(4 + encodedVendorString.length);\n    let currentView = new DataView(currentBuffer.buffer);\n    currentView.setUint32(0, encodedVendorString.length, true);\n    currentBuffer.set(encodedVendorString, 4);\n    commentHeaderParts.push(currentBuffer);\n    const writtenTags = new Set();\n    const addCommentTag = (key, value) => {\n        const joined = `${key}=${value}`;\n        const encoded = textEncoder.encode(joined);\n        currentBuffer = new Uint8Array(4 + encoded.length);\n        currentView = new DataView(currentBuffer.buffer);\n        currentView.setUint32(0, encoded.length, true);\n        currentBuffer.set(encoded, 4);\n        commentHeaderParts.push(currentBuffer);\n        writtenTags.add(key);\n    };\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    addCommentTag('TITLE', value);\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    addCommentTag('DESCRIPTION', value);\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    addCommentTag('ARTIST', value);\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    addCommentTag('ALBUM', value);\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    addCommentTag('ALBUMARTIST', value);\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    addCommentTag('GENRE', value);\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    const rawVersion = tags.raw?.['DATE'] ?? tags.raw?.['date'];\n                    if (rawVersion && typeof rawVersion === 'string') {\n                        addCommentTag('DATE', rawVersion);\n                    }\n                    else {\n                        addCommentTag('DATE', value.toISOString().slice(0, 10));\n                    }\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    addCommentTag('COMMENT', value);\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    addCommentTag('LYRICS', value);\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    addCommentTag('TRACKNUMBER', value.toString());\n                }\n                ;\n                break;\n            case 'tracksTotal':\n                {\n                    addCommentTag('TRACKTOTAL', value.toString());\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    addCommentTag('DISCNUMBER', value.toString());\n                }\n                ;\n                break;\n            case 'discsTotal':\n                {\n                    addCommentTag('DISCTOTAL', value.toString());\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    // For example, in .flac, we put the pictures in a different section,\n                    // not in the Vorbis comment header.\n                    if (!writeImages) {\n                        break;\n                    }\n                    for (const image of value) {\n                        // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                        const pictureType = image.kind === 'coverFront' ? 3 : image.kind === 'coverBack' ? 4 : 0;\n                        const encodedMediaType = new Uint8Array(image.mimeType.length);\n                        for (let i = 0; i < image.mimeType.length; i++) {\n                            encodedMediaType[i] = image.mimeType.charCodeAt(i);\n                        }\n                        const encodedDescription = textEncoder.encode(image.description ?? '');\n                        const buffer = new Uint8Array(4 // Picture type\n                            + 4 // MIME type length\n                            + encodedMediaType.length // MIME type\n                            + 4 // Description length\n                            + encodedDescription.length // Description\n                            + 16 // Width, height, color depth, number of colors\n                            + 4 // Picture data length\n                            + image.data.length);\n                        const view = toDataView(buffer);\n                        view.setUint32(0, pictureType, false);\n                        view.setUint32(4, encodedMediaType.length, false);\n                        buffer.set(encodedMediaType, 8);\n                        view.setUint32(8 + encodedMediaType.length, encodedDescription.length, false);\n                        buffer.set(encodedDescription, 12 + encodedMediaType.length);\n                        // Skip a bunch of fields (width, height, color depth, number of colors)\n                        view.setUint32(28 + encodedMediaType.length + encodedDescription.length, image.data.length, false);\n                        buffer.set(image.data, 32 + encodedMediaType.length + encodedDescription.length);\n                        const encoded = bytesToBase64(buffer);\n                        addCommentTag('METADATA_BLOCK_PICTURE', encoded);\n                    }\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key] ?? tags.raw[key.toLowerCase()];\n            if (key === 'vendor' || value == null || writtenTags.has(key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                addCommentTag(key, value);\n            }\n        }\n    }\n    const listLengthBuffer = new Uint8Array(4);\n    toDataView(listLengthBuffer).setUint32(0, writtenTags.size, true);\n    commentHeaderParts.splice(2, 0, listLengthBuffer); // Insert after the header and vendor section\n    // Merge all comment header parts into a single buffer\n    const commentHeaderLength = commentHeaderParts.reduce((a, b) => a + b.length, 0);\n    const commentHeader = new Uint8Array(commentHeaderLength);\n    let pos = 0;\n    for (const part of commentHeaderParts) {\n        commentHeader.set(part, pos);\n        pos += part.length;\n    }\n    return commentHeader;\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Base class for custom video decoders. To add your own custom video decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomVideoDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio decoders. To add your own custom audio decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomAudioDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom video encoders. To add your own custom video encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomVideoEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio encoders. To add your own custom audio encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomAudioEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\nexport const customVideoDecoders = [];\nexport const customAudioDecoders = [];\nexport const customVideoEncoders = [];\nexport const customAudioEncoders = [];\n/**\n * Registers a custom video or audio decoder. Registered decoders will automatically be used for decoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nexport const registerDecoder = (decoder) => {\n    if (decoder.prototype instanceof CustomVideoDecoder) {\n        const casted = decoder;\n        if (customVideoDecoders.includes(casted)) {\n            console.warn('Video decoder already registered.');\n            return;\n        }\n        customVideoDecoders.push(casted);\n    }\n    else if (decoder.prototype instanceof CustomAudioDecoder) {\n        const casted = decoder;\n        if (customAudioDecoders.includes(casted)) {\n            console.warn('Audio decoder already registered.');\n            return;\n        }\n        customAudioDecoders.push(casted);\n    }\n    else {\n        throw new TypeError('Decoder must be a CustomVideoDecoder or CustomAudioDecoder.');\n    }\n};\n/**\n * Registers a custom video or audio encoder. Registered encoders will automatically be used for encoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nexport const registerEncoder = (encoder) => {\n    if (encoder.prototype instanceof CustomVideoEncoder) {\n        const casted = encoder;\n        if (customVideoEncoders.includes(casted)) {\n            console.warn('Video encoder already registered.');\n            return;\n        }\n        customVideoEncoders.push(casted);\n    }\n    else if (encoder.prototype instanceof CustomAudioEncoder) {\n        const casted = encoder;\n        if (customAudioEncoders.includes(casted)) {\n            console.warn('Audio encoder already registered.');\n            return;\n        }\n        customAudioEncoders.push(casted);\n    }\n    else {\n        throw new TypeError('Encoder must be a CustomVideoEncoder or CustomAudioEncoder.');\n    }\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { SECOND_TO_MICROSECOND_FACTOR } from './misc.js';\nexport const PLACEHOLDER_DATA = new Uint8Array(0);\n/**\n * Represents an encoded chunk of media. Mainly used as an expressive wrapper around WebCodecs API's\n * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) and\n * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk), but can also be used\n * standalone.\n * @group Packets\n * @public\n */\nexport class EncodedPacket {\n    /** Creates a new {@link EncodedPacket} from raw bytes and timing information. */\n    constructor(\n    /** The encoded data of this packet. */\n    data, \n    /** The type of this packet. */\n    type, \n    /**\n     * The presentation timestamp of this packet in seconds. May be negative. Samples with negative end timestamps\n     * should not be presented.\n     */\n    timestamp, \n    /** The duration of this packet in seconds. */\n    duration, \n    /**\n     * The sequence number indicates the decode order of the packets. Packet A  must be decoded before packet B if A\n     * has a lower sequence number than B. If two packets have the same sequence number, they are the same packet.\n     * Otherwise, sequence numbers are arbitrary and are not guaranteed to have any meaning besides their relative\n     * ordering. Negative sequence numbers mean the sequence number is undefined.\n     */\n    sequenceNumber = -1, byteLength, sideData) {\n        this.data = data;\n        this.type = type;\n        this.timestamp = timestamp;\n        this.duration = duration;\n        this.sequenceNumber = sequenceNumber;\n        if (data === PLACEHOLDER_DATA && byteLength === undefined) {\n            throw new Error('Internal error: byteLength must be explicitly provided when constructing metadata-only packets.');\n        }\n        if (byteLength === undefined) {\n            byteLength = data.byteLength;\n        }\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (type !== 'key' && type !== 'delta') {\n            throw new TypeError('type must be either \"key\" or \"delta\".');\n        }\n        if (!Number.isFinite(timestamp)) {\n            throw new TypeError('timestamp must be a number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        if (!Number.isFinite(sequenceNumber)) {\n            throw new TypeError('sequenceNumber must be a number.');\n        }\n        if (!Number.isInteger(byteLength) || byteLength < 0) {\n            throw new TypeError('byteLength must be a non-negative integer.');\n        }\n        if (sideData !== undefined && (typeof sideData !== 'object' || !sideData)) {\n            throw new TypeError('sideData, when provided, must be an object.');\n        }\n        if (sideData?.alpha !== undefined && !(sideData.alpha instanceof Uint8Array)) {\n            throw new TypeError('sideData.alpha, when provided, must be a Uint8Array.');\n        }\n        if (sideData?.alphaByteLength !== undefined\n            && (!Number.isInteger(sideData.alphaByteLength) || sideData.alphaByteLength < 0)) {\n            throw new TypeError('sideData.alphaByteLength, when provided, must be a non-negative integer.');\n        }\n        this.byteLength = byteLength;\n        this.sideData = sideData ?? {};\n        if (this.sideData.alpha && this.sideData.alphaByteLength === undefined) {\n            this.sideData.alphaByteLength = this.sideData.alpha.byteLength;\n        }\n    }\n    /** If this packet is a metadata-only packet. Metadata-only packets don't contain their packet data. */\n    get isMetadataOnly() {\n        return this.data === PLACEHOLDER_DATA;\n    }\n    /** The timestamp of this packet in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of this packet in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /** Converts this packet to an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) for use with the\n     * WebCodecs API. */\n    toEncodedVideoChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Converts this packet to an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) for use with the\n     * WebCodecs API, using the alpha side data instead of the color data. Throws if no alpha side data is defined.\n     */\n    alphaToEncodedVideoChunk(type = this.type) {\n        if (!this.sideData.alpha) {\n            throw new TypeError('This packet does not contain alpha side data.');\n        }\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.sideData.alpha,\n            type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /** Converts this packet to an\n     * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk) for use with the\n     * WebCodecs API. */\n    toEncodedAudioChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to an audio chunk.');\n        }\n        if (typeof EncodedAudioChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedAudioChunk.');\n        }\n        return new EncodedAudioChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Creates an {@link EncodedPacket} from an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) or\n     * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk). This method is useful\n     * for converting chunks from the WebCodecs API to `EncodedPacket` instances.\n     */\n    static fromEncodedChunk(chunk, sideData) {\n        if (!(chunk instanceof EncodedVideoChunk || chunk instanceof EncodedAudioChunk)) {\n            throw new TypeError('chunk must be an EncodedVideoChunk or EncodedAudioChunk.');\n        }\n        const data = new Uint8Array(chunk.byteLength);\n        chunk.copyTo(data);\n        return new EncodedPacket(data, chunk.type, chunk.timestamp / 1e6, (chunk.duration ?? 0) / 1e6, undefined, undefined, sideData);\n    }\n    /** Clones this packet while optionally updating timing information. */\n    clone(options) {\n        if (options !== undefined && (typeof options !== 'object' || options === null)) {\n            throw new TypeError('options, when provided, must be an object.');\n        }\n        if (options?.timestamp !== undefined && !Number.isFinite(options.timestamp)) {\n            throw new TypeError('options.timestamp, when provided, must be a number.');\n        }\n        if (options?.duration !== undefined && !Number.isFinite(options.duration)) {\n            throw new TypeError('options.duration, when provided, must be a number.');\n        }\n        return new EncodedPacket(this.data, this.type, options?.timestamp ?? this.timestamp, options?.duration ?? this.duration, this.sequenceNumber, this.byteLength);\n    }\n}\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, clamp, isAllowSharedBufferSource, SECOND_TO_MICROSECOND_FACTOR, toDataView, toUint8Array, isFirefox, polyfillSymbolDispose, } from './misc.js';\npolyfillSymbolDispose();\n/**\n * Represents a raw, unencoded video sample (frame). Mainly used as an expressive wrapper around WebCodecs API's\n * [`VideoFrame`](https://developer.mozilla.org/en-US/docs/Web/API/VideoFrame), but can also be used standalone.\n * @group Samples\n * @public\n */\nexport class VideoSample {\n    /** The width of the frame in pixels after rotation. */\n    get displayWidth() {\n        return this.rotation % 180 === 0 ? this.codedWidth : this.codedHeight;\n    }\n    /** The height of the frame in pixels after rotation. */\n    get displayHeight() {\n        return this.rotation % 180 === 0 ? this.codedHeight : this.codedWidth;\n    }\n    /** The presentation timestamp of the frame in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the frame in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Whether this sample uses a pixel format that can hold transparency data. Note that this doesn't necessarily mean\n     * that the sample is transparent.\n     */\n    get hasAlpha() {\n        return this.format && this.format.includes('A');\n    }\n    constructor(data, init) {\n        /** @internal */\n        this._closed = false;\n        if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (!('format' in init) || typeof init.format !== 'string') {\n                throw new TypeError('init.format must be a string.');\n            }\n            if (!Number.isInteger(init.codedWidth) || init.codedWidth <= 0) {\n                throw new TypeError('init.codedWidth must be a positive integer.');\n            }\n            if (!Number.isInteger(init.codedHeight) || init.codedHeight <= 0) {\n                throw new TypeError('init.codedHeight must be a positive integer.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = toUint8Array(data).slice(); // Copy it\n            this.format = init.format;\n            this.codedWidth = init.codedWidth;\n            this.codedHeight = init.codedHeight;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoColorSpace(init.colorSpace);\n        }\n        else if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n            if (init?.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (init?.timestamp !== undefined && !Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp, when provided, must be a number.');\n            }\n            if (init?.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = data;\n            this.format = data.format;\n            // Copying the display dimensions here, assuming no innate VideoFrame rotation\n            this.codedWidth = data.displayWidth;\n            this.codedHeight = data.displayHeight;\n            // The VideoFrame's rotation is ignored here. It's still a new field, and I'm not sure of any application\n            // where the browser makes use of it. If a case gets found, I'll add it.\n            this.rotation = init?.rotation ?? 0;\n            this.timestamp = init?.timestamp ?? data.timestamp / 1e6;\n            this.duration = init?.duration ?? (data.duration ?? 0) / 1e6;\n            this.colorSpace = data.colorSpace;\n        }\n        else if ((typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement)\n            || (typeof SVGImageElement !== 'undefined' && data instanceof SVGImageElement)\n            || (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap)\n            || (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement)\n            || (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement)\n            || (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            if (typeof VideoFrame !== 'undefined') {\n                return new VideoSample(new VideoFrame(data, {\n                    timestamp: Math.trunc(init.timestamp * SECOND_TO_MICROSECOND_FACTOR),\n                    // Drag 0 to undefined\n                    duration: Math.trunc((init.duration ?? 0) * SECOND_TO_MICROSECOND_FACTOR) || undefined,\n                }), init);\n            }\n            let width = 0;\n            let height = 0;\n            // Determine the dimensions of the thing\n            if ('naturalWidth' in data) {\n                width = data.naturalWidth;\n                height = data.naturalHeight;\n            }\n            else if ('videoWidth' in data) {\n                width = data.videoWidth;\n                height = data.videoHeight;\n            }\n            else if ('width' in data) {\n                width = Number(data.width);\n                height = Number(data.height);\n            }\n            if (!width || !height) {\n                throw new TypeError('Could not determine dimensions.');\n            }\n            const canvas = new OffscreenCanvas(width, height);\n            const context = canvas.getContext('2d', {\n                alpha: isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n                willReadFrequently: true,\n            });\n            assert(context);\n            // Draw it to a canvas\n            context.drawImage(data, 0, 0);\n            this._data = canvas;\n            this.format = 'RGBX';\n            this.codedWidth = width;\n            this.codedHeight = height;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoColorSpace({\n                matrix: 'rgb',\n                primaries: 'bt709',\n                transfer: 'iec61966-2-1',\n                fullRange: true,\n            });\n        }\n        else {\n            throw new TypeError('Invalid data type: Must be a BufferSource or CanvasImageSource.');\n        }\n    }\n    /** Clones this video sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoSample(this._data.clone(), {\n                timestamp: this.timestamp,\n                duration: this.duration,\n                rotation: this.rotation,\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoSample(this._data.slice(), {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n        else {\n            return new VideoSample(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n    }\n    /**\n     * Closes this video sample, releasing held resources. Video samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        if (isVideoFrame(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = null; // GC that shit\n        }\n        this._closed = true;\n    }\n    /** Returns the number of bytes required to hold this video sample's pixel data. */\n    allocationSize() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return this._data.allocationSize();\n        }\n        else if (this._data instanceof Uint8Array) {\n            return this._data.byteLength;\n        }\n        else {\n            return this.codedWidth * this.codedHeight * 4; // RGBX\n        }\n    }\n    /** Copies this video sample's pixel data to an ArrayBuffer or ArrayBufferView. */\n    async copyTo(destination) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            await this._data.copyTo(destination);\n        }\n        else if (this._data instanceof Uint8Array) {\n            const dest = toUint8Array(destination);\n            dest.set(this._data);\n        }\n        else {\n            const canvas = this._data;\n            const context = canvas.getContext('2d');\n            assert(context);\n            const imageData = context.getImageData(0, 0, this.codedWidth, this.codedHeight);\n            const dest = toUint8Array(destination);\n            dest.set(imageData.data);\n        }\n    }\n    /**\n     * Converts this video sample to a VideoFrame for use with the WebCodecs API. The VideoFrame returned by this\n     * method *must* be closed separately from this video sample.\n     */\n    toVideoFrame() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined, // Drag 0 duration to undefined, glitches some codecs\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoFrame(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined,\n                colorSpace: this.colorSpace,\n            });\n        }\n        else {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined,\n            });\n        }\n    }\n    draw(context, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n        let sx = 0;\n        let sy = 0;\n        let sWidth = this.displayWidth;\n        let sHeight = this.displayHeight;\n        let dx = 0;\n        let dy = 0;\n        let dWidth = this.displayWidth;\n        let dHeight = this.displayHeight;\n        if (arg5 !== undefined) {\n            sx = arg1;\n            sy = arg2;\n            sWidth = arg3;\n            sHeight = arg4;\n            dx = arg5;\n            dy = arg6;\n            if (arg7 !== undefined) {\n                dWidth = arg7;\n                dHeight = arg8;\n            }\n            else {\n                dWidth = sWidth;\n                dHeight = sHeight;\n            }\n        }\n        else {\n            dx = arg1;\n            dy = arg2;\n            if (arg3 !== undefined) {\n                dWidth = arg3;\n                dHeight = arg4;\n            }\n        }\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!Number.isFinite(sx)) {\n            throw new TypeError('sx must be a number.');\n        }\n        if (!Number.isFinite(sy)) {\n            throw new TypeError('sy must be a number.');\n        }\n        if (!Number.isFinite(sWidth) || sWidth < 0) {\n            throw new TypeError('sWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(sHeight) || sHeight < 0) {\n            throw new TypeError('sHeight must be a non-negative number.');\n        }\n        if (!Number.isFinite(dx)) {\n            throw new TypeError('dx must be a number.');\n        }\n        if (!Number.isFinite(dy)) {\n            throw new TypeError('dy must be a number.');\n        }\n        if (!Number.isFinite(dWidth) || dWidth < 0) {\n            throw new TypeError('dWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(dHeight) || dHeight < 0) {\n            throw new TypeError('dHeight must be a non-negative number.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        ({ sx, sy, sWidth, sHeight } = this._rotateSourceRegion(sx, sy, sWidth, sHeight, this.rotation));\n        const source = this.toCanvasImageSource();\n        context.save();\n        const centerX = dx + dWidth / 2;\n        const centerY = dy + dHeight / 2;\n        context.translate(centerX, centerY);\n        context.rotate(this.rotation * Math.PI / 180);\n        const aspectRatioChange = this.rotation % 180 === 0 ? 1 : dWidth / dHeight;\n        // Scale to compensate for aspect ratio changes when rotated\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.drawImage(source, sx, sy, sWidth, sHeight, -dWidth / 2, -dHeight / 2, dWidth, dHeight);\n        // Restore the previous transformation state\n        context.restore();\n    }\n    /**\n     * Draws the sample in the middle of the canvas corresponding to the context with the specified fit behavior.\n     */\n    drawWithFit(context, options) {\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!['fill', 'contain', 'cover'].includes(options.fit)) {\n            throw new TypeError('options.fit must be \\'fill\\', \\'contain\\', or \\'cover\\'.');\n        }\n        if (options.rotation !== undefined && ![0, 90, 180, 270].includes(options.rotation)) {\n            throw new TypeError('options.rotation, when provided, must be 0, 90, 180, or 270.');\n        }\n        if (options.crop !== undefined) {\n            validateCropRectangle(options.crop, 'options.');\n        }\n        const canvasWidth = context.canvas.width;\n        const canvasHeight = context.canvas.height;\n        const rotation = options.rotation ?? this.rotation;\n        const [rotatedWidth, rotatedHeight] = rotation % 180 === 0\n            ? [this.codedWidth, this.codedHeight]\n            : [this.codedHeight, this.codedWidth];\n        if (options.crop) {\n            clampCropRectangle(options.crop, rotatedWidth, rotatedHeight);\n        }\n        // These variables specify where the final sample will be drawn on the canvas\n        let dx;\n        let dy;\n        let newWidth;\n        let newHeight;\n        const { sx, sy, sWidth, sHeight } = this._rotateSourceRegion(options.crop?.left ?? 0, options.crop?.top ?? 0, options.crop?.width ?? rotatedWidth, options.crop?.height ?? rotatedHeight, rotation);\n        if (options.fit === 'fill') {\n            dx = 0;\n            dy = 0;\n            newWidth = canvasWidth;\n            newHeight = canvasHeight;\n        }\n        else {\n            const [sampleWidth, sampleHeight] = options.crop\n                ? [options.crop.width, options.crop.height]\n                : [rotatedWidth, rotatedHeight];\n            const scale = options.fit === 'contain'\n                ? Math.min(canvasWidth / sampleWidth, canvasHeight / sampleHeight)\n                : Math.max(canvasWidth / sampleWidth, canvasHeight / sampleHeight);\n            newWidth = sampleWidth * scale;\n            newHeight = sampleHeight * scale;\n            dx = (canvasWidth - newWidth) / 2;\n            dy = (canvasHeight - newHeight) / 2;\n        }\n        const aspectRatioChange = rotation % 180 === 0 ? 1 : newWidth / newHeight;\n        context.translate(canvasWidth / 2, canvasHeight / 2);\n        context.rotate(rotation * Math.PI / 180);\n        // This aspect ratio compensation is done so that we can draw the sample with the intended dimensions and\n        // don't need to think about how those dimensions change after the rotation\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.translate(-canvasWidth / 2, -canvasHeight / 2);\n        // Important that we don't use .draw() here since that would take rotation into account, but we wanna handle it\n        // ourselves here\n        context.drawImage(this.toCanvasImageSource(), sx, sy, sWidth, sHeight, dx, dy, newWidth, newHeight);\n    }\n    /** @internal */\n    _rotateSourceRegion(sx, sy, sWidth, sHeight, rotation) {\n        // The provided sx,sy,sWidth,sHeight refer to the final rotated image, but that's not actually how the image is\n        // stored. Therefore, we must map these back onto the original, pre-rotation image.\n        if (rotation === 90) {\n            [sx, sy, sWidth, sHeight] = [\n                sy,\n                this.codedHeight - sx - sWidth,\n                sHeight,\n                sWidth,\n            ];\n        }\n        else if (rotation === 180) {\n            [sx, sy] = [\n                this.codedWidth - sx - sWidth,\n                this.codedHeight - sy - sHeight,\n            ];\n        }\n        else if (rotation === 270) {\n            [sx, sy, sWidth, sHeight] = [\n                this.codedWidth - sy - sHeight,\n                sx,\n                sHeight,\n                sWidth,\n            ];\n        }\n        return { sx, sy, sWidth, sHeight };\n    }\n    /**\n     * Converts this video sample to a\n     * [`CanvasImageSource`](https://udn.realityripple.com/docs/Web/API/CanvasImageSource) for drawing to a canvas.\n     *\n     * You must use the value returned by this method immediately, as any VideoFrame created internally will\n     * automatically be closed in the next microtask.\n     */\n    toCanvasImageSource() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (this._data instanceof Uint8Array) {\n            // Requires VideoFrame to be defined\n            const videoFrame = this.toVideoFrame();\n            queueMicrotask(() => videoFrame.close()); // Let's automatically close the frame in the next microtask\n            return videoFrame;\n        }\n        else {\n            return this._data;\n        }\n    }\n    /** Sets the rotation metadata of this video sample. */\n    setRotation(newRotation) {\n        if (![0, 90, 180, 270].includes(newRotation)) {\n            throw new TypeError('newRotation must be 0, 90, 180, or 270.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.rotation = newRotation;\n    }\n    /** Sets the presentation timestamp of this video sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Sets the duration of this video sample, in seconds. */\n    setDuration(newDuration) {\n        if (!Number.isFinite(newDuration) || newDuration < 0) {\n            throw new TypeError('newDuration must be a non-negative number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.duration = newDuration;\n    }\n    /** Calls `.close()`. */\n    [Symbol.dispose]() {\n        this.close();\n    }\n}\nconst isVideoFrame = (x) => {\n    return typeof VideoFrame !== 'undefined' && x instanceof VideoFrame;\n};\nexport const clampCropRectangle = (crop, outerWidth, outerHeight) => {\n    crop.left = Math.min(crop.left, outerWidth);\n    crop.top = Math.min(crop.top, outerHeight);\n    crop.width = Math.min(crop.width, outerWidth - crop.left);\n    crop.height = Math.min(crop.height, outerHeight - crop.top);\n    assert(crop.width >= 0);\n    assert(crop.height >= 0);\n};\nexport const validateCropRectangle = (crop, prefix) => {\n    if (!crop || typeof crop !== 'object') {\n        throw new TypeError(prefix + 'crop, when provided, must be an object.');\n    }\n    if (!Number.isInteger(crop.left) || crop.left < 0) {\n        throw new TypeError(prefix + 'crop.left must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.top) || crop.top < 0) {\n        throw new TypeError(prefix + 'crop.top must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.width) || crop.width < 0) {\n        throw new TypeError(prefix + 'crop.width must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.height) || crop.height < 0) {\n        throw new TypeError(prefix + 'crop.height must be a non-negative integer.');\n    }\n};\nconst AUDIO_SAMPLE_FORMATS = new Set(['f32', 'f32-planar', 's16', 's16-planar', 's32', 's32-planar', 'u8', 'u8-planar']);\n/**\n * Represents a raw, unencoded audio sample. Mainly used as an expressive wrapper around WebCodecs API's\n * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData), but can also be used standalone.\n * @group Samples\n * @public\n */\nexport class AudioSample {\n    /** The presentation timestamp of the sample in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the sample in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Creates a new {@link AudioSample}, either from an existing\n     * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData) or from raw bytes specified in\n     * {@link AudioSampleInit}.\n     */\n    constructor(init) {\n        /** @internal */\n        this._closed = false;\n        if (isAudioData(init)) {\n            if (init.format === null) {\n                throw new TypeError('AudioData with null format is not supported.');\n            }\n            this._data = init;\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = init.numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp / 1e6;\n            this.duration = init.numberOfFrames / init.sampleRate;\n        }\n        else {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('Invalid AudioDataInit: must be an object.');\n            }\n            if (!AUDIO_SAMPLE_FORMATS.has(init.format)) {\n                throw new TypeError('Invalid AudioDataInit: invalid format.');\n            }\n            if (!Number.isFinite(init.sampleRate) || init.sampleRate <= 0) {\n                throw new TypeError('Invalid AudioDataInit: sampleRate must be > 0.');\n            }\n            if (!Number.isInteger(init.numberOfChannels) || init.numberOfChannels === 0) {\n                throw new TypeError('Invalid AudioDataInit: numberOfChannels must be an integer > 0.');\n            }\n            if (!Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            const numberOfFrames = init.data.byteLength / (getBytesPerSample(init.format) * init.numberOfChannels);\n            if (!Number.isInteger(numberOfFrames)) {\n                throw new TypeError('Invalid AudioDataInit: data size is not a multiple of frame size.');\n            }\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp;\n            this.duration = numberOfFrames / init.sampleRate;\n            let dataBuffer;\n            if (init.data instanceof ArrayBuffer) {\n                dataBuffer = new Uint8Array(init.data);\n            }\n            else if (ArrayBuffer.isView(init.data)) {\n                dataBuffer = new Uint8Array(init.data.buffer, init.data.byteOffset, init.data.byteLength);\n            }\n            else {\n                throw new TypeError('Invalid AudioDataInit: data is not a BufferSource.');\n            }\n            const expectedSize = this.numberOfFrames * this.numberOfChannels * getBytesPerSample(this.format);\n            if (dataBuffer.byteLength < expectedSize) {\n                throw new TypeError('Invalid AudioDataInit: insufficient data size.');\n            }\n            this._data = dataBuffer;\n        }\n    }\n    /** Returns the number of bytes required to hold the audio sample's data as specified by the given options. */\n    allocationSize(options) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const destFormat = options.format ?? this.format;\n        const frameOffset = options.frameOffset ?? 0;\n        if (frameOffset >= this.numberOfFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = options.frameCount !== undefined ? options.frameCount : (this.numberOfFrames - frameOffset);\n        if (copyFrameCount > (this.numberOfFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const bytesPerSample = getBytesPerSample(destFormat);\n        const isPlanar = formatIsPlanar(destFormat);\n        if (isPlanar && options.planeIndex >= this.numberOfChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!isPlanar && options.planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const elementCount = isPlanar ? copyFrameCount : copyFrameCount * this.numberOfChannels;\n        return elementCount * bytesPerSample;\n    }\n    /** Copies the audio sample's data to an ArrayBuffer or ArrayBufferView as specified by the given options. */\n    copyTo(destination, options) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const { planeIndex, format, frameCount: optFrameCount, frameOffset: optFrameOffset } = options;\n        const destFormat = format ?? this.format;\n        if (!destFormat)\n            throw new Error('Destination format not determined');\n        const numFrames = this.numberOfFrames;\n        const numChannels = this.numberOfChannels;\n        const frameOffset = optFrameOffset ?? 0;\n        if (frameOffset >= numFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = optFrameCount !== undefined ? optFrameCount : (numFrames - frameOffset);\n        if (copyFrameCount > (numFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const destBytesPerSample = getBytesPerSample(destFormat);\n        const destIsPlanar = formatIsPlanar(destFormat);\n        if (destIsPlanar && planeIndex >= numChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!destIsPlanar && planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const destElementCount = destIsPlanar ? copyFrameCount : copyFrameCount * numChannels;\n        const requiredSize = destElementCount * destBytesPerSample;\n        if (destination.byteLength < requiredSize) {\n            throw new RangeError('Destination buffer is too small');\n        }\n        const destView = toDataView(destination);\n        const writeFn = getWriteFunction(destFormat);\n        if (isAudioData(this._data)) {\n            if (destIsPlanar) {\n                if (destFormat === 'f32-planar') {\n                    // Simple, since the browser must support f32-planar, we can just delegate here\n                    this._data.copyTo(destination, {\n                        planeIndex,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                }\n                else {\n                    // Allocate temporary buffer for f32-planar data\n                    const tempBuffer = new ArrayBuffer(copyFrameCount * 4);\n                    const tempArray = new Float32Array(tempBuffer);\n                    this._data.copyTo(tempArray, {\n                        planeIndex,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                    // Convert each f32 sample to destination format\n                    const tempView = new DataView(tempBuffer);\n                    for (let i = 0; i < copyFrameCount; i++) {\n                        const destOffset = i * destBytesPerSample;\n                        const sample = tempView.getFloat32(i * 4, true);\n                        writeFn(destView, destOffset, sample);\n                    }\n                }\n            }\n            else {\n                // Destination is interleaved.\n                // Allocate a temporary Float32Array to hold one channel's worth of data.\n                const numCh = numChannels;\n                const temp = new Float32Array(copyFrameCount);\n                for (let ch = 0; ch < numCh; ch++) {\n                    this._data.copyTo(temp, {\n                        planeIndex: ch,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                    for (let i = 0; i < copyFrameCount; i++) {\n                        const destIndex = i * numCh + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        writeFn(destView, destOffset, temp[i]);\n                    }\n                }\n            }\n        }\n        else {\n            // Branch for Uint8Array data (non-AudioData)\n            const uint8Data = this._data;\n            const srcView = new DataView(uint8Data.buffer, uint8Data.byteOffset, uint8Data.byteLength);\n            const srcFormat = this.format;\n            const readFn = getReadFunction(srcFormat);\n            const srcBytesPerSample = getBytesPerSample(srcFormat);\n            const srcIsPlanar = formatIsPlanar(srcFormat);\n            for (let i = 0; i < copyFrameCount; i++) {\n                if (destIsPlanar) {\n                    const destOffset = i * destBytesPerSample;\n                    let srcOffset;\n                    if (srcIsPlanar) {\n                        srcOffset = (planeIndex * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                    }\n                    else {\n                        srcOffset = (((i + frameOffset) * numChannels) + planeIndex) * srcBytesPerSample;\n                    }\n                    const normalized = readFn(srcView, srcOffset);\n                    writeFn(destView, destOffset, normalized);\n                }\n                else {\n                    for (let ch = 0; ch < numChannels; ch++) {\n                        const destIndex = i * numChannels + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        let srcOffset;\n                        if (srcIsPlanar) {\n                            srcOffset = (ch * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                        }\n                        else {\n                            srcOffset = (((i + frameOffset) * numChannels) + ch) * srcBytesPerSample;\n                        }\n                        const normalized = readFn(srcView, srcOffset);\n                        writeFn(destView, destOffset, normalized);\n                    }\n                }\n            }\n        }\n    }\n    /** Clones this audio sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            const sample = new AudioSample(this._data.clone());\n            sample.setTimestamp(this.timestamp); // Make sure the timestamp is precise (beyond microsecond accuracy)\n            return sample;\n        }\n        else {\n            return new AudioSample({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.timestamp,\n                data: this._data,\n            });\n        }\n    }\n    /**\n     * Closes this audio sample, releasing held resources. Audio samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        if (isAudioData(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = new Uint8Array(0);\n        }\n        this._closed = true;\n    }\n    /**\n     * Converts this audio sample to an AudioData for use with the WebCodecs API. The AudioData returned by this\n     * method *must* be closed separately from this audio sample.\n     */\n    toAudioData() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            if (this._data.timestamp === this.microsecondTimestamp) {\n                // Timestamp matches, let's just return the data (but cloned)\n                return this._data.clone();\n            }\n            else {\n                // It's impossible to simply change an AudioData's timestamp, so we'll need to create a new one\n                if (formatIsPlanar(this.format)) {\n                    const size = this.allocationSize({ planeIndex: 0, format: this.format });\n                    const data = new ArrayBuffer(size * this.numberOfChannels);\n                    // We gotta read out each plane individually\n                    for (let i = 0; i < this.numberOfChannels; i++) {\n                        this.copyTo(new Uint8Array(data, i * size, size), { planeIndex: i, format: this.format });\n                    }\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n                else {\n                    const data = new ArrayBuffer(this.allocationSize({ planeIndex: 0, format: this.format }));\n                    this.copyTo(data, { planeIndex: 0, format: this.format });\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n            }\n        }\n        else {\n            return new AudioData({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.microsecondTimestamp,\n                data: this._data,\n            });\n        }\n    }\n    /** Convert this audio sample to an AudioBuffer for use with the Web Audio API. */\n    toAudioBuffer() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const audioBuffer = new AudioBuffer({\n            numberOfChannels: this.numberOfChannels,\n            length: this.numberOfFrames,\n            sampleRate: this.sampleRate,\n        });\n        const dataBytes = new Float32Array(this.allocationSize({ planeIndex: 0, format: 'f32-planar' }) / 4);\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            this.copyTo(dataBytes, { planeIndex: i, format: 'f32-planar' });\n            audioBuffer.copyToChannel(dataBytes, i);\n        }\n        return audioBuffer;\n    }\n    /** Sets the presentation timestamp of this audio sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Calls `.close()`. */\n    [Symbol.dispose]() {\n        this.close();\n    }\n    /** @internal */\n    static *_fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            yield new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n    }\n    /**\n     * Creates AudioSamples from an AudioBuffer, starting at the given timestamp in seconds. Typically creates exactly\n     * one sample, but may create multiple if the AudioBuffer is exceedingly large.\n     */\n    static fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        const result = [];\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            const audioSample = new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            result.push(audioSample);\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n        return result;\n    }\n}\nconst getBytesPerSample = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return 1;\n        case 's16':\n        case 's16-planar':\n            return 2;\n        case 's32':\n        case 's32-planar':\n            return 4;\n        case 'f32':\n        case 'f32-planar':\n            return 4;\n        default:\n            throw new Error('Unknown AudioSampleFormat');\n    }\n};\nconst formatIsPlanar = (format) => {\n    switch (format) {\n        case 'u8-planar':\n        case 's16-planar':\n        case 's32-planar':\n        case 'f32-planar':\n            return true;\n        default:\n            return false;\n    }\n};\nconst getReadFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset) => (view.getUint8(offset) - 128) / 128;\n        case 's16':\n        case 's16-planar':\n            return (view, offset) => view.getInt16(offset, true) / 32768;\n        case 's32':\n        case 's32-planar':\n            return (view, offset) => view.getInt32(offset, true) / 2147483648;\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset) => view.getFloat32(offset, true);\n    }\n};\nconst getWriteFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset, value) => view.setUint8(offset, clamp((value + 1) * 127.5, 0, 255));\n        case 's16':\n        case 's16-planar':\n            return (view, offset, value) => view.setInt16(offset, clamp(Math.round(value * 32767), -32768, 32767), true);\n        case 's32':\n        case 's32-planar':\n            return (view, offset, value) => view.setInt32(offset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), true);\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset, value) => view.setFloat32(offset, value, true);\n    }\n};\nconst isAudioData = (x) => {\n    return typeof AudioData !== 'undefined' && x instanceof AudioData;\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assertNever, textDecoder, textEncoder } from '../misc.js';\nimport { readBytes, readF32Be, readF64Be, readU8 } from '../reader.js';\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLFloat32 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLFloat64 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLSignedInt {\n    constructor(value) {\n        this.value = value;\n    }\n}\nexport class EBMLUnicodeString {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Defines some of the EBML IDs used by Matroska files. */\nexport var EBMLId;\n(function (EBMLId) {\n    EBMLId[EBMLId[\"EBML\"] = 440786851] = \"EBML\";\n    EBMLId[EBMLId[\"EBMLVersion\"] = 17030] = \"EBMLVersion\";\n    EBMLId[EBMLId[\"EBMLReadVersion\"] = 17143] = \"EBMLReadVersion\";\n    EBMLId[EBMLId[\"EBMLMaxIDLength\"] = 17138] = \"EBMLMaxIDLength\";\n    EBMLId[EBMLId[\"EBMLMaxSizeLength\"] = 17139] = \"EBMLMaxSizeLength\";\n    EBMLId[EBMLId[\"DocType\"] = 17026] = \"DocType\";\n    EBMLId[EBMLId[\"DocTypeVersion\"] = 17031] = \"DocTypeVersion\";\n    EBMLId[EBMLId[\"DocTypeReadVersion\"] = 17029] = \"DocTypeReadVersion\";\n    EBMLId[EBMLId[\"Void\"] = 236] = \"Void\";\n    EBMLId[EBMLId[\"Segment\"] = 408125543] = \"Segment\";\n    EBMLId[EBMLId[\"SeekHead\"] = 290298740] = \"SeekHead\";\n    EBMLId[EBMLId[\"Seek\"] = 19899] = \"Seek\";\n    EBMLId[EBMLId[\"SeekID\"] = 21419] = \"SeekID\";\n    EBMLId[EBMLId[\"SeekPosition\"] = 21420] = \"SeekPosition\";\n    EBMLId[EBMLId[\"Duration\"] = 17545] = \"Duration\";\n    EBMLId[EBMLId[\"Info\"] = 357149030] = \"Info\";\n    EBMLId[EBMLId[\"TimestampScale\"] = 2807729] = \"TimestampScale\";\n    EBMLId[EBMLId[\"MuxingApp\"] = 19840] = \"MuxingApp\";\n    EBMLId[EBMLId[\"WritingApp\"] = 22337] = \"WritingApp\";\n    EBMLId[EBMLId[\"Tracks\"] = 374648427] = \"Tracks\";\n    EBMLId[EBMLId[\"TrackEntry\"] = 174] = \"TrackEntry\";\n    EBMLId[EBMLId[\"TrackNumber\"] = 215] = \"TrackNumber\";\n    EBMLId[EBMLId[\"TrackUID\"] = 29637] = \"TrackUID\";\n    EBMLId[EBMLId[\"TrackType\"] = 131] = \"TrackType\";\n    EBMLId[EBMLId[\"FlagEnabled\"] = 185] = \"FlagEnabled\";\n    EBMLId[EBMLId[\"FlagDefault\"] = 136] = \"FlagDefault\";\n    EBMLId[EBMLId[\"FlagForced\"] = 21930] = \"FlagForced\";\n    EBMLId[EBMLId[\"FlagLacing\"] = 156] = \"FlagLacing\";\n    EBMLId[EBMLId[\"Name\"] = 21358] = \"Name\";\n    EBMLId[EBMLId[\"Language\"] = 2274716] = \"Language\";\n    EBMLId[EBMLId[\"LanguageBCP47\"] = 2274717] = \"LanguageBCP47\";\n    EBMLId[EBMLId[\"CodecID\"] = 134] = \"CodecID\";\n    EBMLId[EBMLId[\"CodecPrivate\"] = 25506] = \"CodecPrivate\";\n    EBMLId[EBMLId[\"CodecDelay\"] = 22186] = \"CodecDelay\";\n    EBMLId[EBMLId[\"SeekPreRoll\"] = 22203] = \"SeekPreRoll\";\n    EBMLId[EBMLId[\"DefaultDuration\"] = 2352003] = \"DefaultDuration\";\n    EBMLId[EBMLId[\"Video\"] = 224] = \"Video\";\n    EBMLId[EBMLId[\"PixelWidth\"] = 176] = \"PixelWidth\";\n    EBMLId[EBMLId[\"PixelHeight\"] = 186] = \"PixelHeight\";\n    EBMLId[EBMLId[\"AlphaMode\"] = 21440] = \"AlphaMode\";\n    EBMLId[EBMLId[\"Audio\"] = 225] = \"Audio\";\n    EBMLId[EBMLId[\"SamplingFrequency\"] = 181] = \"SamplingFrequency\";\n    EBMLId[EBMLId[\"Channels\"] = 159] = \"Channels\";\n    EBMLId[EBMLId[\"BitDepth\"] = 25188] = \"BitDepth\";\n    EBMLId[EBMLId[\"SimpleBlock\"] = 163] = \"SimpleBlock\";\n    EBMLId[EBMLId[\"BlockGroup\"] = 160] = \"BlockGroup\";\n    EBMLId[EBMLId[\"Block\"] = 161] = \"Block\";\n    EBMLId[EBMLId[\"BlockAdditions\"] = 30113] = \"BlockAdditions\";\n    EBMLId[EBMLId[\"BlockMore\"] = 166] = \"BlockMore\";\n    EBMLId[EBMLId[\"BlockAdditional\"] = 165] = \"BlockAdditional\";\n    EBMLId[EBMLId[\"BlockAddID\"] = 238] = \"BlockAddID\";\n    EBMLId[EBMLId[\"BlockDuration\"] = 155] = \"BlockDuration\";\n    EBMLId[EBMLId[\"ReferenceBlock\"] = 251] = \"ReferenceBlock\";\n    EBMLId[EBMLId[\"Cluster\"] = 524531317] = \"Cluster\";\n    EBMLId[EBMLId[\"Timestamp\"] = 231] = \"Timestamp\";\n    EBMLId[EBMLId[\"Cues\"] = 475249515] = \"Cues\";\n    EBMLId[EBMLId[\"CuePoint\"] = 187] = \"CuePoint\";\n    EBMLId[EBMLId[\"CueTime\"] = 179] = \"CueTime\";\n    EBMLId[EBMLId[\"CueTrackPositions\"] = 183] = \"CueTrackPositions\";\n    EBMLId[EBMLId[\"CueTrack\"] = 247] = \"CueTrack\";\n    EBMLId[EBMLId[\"CueClusterPosition\"] = 241] = \"CueClusterPosition\";\n    EBMLId[EBMLId[\"Colour\"] = 21936] = \"Colour\";\n    EBMLId[EBMLId[\"MatrixCoefficients\"] = 21937] = \"MatrixCoefficients\";\n    EBMLId[EBMLId[\"TransferCharacteristics\"] = 21946] = \"TransferCharacteristics\";\n    EBMLId[EBMLId[\"Primaries\"] = 21947] = \"Primaries\";\n    EBMLId[EBMLId[\"Range\"] = 21945] = \"Range\";\n    EBMLId[EBMLId[\"Projection\"] = 30320] = \"Projection\";\n    EBMLId[EBMLId[\"ProjectionType\"] = 30321] = \"ProjectionType\";\n    EBMLId[EBMLId[\"ProjectionPoseRoll\"] = 30325] = \"ProjectionPoseRoll\";\n    EBMLId[EBMLId[\"Attachments\"] = 423732329] = \"Attachments\";\n    EBMLId[EBMLId[\"AttachedFile\"] = 24999] = \"AttachedFile\";\n    EBMLId[EBMLId[\"FileDescription\"] = 18046] = \"FileDescription\";\n    EBMLId[EBMLId[\"FileName\"] = 18030] = \"FileName\";\n    EBMLId[EBMLId[\"FileMediaType\"] = 18016] = \"FileMediaType\";\n    EBMLId[EBMLId[\"FileData\"] = 18012] = \"FileData\";\n    EBMLId[EBMLId[\"FileUID\"] = 18094] = \"FileUID\";\n    EBMLId[EBMLId[\"Chapters\"] = 272869232] = \"Chapters\";\n    EBMLId[EBMLId[\"Tags\"] = 307544935] = \"Tags\";\n    EBMLId[EBMLId[\"Tag\"] = 29555] = \"Tag\";\n    EBMLId[EBMLId[\"Targets\"] = 25536] = \"Targets\";\n    EBMLId[EBMLId[\"TargetTypeValue\"] = 26826] = \"TargetTypeValue\";\n    EBMLId[EBMLId[\"TargetType\"] = 25546] = \"TargetType\";\n    EBMLId[EBMLId[\"TagTrackUID\"] = 25541] = \"TagTrackUID\";\n    EBMLId[EBMLId[\"TagEditionUID\"] = 25545] = \"TagEditionUID\";\n    EBMLId[EBMLId[\"TagChapterUID\"] = 25540] = \"TagChapterUID\";\n    EBMLId[EBMLId[\"TagAttachmentUID\"] = 25542] = \"TagAttachmentUID\";\n    EBMLId[EBMLId[\"SimpleTag\"] = 26568] = \"SimpleTag\";\n    EBMLId[EBMLId[\"TagName\"] = 17827] = \"TagName\";\n    EBMLId[EBMLId[\"TagLanguage\"] = 17530] = \"TagLanguage\";\n    EBMLId[EBMLId[\"TagString\"] = 17543] = \"TagString\";\n    EBMLId[EBMLId[\"TagBinary\"] = 17541] = \"TagBinary\";\n    EBMLId[EBMLId[\"ContentEncodings\"] = 28032] = \"ContentEncodings\";\n    EBMLId[EBMLId[\"ContentEncoding\"] = 25152] = \"ContentEncoding\";\n    EBMLId[EBMLId[\"ContentEncodingOrder\"] = 20529] = \"ContentEncodingOrder\";\n    EBMLId[EBMLId[\"ContentEncodingScope\"] = 20530] = \"ContentEncodingScope\";\n    EBMLId[EBMLId[\"ContentCompression\"] = 20532] = \"ContentCompression\";\n    EBMLId[EBMLId[\"ContentCompAlgo\"] = 16980] = \"ContentCompAlgo\";\n    EBMLId[EBMLId[\"ContentCompSettings\"] = 16981] = \"ContentCompSettings\";\n    EBMLId[EBMLId[\"ContentEncryption\"] = 20533] = \"ContentEncryption\";\n})(EBMLId || (EBMLId = {}));\nexport const LEVEL_0_EBML_IDS = [\n    EBMLId.EBML,\n    EBMLId.Segment,\n];\n// All the stuff that can appear in a segment, basically\nexport const LEVEL_1_EBML_IDS = [\n    EBMLId.SeekHead,\n    EBMLId.Info,\n    EBMLId.Cluster,\n    EBMLId.Tracks,\n    EBMLId.Cues,\n    EBMLId.Attachments,\n    EBMLId.Chapters,\n    EBMLId.Tags,\n];\nexport const LEVEL_0_AND_1_EBML_IDS = [\n    ...LEVEL_0_EBML_IDS,\n    ...LEVEL_1_EBML_IDS,\n];\nexport const measureUnsignedInt = (value) => {\n    if (value < (1 << 8)) {\n        return 1;\n    }\n    else if (value < (1 << 16)) {\n        return 2;\n    }\n    else if (value < (1 << 24)) {\n        return 3;\n    }\n    else if (value < 2 ** 32) {\n        return 4;\n    }\n    else if (value < 2 ** 40) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nexport const measureUnsignedBigInt = (value) => {\n    if (value < (1n << 8n)) {\n        return 1;\n    }\n    else if (value < (1n << 16n)) {\n        return 2;\n    }\n    else if (value < (1n << 24n)) {\n        return 3;\n    }\n    else if (value < (1n << 32n)) {\n        return 4;\n    }\n    else if (value < (1n << 40n)) {\n        return 5;\n    }\n    else if (value < (1n << 48n)) {\n        return 6;\n    }\n    else if (value < (1n << 56n)) {\n        return 7;\n    }\n    else {\n        return 8;\n    }\n};\nexport const measureSignedInt = (value) => {\n    if (value >= -(1 << 6) && value < (1 << 6)) {\n        return 1;\n    }\n    else if (value >= -(1 << 13) && value < (1 << 13)) {\n        return 2;\n    }\n    else if (value >= -(1 << 20) && value < (1 << 20)) {\n        return 3;\n    }\n    else if (value >= -(1 << 27) && value < (1 << 27)) {\n        return 4;\n    }\n    else if (value >= -(2 ** 34) && value < 2 ** 34) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nexport const measureVarInt = (value) => {\n    if (value < (1 << 7) - 1) {\n        /** Top bit is set, leaving 7 bits to hold the integer, but we can't store\n         * 127 because \"all bits set to one\" is a reserved value. Same thing for the\n         * other cases below:\n         */\n        return 1;\n    }\n    else if (value < (1 << 14) - 1) {\n        return 2;\n    }\n    else if (value < (1 << 21) - 1) {\n        return 3;\n    }\n    else if (value < (1 << 28) - 1) {\n        return 4;\n    }\n    else if (value < 2 ** 35 - 1) {\n        return 5;\n    }\n    else if (value < 2 ** 42 - 1) {\n        return 6;\n    }\n    else {\n        throw new Error('EBML varint size not supported ' + value);\n    }\n};\nexport class EBMLWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where EBML elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n        /** Same as offsets, but stores position where the element's data starts (after ID and size fields). */\n        this.dataOffsets = new WeakMap();\n    }\n    writeByte(value) {\n        this.helperView.setUint8(0, value);\n        this.writer.write(this.helper.subarray(0, 1));\n    }\n    writeFloat32(value) {\n        this.helperView.setFloat32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeFloat64(value) {\n        this.helperView.setFloat64(0, value, false);\n        this.writer.write(this.helper);\n    }\n    writeUnsignedInt(value, width = measureUnsignedInt(value)) {\n        let pos = 0;\n        // Each case falls through:\n        switch (width) {\n            case 6:\n                // Need to use division to access >32 bits of floating point var\n                this.helperView.setUint8(pos++, (value / 2 ** 40) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 5:\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 4:\n                this.helperView.setUint8(pos++, value >> 24);\n            // eslint-disable-next-line no-fallthrough\n            case 3:\n                this.helperView.setUint8(pos++, value >> 16);\n            // eslint-disable-next-line no-fallthrough\n            case 2:\n                this.helperView.setUint8(pos++, value >> 8);\n            // eslint-disable-next-line no-fallthrough\n            case 1:\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad unsigned int size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeUnsignedBigInt(value, width = measureUnsignedBigInt(value)) {\n        let pos = 0;\n        for (let i = width - 1; i >= 0; i--) {\n            this.helperView.setUint8(pos++, Number((value >> BigInt(i * 8)) & 0xffn));\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeSignedInt(value, width = measureSignedInt(value)) {\n        if (value < 0) {\n            // Two's complement stuff\n            value += 2 ** (width * 8);\n        }\n        this.writeUnsignedInt(value, width);\n    }\n    writeVarInt(value, width = measureVarInt(value)) {\n        let pos = 0;\n        switch (width) {\n            case 1:\n                this.helperView.setUint8(pos++, (1 << 7) | value);\n                break;\n            case 2:\n                this.helperView.setUint8(pos++, (1 << 6) | (value >> 8));\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 3:\n                this.helperView.setUint8(pos++, (1 << 5) | (value >> 16));\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 4:\n                this.helperView.setUint8(pos++, (1 << 4) | (value >> 24));\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 5:\n                /**\n                 * JavaScript converts its doubles to 32-bit integers for bitwise\n                 * operations, so we need to do a division by 2^32 instead of a\n                 * right-shift of 32 to retain those top 3 bits\n                 */\n                this.helperView.setUint8(pos++, (1 << 3) | ((value / 2 ** 32) & 0x7));\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 6:\n                this.helperView.setUint8(pos++, (1 << 2) | ((value / 2 ** 40) & 0x3));\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad EBML varint size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeAsciiString(str) {\n        this.writer.write(new Uint8Array(str.split('').map(x => x.charCodeAt(0))));\n    }\n    writeEBML(data) {\n        if (data === null)\n            return;\n        if (data instanceof Uint8Array) {\n            this.writer.write(data);\n        }\n        else if (Array.isArray(data)) {\n            for (const elem of data) {\n                this.writeEBML(elem);\n            }\n        }\n        else {\n            this.offsets.set(data, this.writer.getPos());\n            this.writeUnsignedInt(data.id); // ID field\n            if (Array.isArray(data.data)) {\n                const sizePos = this.writer.getPos();\n                const sizeSize = data.size === -1 ? 1 : (data.size ?? 4);\n                if (data.size === -1) {\n                    // Write the reserved all-one-bits marker for unknown/unbounded size.\n                    this.writeByte(0xff);\n                }\n                else {\n                    this.writer.seek(this.writer.getPos() + sizeSize);\n                }\n                const startPos = this.writer.getPos();\n                this.dataOffsets.set(data, startPos);\n                this.writeEBML(data.data);\n                if (data.size !== -1) {\n                    const size = this.writer.getPos() - startPos;\n                    const endPos = this.writer.getPos();\n                    this.writer.seek(sizePos);\n                    this.writeVarInt(size, sizeSize);\n                    this.writer.seek(endPos);\n                }\n            }\n            else if (typeof data.data === 'number') {\n                const size = data.size ?? measureUnsignedInt(data.data);\n                this.writeVarInt(size);\n                this.writeUnsignedInt(data.data, size);\n            }\n            else if (typeof data.data === 'bigint') {\n                const size = data.size ?? measureUnsignedBigInt(data.data);\n                this.writeVarInt(size);\n                this.writeUnsignedBigInt(data.data, size);\n            }\n            else if (typeof data.data === 'string') {\n                this.writeVarInt(data.data.length);\n                this.writeAsciiString(data.data);\n            }\n            else if (data.data instanceof Uint8Array) {\n                this.writeVarInt(data.data.byteLength, data.size);\n                this.writer.write(data.data);\n            }\n            else if (data.data instanceof EBMLFloat32) {\n                this.writeVarInt(4);\n                this.writeFloat32(data.data.value);\n            }\n            else if (data.data instanceof EBMLFloat64) {\n                this.writeVarInt(8);\n                this.writeFloat64(data.data.value);\n            }\n            else if (data.data instanceof EBMLSignedInt) {\n                const size = data.size ?? measureSignedInt(data.data.value);\n                this.writeVarInt(size);\n                this.writeSignedInt(data.data.value, size);\n            }\n            else if (data.data instanceof EBMLUnicodeString) {\n                const bytes = textEncoder.encode(data.data.value);\n                this.writeVarInt(bytes.length);\n                this.writer.write(bytes);\n            }\n            else {\n                assertNever(data.data);\n            }\n        }\n    }\n}\nexport const MAX_VAR_INT_SIZE = 8;\nexport const MIN_HEADER_SIZE = 2; // 1-byte ID and 1-byte size\nexport const MAX_HEADER_SIZE = 2 * MAX_VAR_INT_SIZE; // 8-byte ID and 8-byte size\nexport const readVarIntSize = (slice) => {\n    const firstByte = readU8(slice);\n    slice.skip(-1);\n    if (firstByte === 0) {\n        return null; // Invalid VINT\n    }\n    let width = 1;\n    let mask = 0x80;\n    while ((firstByte & mask) === 0) {\n        width++;\n        mask >>= 1;\n    }\n    return width;\n};\nexport const readVarInt = (slice) => {\n    // Read the first byte to determine the width of the variable-length integer\n    const firstByte = readU8(slice);\n    if (firstByte === 0) {\n        return null; // Invalid VINT\n    }\n    // Find the position of VINT_MARKER, which determines the width\n    let width = 1;\n    let mask = 1 << 7;\n    while ((firstByte & mask) === 0) {\n        width++;\n        mask >>= 1;\n    }\n    // First byte's value needs the marker bit cleared\n    let value = firstByte & (mask - 1);\n    // Read remaining bytes\n    for (let i = 1; i < width; i++) {\n        value *= 1 << 8;\n        value += readU8(slice);\n    }\n    return value;\n};\nexport const readUnsignedInt = (slice, width) => {\n    if (width < 1 || width > 8) {\n        throw new Error('Bad unsigned int size ' + width);\n    }\n    let value = 0;\n    // Read bytes from most significant to least significant\n    for (let i = 0; i < width; i++) {\n        value *= 1 << 8;\n        value += readU8(slice);\n    }\n    return value;\n};\nexport const readUnsignedBigInt = (slice, width) => {\n    if (width < 1) {\n        throw new Error('Bad unsigned int size ' + width);\n    }\n    let value = 0n;\n    for (let i = 0; i < width; i++) {\n        value <<= 8n;\n        value += BigInt(readU8(slice));\n    }\n    return value;\n};\nexport const readSignedInt = (slice, width) => {\n    let value = readUnsignedInt(slice, width);\n    // If the highest bit is set, convert from two's complement\n    if (value & (1 << (width * 8 - 1))) {\n        value -= 2 ** (width * 8);\n    }\n    return value;\n};\nexport const readElementId = (slice) => {\n    const size = readVarIntSize(slice);\n    if (size === null) {\n        return null;\n    }\n    const id = readUnsignedInt(slice, size);\n    return id;\n};\nexport const readElementSize = (slice) => {\n    let size = readU8(slice);\n    if (size === 0xff) {\n        size = null;\n    }\n    else {\n        slice.skip(-1);\n        size = readVarInt(slice);\n        // In some (livestreamed) files, this is the value of the size field. While this technically is just a very\n        // large number, it is intended to behave like the reserved size 0xFF, meaning the size is undefined. We\n        // catch the number here. Note that it cannot be perfectly represented as a double, but the comparison works\n        // nonetheless.\n        // eslint-disable-next-line no-loss-of-precision\n        if (size === 0x00ffffffffffffff) {\n            size = null;\n        }\n    }\n    return size;\n};\nexport const readElementHeader = (slice) => {\n    const id = readElementId(slice);\n    if (id === null) {\n        return null;\n    }\n    const size = readElementSize(slice);\n    return { id, size };\n};\nexport const readAsciiString = (slice, length) => {\n    const bytes = readBytes(slice, length);\n    // Actual string length might be shorter due to null terminators\n    let strLength = 0;\n    while (strLength < length && bytes[strLength] !== 0) {\n        strLength += 1;\n    }\n    return String.fromCharCode(...bytes.subarray(0, strLength));\n};\nexport const readUnicodeString = (slice, length) => {\n    const bytes = readBytes(slice, length);\n    // Actual string length might be shorter due to null terminators\n    let strLength = 0;\n    while (strLength < length && bytes[strLength] !== 0) {\n        strLength += 1;\n    }\n    return textDecoder.decode(bytes.subarray(0, strLength));\n};\nexport const readFloat = (slice, width) => {\n    if (width === 0) {\n        return 0;\n    }\n    if (width !== 4 && width !== 8) {\n        throw new Error('Bad float size ' + width);\n    }\n    return width === 4 ? readF32Be(slice) : readF64Be(slice);\n};\n/** Returns the byte offset in the file of the next element with a matching ID. */\nexport const searchForNextElementId = async (reader, startPos, ids, until) => {\n    const idsSet = new Set(ids);\n    let currentPos = startPos;\n    while (until === null || currentPos < until) {\n        let slice = reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        const elementHeader = readElementHeader(slice);\n        if (!elementHeader) {\n            break;\n        }\n        if (idsSet.has(elementHeader.id)) {\n            return { pos: currentPos, found: true };\n        }\n        assertDefinedSize(elementHeader.size);\n        currentPos = slice.filePos + elementHeader.size;\n    }\n    return { pos: (until !== null && until > currentPos) ? until : currentPos, found: false };\n};\n/** Searches for the next occurrence of an element ID using a naive byte-wise search. */\nexport const resync = async (reader, startPos, ids, until) => {\n    const CHUNK_SIZE = 2 ** 16; // So we don't need to grab thousands of slices\n    const idsSet = new Set(ids);\n    let currentPos = startPos;\n    while (currentPos < until) {\n        let slice = reader.requestSliceRange(currentPos, 0, Math.min(CHUNK_SIZE, until - currentPos));\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        if (slice.length < MAX_VAR_INT_SIZE)\n            break;\n        for (let i = 0; i < slice.length - MAX_VAR_INT_SIZE; i++) {\n            slice.filePos = currentPos;\n            const elementId = readElementId(slice);\n            if (elementId !== null && idsSet.has(elementId)) {\n                return currentPos;\n            }\n            currentPos++;\n        }\n    }\n    return null;\n};\nexport const CODEC_STRING_MAP = {\n    'avc': 'V_MPEG4/ISO/AVC',\n    'hevc': 'V_MPEGH/ISO/HEVC',\n    'vp8': 'V_VP8',\n    'vp9': 'V_VP9',\n    'av1': 'V_AV1',\n    'aac': 'A_AAC',\n    'mp3': 'A_MPEG/L3',\n    'opus': 'A_OPUS',\n    'vorbis': 'A_VORBIS',\n    'flac': 'A_FLAC',\n    'pcm-u8': 'A_PCM/INT/LIT',\n    'pcm-s16': 'A_PCM/INT/LIT',\n    'pcm-s16be': 'A_PCM/INT/BIG',\n    'pcm-s24': 'A_PCM/INT/LIT',\n    'pcm-s24be': 'A_PCM/INT/BIG',\n    'pcm-s32': 'A_PCM/INT/LIT',\n    'pcm-s32be': 'A_PCM/INT/BIG',\n    'pcm-f32': 'A_PCM/FLOAT/IEEE',\n    'pcm-f64': 'A_PCM/FLOAT/IEEE',\n    'webvtt': 'S_TEXT/WEBVTT',\n};\nexport function assertDefinedSize(size) {\n    if (size === null) {\n        throw new Error('Undefined element size is used in a place where it is not supported.');\n    }\n}\n;\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst cueBlockHeaderRegex = /(?:(.+?)\\n)?((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})\\s+-->\\s+((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})/g;\nconst preambleStartRegex = /^WEBVTT(.|\\n)*?\\n{2}/;\nexport const inlineTimestampRegex = /<(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})>/g;\nexport class SubtitleParser {\n    constructor(options) {\n        this.preambleText = null;\n        this.preambleEmitted = false;\n        this.options = options;\n    }\n    parse(text) {\n        text = text.replaceAll('\\r\\n', '\\n').replaceAll('\\r', '\\n');\n        cueBlockHeaderRegex.lastIndex = 0;\n        let match;\n        if (!this.preambleText) {\n            if (!preambleStartRegex.test(text)) {\n                throw new Error('WebVTT preamble incorrect.');\n            }\n            match = cueBlockHeaderRegex.exec(text);\n            const preamble = text.slice(0, match?.index ?? text.length).trimEnd();\n            if (!preamble) {\n                throw new Error('No WebVTT preamble provided.');\n            }\n            this.preambleText = preamble;\n            if (match) {\n                text = text.slice(match.index);\n                cueBlockHeaderRegex.lastIndex = 0;\n            }\n        }\n        while ((match = cueBlockHeaderRegex.exec(text))) {\n            const notes = text.slice(0, match.index);\n            const cueIdentifier = match[1];\n            const matchEnd = match.index + match[0].length;\n            const bodyStart = text.indexOf('\\n', matchEnd) + 1;\n            const cueSettings = text.slice(matchEnd, bodyStart).trim();\n            let bodyEnd = text.indexOf('\\n\\n', matchEnd);\n            if (bodyEnd === -1)\n                bodyEnd = text.length;\n            const startTime = parseSubtitleTimestamp(match[2]);\n            const endTime = parseSubtitleTimestamp(match[3]);\n            const duration = endTime - startTime;\n            const body = text.slice(bodyStart, bodyEnd).trim();\n            text = text.slice(bodyEnd).trimStart();\n            cueBlockHeaderRegex.lastIndex = 0;\n            const cue = {\n                timestamp: startTime / 1000,\n                duration: duration / 1000,\n                text: body,\n                identifier: cueIdentifier,\n                settings: cueSettings,\n                notes,\n            };\n            const meta = {};\n            if (!this.preambleEmitted) {\n                meta.config = {\n                    description: this.preambleText,\n                };\n                this.preambleEmitted = true;\n            }\n            this.options.output(cue, meta);\n        }\n    }\n}\nconst timestampRegex = /(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})/;\nexport const parseSubtitleTimestamp = (string) => {\n    const match = timestampRegex.exec(string);\n    if (!match)\n        throw new Error('Expected match.');\n    return 60 * 60 * 1000 * Number(match[1] || '0')\n        + 60 * 1000 * Number(match[2])\n        + 1000 * Number(match[3])\n        + Number(match[4]);\n};\nexport const formatSubtitleTimestamp = (timestamp) => {\n    const hours = Math.floor(timestamp / (60 * 60 * 1000));\n    const minutes = Math.floor((timestamp % (60 * 60 * 1000)) / (60 * 1000));\n    const seconds = Math.floor((timestamp % (60 * 1000)) / 1000);\n    const milliseconds = timestamp % 1000;\n    return hours.toString().padStart(2, '0') + ':'\n        + minutes.toString().padStart(2, '0') + ':'\n        + seconds.toString().padStart(2, '0') + '.'\n        + milliseconds.toString().padStart(3, '0');\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert } from './misc.js';\nexport class Writer {\n    constructor() {\n        /** Setting this to true will cause the writer to ensure data is written in a strictly monotonic, streamable way. */\n        this.ensureMonotonicity = false;\n        this.trackedWrites = null;\n        this.trackedStart = -1;\n        this.trackedEnd = -1;\n    }\n    start() { }\n    maybeTrackWrites(data) {\n        if (!this.trackedWrites) {\n            return;\n        }\n        // Handle negative relative write positions\n        let pos = this.getPos();\n        if (pos < this.trackedStart) {\n            if (pos + data.byteLength <= this.trackedStart) {\n                return;\n            }\n            data = data.subarray(this.trackedStart - pos);\n            pos = 0;\n        }\n        const neededSize = pos + data.byteLength - this.trackedStart;\n        let newLength = this.trackedWrites.byteLength;\n        while (newLength < neededSize) {\n            newLength *= 2;\n        }\n        // Check if we need to resize the buffer\n        if (newLength !== this.trackedWrites.byteLength) {\n            const copy = new Uint8Array(newLength);\n            copy.set(this.trackedWrites, 0);\n            this.trackedWrites = copy;\n        }\n        this.trackedWrites.set(data, pos - this.trackedStart);\n        this.trackedEnd = Math.max(this.trackedEnd, pos + data.byteLength);\n    }\n    startTrackingWrites() {\n        this.trackedWrites = new Uint8Array(2 ** 10);\n        this.trackedStart = this.getPos();\n        this.trackedEnd = this.trackedStart;\n    }\n    stopTrackingWrites() {\n        if (!this.trackedWrites) {\n            throw new Error('Internal error: Can\\'t get tracked writes since nothing was tracked.');\n        }\n        const slice = this.trackedWrites.subarray(0, this.trackedEnd - this.trackedStart);\n        const result = {\n            data: slice,\n            start: this.trackedStart,\n            end: this.trackedEnd,\n        };\n        this.trackedWrites = null;\n        return result;\n    }\n}\nconst ARRAY_BUFFER_INITIAL_SIZE = 2 ** 16;\nconst ARRAY_BUFFER_MAX_SIZE = 2 ** 32;\nexport class BufferTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.maxPos = 0;\n        this.target = target;\n        this.supportsResize = 'resize' in new ArrayBuffer(0);\n        if (this.supportsResize) {\n            try {\n                // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE, { maxByteLength: ARRAY_BUFFER_MAX_SIZE });\n            }\n            catch {\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n                this.supportsResize = false;\n            }\n        }\n        else {\n            this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n        }\n        this.bytes = new Uint8Array(this.buffer);\n    }\n    ensureSize(size) {\n        let newLength = this.buffer.byteLength;\n        while (newLength < size)\n            newLength *= 2;\n        if (newLength === this.buffer.byteLength)\n            return;\n        if (newLength > ARRAY_BUFFER_MAX_SIZE) {\n            throw new Error(`ArrayBuffer exceeded maximum size of ${ARRAY_BUFFER_MAX_SIZE} bytes. Please consider using another`\n                + ` target.`);\n        }\n        if (this.supportsResize) {\n            // Use resize if it exists\n            // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            this.buffer.resize(newLength);\n            // The Uint8Array scales automatically\n        }\n        else {\n            const newBuffer = new ArrayBuffer(newLength);\n            const newBytes = new Uint8Array(newBuffer);\n            newBytes.set(this.bytes, 0);\n            this.buffer = newBuffer;\n            this.bytes = newBytes;\n        }\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.ensureSize(this.pos + data.byteLength);\n        this.bytes.set(data, this.pos);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.maxPos = Math.max(this.maxPos, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() { }\n    async finalize() {\n        this.ensureSize(this.pos);\n        this.target.buffer = this.buffer.slice(0, Math.max(this.maxPos, this.pos));\n    }\n    async close() { }\n    getSlice(start, end) {\n        return this.bytes.slice(start, end);\n    }\n}\nconst DEFAULT_CHUNK_SIZE = 2 ** 24;\nconst MAX_CHUNKS_AT_ONCE = 2;\n/**\n * Writes to a StreamTarget every time it is flushed, sending out all of the new data written since the\n * last flush. This is useful for streaming applications, like piping the output to disk. When using the chunked mode,\n * data will first be accumulated in larger chunks, and then the entire chunk will be flushed out at once when ready.\n */\nexport class StreamTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.sections = [];\n        this.lastWriteEnd = 0;\n        this.lastFlushEnd = 0;\n        this.writer = null;\n        /**\n         * The data is divided up into fixed-size chunks, whose contents are first filled in RAM and then flushed out.\n         * A chunk is flushed if all of its contents have been written.\n         */\n        this.chunks = [];\n        this.target = target;\n        this.chunked = target._options.chunked ?? false;\n        this.chunkSize = target._options.chunkSize ?? DEFAULT_CHUNK_SIZE;\n    }\n    start() {\n        this.writer = this.target._writable.getWriter();\n    }\n    write(data) {\n        if (this.pos > this.lastWriteEnd) {\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        this.maybeTrackWrites(data);\n        this.sections.push({\n            data: data.slice(),\n            start: this.pos,\n        });\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.lastWriteEnd = Math.max(this.lastWriteEnd, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() {\n        if (this.pos > this.lastWriteEnd) {\n            // There's a \"void\" between the last written byte and the next byte we're about to write. Let's pad that\n            // void with zeroes explicitly.\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        assert(this.writer);\n        if (this.sections.length === 0)\n            return;\n        const chunks = [];\n        const sorted = [...this.sections].sort((a, b) => a.start - b.start);\n        chunks.push({\n            start: sorted[0].start,\n            size: sorted[0].data.byteLength,\n        });\n        // Figure out how many contiguous chunks we have\n        for (let i = 1; i < sorted.length; i++) {\n            const lastChunk = chunks[chunks.length - 1];\n            const section = sorted[i];\n            if (section.start <= lastChunk.start + lastChunk.size) {\n                lastChunk.size = Math.max(lastChunk.size, section.start + section.data.byteLength - lastChunk.start);\n            }\n            else {\n                chunks.push({\n                    start: section.start,\n                    size: section.data.byteLength,\n                });\n            }\n        }\n        for (const chunk of chunks) {\n            chunk.data = new Uint8Array(chunk.size);\n            // Make sure to write the data in the correct order for correct overwriting\n            for (const section of this.sections) {\n                // Check if the section is in the chunk\n                if (chunk.start <= section.start && section.start < chunk.start + chunk.size) {\n                    chunk.data.set(section.data, section.start - chunk.start);\n                }\n            }\n            if (this.writer.desiredSize !== null && this.writer.desiredSize <= 0) {\n                await this.writer.ready; // Allow the writer to apply backpressure\n            }\n            if (this.chunked) {\n                // Let's first gather the data into bigger chunks before writing it\n                this.writeDataIntoChunks(chunk.data, chunk.start);\n                this.tryToFlushChunks();\n            }\n            else {\n                if (this.ensureMonotonicity && chunk.start !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                // Write out the data immediately\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data,\n                    position: chunk.start,\n                });\n                this.lastFlushEnd = chunk.start + chunk.data.byteLength;\n            }\n        }\n        this.sections.length = 0;\n    }\n    writeDataIntoChunks(data, position) {\n        // First, find the chunk to write the data into, or create one if none exists\n        let chunkIndex = this.chunks.findIndex(x => x.start <= position && position < x.start + this.chunkSize);\n        if (chunkIndex === -1)\n            chunkIndex = this.createChunk(position);\n        const chunk = this.chunks[chunkIndex];\n        // Figure out how much to write to the chunk, and then write to the chunk\n        const relativePosition = position - chunk.start;\n        const toWrite = data.subarray(0, Math.min(this.chunkSize - relativePosition, data.byteLength));\n        chunk.data.set(toWrite, relativePosition);\n        // Create a section describing the region of data that was just written to\n        const section = {\n            start: relativePosition,\n            end: relativePosition + toWrite.byteLength,\n        };\n        this.insertSectionIntoChunk(chunk, section);\n        // Queue chunk for flushing to target if it has been fully written to\n        if (chunk.written[0].start === 0 && chunk.written[0].end === this.chunkSize) {\n            chunk.shouldFlush = true;\n        }\n        // Make sure we don't hold too many chunks in memory at once to keep memory usage down\n        if (this.chunks.length > MAX_CHUNKS_AT_ONCE) {\n            // Flush all but the last chunk\n            for (let i = 0; i < this.chunks.length - 1; i++) {\n                this.chunks[i].shouldFlush = true;\n            }\n            this.tryToFlushChunks();\n        }\n        // If the data didn't fit in one chunk, recurse with the remaining data\n        if (toWrite.byteLength < data.byteLength) {\n            this.writeDataIntoChunks(data.subarray(toWrite.byteLength), position + toWrite.byteLength);\n        }\n    }\n    insertSectionIntoChunk(chunk, section) {\n        let low = 0;\n        let high = chunk.written.length - 1;\n        let index = -1;\n        // Do a binary search to find the last section with a start not larger than `section`'s start\n        while (low <= high) {\n            const mid = Math.floor(low + (high - low + 1) / 2);\n            if (chunk.written[mid].start <= section.start) {\n                low = mid + 1;\n                index = mid;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        // Insert the new section\n        chunk.written.splice(index + 1, 0, section);\n        if (index === -1 || chunk.written[index].end < section.start)\n            index++;\n        // Merge overlapping sections\n        while (index < chunk.written.length - 1 && chunk.written[index].end >= chunk.written[index + 1].start) {\n            chunk.written[index].end = Math.max(chunk.written[index].end, chunk.written[index + 1].end);\n            chunk.written.splice(index + 1, 1);\n        }\n    }\n    createChunk(includesPosition) {\n        const start = Math.floor(includesPosition / this.chunkSize) * this.chunkSize;\n        const chunk = {\n            start,\n            data: new Uint8Array(this.chunkSize),\n            written: [],\n            shouldFlush: false,\n        };\n        this.chunks.push(chunk);\n        this.chunks.sort((a, b) => a.start - b.start);\n        return this.chunks.indexOf(chunk);\n    }\n    tryToFlushChunks(force = false) {\n        assert(this.writer);\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            if (!chunk.shouldFlush && !force)\n                continue;\n            for (const section of chunk.written) {\n                const position = chunk.start + section.start;\n                if (this.ensureMonotonicity && position !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data.subarray(section.start, section.end),\n                    position,\n                });\n                this.lastFlushEnd = chunk.start + section.end;\n            }\n            this.chunks.splice(i--, 1);\n        }\n    }\n    finalize() {\n        if (this.chunked) {\n            this.tryToFlushChunks(true);\n        }\n        assert(this.writer);\n        return this.writer.close();\n    }\n    async close() {\n        return this.writer?.close();\n    }\n}\nexport class NullTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.target = target;\n        this.pos = 0;\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n    }\n    getPos() {\n        return this.pos;\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    async flush() { }\n    async finalize() { }\n    async close() { }\n}\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { BufferTargetWriter, NullTargetWriter, StreamTargetWriter } from './writer.js';\nimport * as nodeAlias from './node.js';\nimport { assert } from './misc.js';\nconst node = typeof nodeAlias !== 'undefined'\n    ? nodeAlias // Aliasing it prevents some bundler warnings\n    : undefined;\n/**\n * Base class for targets, specifying where output files are written.\n * @group Output targets\n * @public\n */\nexport class Target {\n    constructor() {\n        /** @internal */\n        this._output = null;\n        /**\n         * Called each time data is written to the target. Will be called with the byte range into which data was written.\n         *\n         * Use this callback to track the size of the output file as it grows. But be warned, this function is chatty and\n         * gets called *extremely* often.\n         */\n        this.onwrite = null;\n    }\n}\n/**\n * A target that writes data directly into an ArrayBuffer in memory. Great for performance, but not suitable for very\n * large files. The buffer will be available once the output has been finalized.\n * @group Output targets\n * @public\n */\nexport class BufferTarget extends Target {\n    constructor() {\n        super(...arguments);\n        /** Stores the final output buffer. Until the output is finalized, this will be `null`. */\n        this.buffer = null;\n    }\n    /** @internal */\n    _createWriter() {\n        return new BufferTargetWriter(this);\n    }\n}\n/**\n * This target writes data to a [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream),\n * making it a general-purpose target for writing data anywhere. It is also compatible with\n * [`FileSystemWritableFileStream`](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream) for\n * use with the [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API). The\n * `WritableStream` can also apply backpressure, which will propagate to the output and throttle the encoders.\n * @group Output targets\n * @public\n */\nexport class StreamTarget extends Target {\n    /** Creates a new {@link StreamTarget} which writes to the specified `writable`. */\n    constructor(writable, options = {}) {\n        super();\n        if (!(writable instanceof WritableStream)) {\n            throw new TypeError('StreamTarget requires a WritableStream instance.');\n        }\n        if (options != null && typeof options !== 'object') {\n            throw new TypeError('StreamTarget options, when provided, must be an object.');\n        }\n        if (options.chunked !== undefined && typeof options.chunked !== 'boolean') {\n            throw new TypeError('options.chunked, when provided, must be a boolean.');\n        }\n        if (options.chunkSize !== undefined && (!Number.isInteger(options.chunkSize) || options.chunkSize < 1024)) {\n            throw new TypeError('options.chunkSize, when provided, must be an integer and not smaller than 1024.');\n        }\n        this._writable = writable;\n        this._options = options;\n    }\n    /** @internal */\n    _createWriter() {\n        return new StreamTargetWriter(this);\n    }\n}\n/**\n * A target that writes to a file at the specified path. Intended for server-side usage in Node, Bun, or Deno.\n *\n * Writing is chunked by default. The internally held file handle will be closed when `.finalize()` or `.cancel()` are\n * called on the corresponding {@link Output}.\n * @group Output targets\n * @public\n */\nexport class FilePathTarget extends Target {\n    /** Creates a new {@link FilePathTarget} that writes to the file at the specified file path. */\n    constructor(filePath, options = {}) {\n        if (typeof filePath !== 'string') {\n            throw new TypeError('filePath must be a string.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        super();\n        /** @internal */\n        this._fileHandle = null;\n        // Let's back this target with a StreamTarget, makes the implementation very simple\n        const writable = new WritableStream({\n            start: async () => {\n                this._fileHandle = await node.fs.open(filePath, 'w');\n            },\n            write: async (chunk) => {\n                assert(this._fileHandle);\n                await this._fileHandle.write(chunk.data, 0, chunk.data.byteLength, chunk.position);\n            },\n            close: async () => {\n                if (this._fileHandle) {\n                    await this._fileHandle.close();\n                    this._fileHandle = null;\n                }\n            },\n        });\n        this._streamTarget = new StreamTarget(writable, {\n            chunked: true,\n            ...options,\n        });\n        this._streamTarget._output = this._output;\n    }\n    /** @internal */\n    _createWriter() {\n        return this._streamTarget._createWriter();\n    }\n}\n/**\n * This target just discards all incoming data. It is useful for when you need an {@link Output} but extract data from\n * it differently, for example through format-specific callbacks (`onMoof`, `onMdat`, ...) or encoder events.\n * @group Output targets\n * @public\n */\nexport class NullTarget extends Target {\n    /** @internal */\n    _createWriter() {\n        return new NullTargetWriter(this);\n    }\n}\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, UNDETERMINED_LANGUAGE, assert, assertNever, colorSpaceIsComplete, imageMimeTypeToExtension, keyValueIterator, normalizeRotation, promiseWithResolvers, roundToMultiple, textEncoder, toUint8Array, uint8ArraysAreEqual, writeBits, } from '../misc.js';\nimport { CODEC_STRING_MAP, EBMLFloat32, EBMLFloat64, EBMLId, EBMLSignedInt, EBMLUnicodeString, EBMLWriter, } from './ebml.js';\nimport { buildMatroskaMimeType } from './matroska-misc.js';\nimport { WebMOutputFormat } from '../output-format.js';\nimport { formatSubtitleTimestamp, inlineTimestampRegex, parseSubtitleTimestamp, } from '../subtitles.js';\nimport { OPUS_SAMPLE_RATE, PCM_AUDIO_CODECS, generateAv1CodecConfigurationFromCodecString, generateVp9CodecConfigurationFromCodecString, parsePcmCodec, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { Muxer } from '../muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nimport { AttachedFile } from '../tags.js';\nconst MIN_CLUSTER_TIMESTAMP_MS = -(2 ** 15);\nconst MAX_CLUSTER_TIMESTAMP_MS = 2 ** 15 - 1;\nconst APP_NAME = 'Mediabunny';\nconst SEGMENT_SIZE_BYTES = 6;\nconst CLUSTER_SIZE_BYTES = 5;\nconst TRACK_TYPE_MAP = {\n    video: 1,\n    audio: 2,\n    subtitle: 17,\n};\nexport class MatroskaMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.segment = null;\n        this.segmentInfo = null;\n        this.seekHead = null;\n        this.tracksElement = null;\n        this.tagsElement = null;\n        this.attachmentsElement = null;\n        this.segmentDuration = null;\n        this.cues = null;\n        this.currentCluster = null;\n        this.currentClusterStartMsTimestamp = null;\n        this.currentClusterMaxMsTimestamp = null;\n        this.trackDatasInCurrentCluster = new Map();\n        this.duration = 0;\n        this.writer = output._writer;\n        this.format = format;\n        this.ebmlWriter = new EBMLWriter(this.writer);\n        if (this.format._options.appendOnly) {\n            this.writer.ensureMonotonicity = true;\n        }\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        this.writeEBMLHeader();\n        this.createSegmentInfo();\n        this.createCues();\n        await this.writer.flush();\n        release();\n    }\n    writeEBMLHeader() {\n        if (this.format._options.onEbmlHeader) {\n            this.writer.startTrackingWrites();\n        }\n        const ebmlHeader = { id: EBMLId.EBML, data: [\n                { id: EBMLId.EBMLVersion, data: 1 },\n                { id: EBMLId.EBMLReadVersion, data: 1 },\n                { id: EBMLId.EBMLMaxIDLength, data: 4 },\n                { id: EBMLId.EBMLMaxSizeLength, data: 8 },\n                { id: EBMLId.DocType, data: this.format instanceof WebMOutputFormat ? 'webm' : 'matroska' },\n                { id: EBMLId.DocTypeVersion, data: 2 },\n                { id: EBMLId.DocTypeReadVersion, data: 2 },\n            ] };\n        this.ebmlWriter.writeEBML(ebmlHeader);\n        if (this.format._options.onEbmlHeader) {\n            const { data, start } = this.writer.stopTrackingWrites(); // start should be 0\n            this.format._options.onEbmlHeader(data, start);\n        }\n    }\n    /**\n     * Creates a SeekHead element which is positioned near the start of the file and allows the media player to seek to\n     * relevant sections more easily. Since we don't know the positions of those sections yet, we'll set them later.\n     */\n    maybeCreateSeekHead(writeOffsets) {\n        if (this.format._options.appendOnly) {\n            return;\n        }\n        const kaxCues = new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]);\n        const kaxInfo = new Uint8Array([0x15, 0x49, 0xa9, 0x66]);\n        const kaxTracks = new Uint8Array([0x16, 0x54, 0xae, 0x6b]);\n        const kaxAttachments = new Uint8Array([0x19, 0x41, 0xa4, 0x69]);\n        const kaxTags = new Uint8Array([0x12, 0x54, 0xc3, 0x67]);\n        const seekHead = { id: EBMLId.SeekHead, data: [\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxCues },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.cues) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxInfo },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.segmentInfo) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxTracks },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.tracksElement) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                this.attachmentsElement\n                    ? { id: EBMLId.Seek, data: [\n                            { id: EBMLId.SeekID, data: kaxAttachments },\n                            {\n                                id: EBMLId.SeekPosition,\n                                size: 5,\n                                data: writeOffsets\n                                    ? this.ebmlWriter.offsets.get(this.attachmentsElement) - this.segmentDataOffset\n                                    : 0,\n                            },\n                        ] }\n                    : null,\n                this.tagsElement\n                    ? { id: EBMLId.Seek, data: [\n                            { id: EBMLId.SeekID, data: kaxTags },\n                            {\n                                id: EBMLId.SeekPosition,\n                                size: 5,\n                                data: writeOffsets\n                                    ? this.ebmlWriter.offsets.get(this.tagsElement) - this.segmentDataOffset\n                                    : 0,\n                            },\n                        ] }\n                    : null,\n            ] };\n        this.seekHead = seekHead;\n    }\n    createSegmentInfo() {\n        const segmentDuration = { id: EBMLId.Duration, data: new EBMLFloat64(0) };\n        this.segmentDuration = segmentDuration;\n        const segmentInfo = { id: EBMLId.Info, data: [\n                { id: EBMLId.TimestampScale, data: 1e6 },\n                { id: EBMLId.MuxingApp, data: APP_NAME },\n                { id: EBMLId.WritingApp, data: APP_NAME },\n                !this.format._options.appendOnly ? segmentDuration : null,\n            ] };\n        this.segmentInfo = segmentInfo;\n    }\n    createTracks() {\n        const tracksElement = { id: EBMLId.Tracks, data: [] };\n        this.tracksElement = tracksElement;\n        for (const trackData of this.trackDatas) {\n            const codecId = CODEC_STRING_MAP[trackData.track.source._codec];\n            assert(codecId);\n            let seekPreRollNs = 0;\n            if (trackData.type === 'audio' && trackData.track.source._codec === 'opus') {\n                seekPreRollNs = 1e6 * 80; // In \"Matroska ticks\" (nanoseconds)\n                const description = trackData.info.decoderConfig.description;\n                if (description) {\n                    const bytes = toUint8Array(description);\n                    const header = parseOpusIdentificationHeader(bytes);\n                    // Use the preSkip value from the header\n                    seekPreRollNs = Math.round(1e9 * (header.preSkip / OPUS_SAMPLE_RATE));\n                }\n            }\n            tracksElement.data.push({ id: EBMLId.TrackEntry, data: [\n                    { id: EBMLId.TrackNumber, data: trackData.track.id },\n                    { id: EBMLId.TrackUID, data: trackData.track.id },\n                    { id: EBMLId.TrackType, data: TRACK_TYPE_MAP[trackData.type] },\n                    { id: EBMLId.FlagLacing, data: 0 },\n                    { id: EBMLId.Language, data: trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE },\n                    { id: EBMLId.CodecID, data: codecId },\n                    { id: EBMLId.CodecDelay, data: 0 },\n                    { id: EBMLId.SeekPreRoll, data: seekPreRollNs },\n                    trackData.track.metadata.name !== undefined\n                        ? { id: EBMLId.Name, data: new EBMLUnicodeString(trackData.track.metadata.name) }\n                        : null,\n                    (trackData.type === 'video' ? this.videoSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'audio' ? this.audioSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'subtitle' ? this.subtitleSpecificTrackInfo(trackData) : null),\n                ] });\n        }\n    }\n    videoSpecificTrackInfo(trackData) {\n        const { frameRate, rotation } = trackData.track.metadata;\n        const elements = [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: EBMLId.CodecPrivate,\n                    data: toUint8Array(trackData.info.decoderConfig.description),\n                }\n                : null),\n            (frameRate\n                ? {\n                    id: EBMLId.DefaultDuration,\n                    data: 1e9 / frameRate,\n                }\n                : null),\n        ];\n        // Convert from clockwise to counter-clockwise\n        const flippedRotation = rotation ? normalizeRotation(-rotation) : 0;\n        const colorSpace = trackData.info.decoderConfig.colorSpace;\n        const videoElement = { id: EBMLId.Video, data: [\n                { id: EBMLId.PixelWidth, data: trackData.info.width },\n                { id: EBMLId.PixelHeight, data: trackData.info.height },\n                trackData.info.alphaMode ? { id: EBMLId.AlphaMode, data: 1 } : null,\n                (colorSpaceIsComplete(colorSpace)\n                    ? {\n                        id: EBMLId.Colour,\n                        data: [\n                            {\n                                id: EBMLId.MatrixCoefficients,\n                                data: MATRIX_COEFFICIENTS_MAP[colorSpace.matrix],\n                            },\n                            {\n                                id: EBMLId.TransferCharacteristics,\n                                data: TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer],\n                            },\n                            {\n                                id: EBMLId.Primaries,\n                                data: COLOR_PRIMARIES_MAP[colorSpace.primaries],\n                            },\n                            {\n                                id: EBMLId.Range,\n                                data: colorSpace.fullRange ? 2 : 1,\n                            },\n                        ],\n                    }\n                    : null),\n                (flippedRotation\n                    ? {\n                        id: EBMLId.Projection,\n                        data: [\n                            {\n                                id: EBMLId.ProjectionType,\n                                data: 0, // rectangular\n                            },\n                            {\n                                id: EBMLId.ProjectionPoseRoll,\n                                data: new EBMLFloat32((flippedRotation + 180) % 360 - 180), // [0, 270] -> [-180, 90]\n                            },\n                        ],\n                    }\n                    : null),\n            ] };\n        elements.push(videoElement);\n        return elements;\n    }\n    audioSpecificTrackInfo(trackData) {\n        const pcmInfo = PCM_AUDIO_CODECS.includes(trackData.track.source._codec)\n            ? parsePcmCodec(trackData.track.source._codec)\n            : null;\n        return [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: EBMLId.CodecPrivate,\n                    data: toUint8Array(trackData.info.decoderConfig.description),\n                }\n                : null),\n            { id: EBMLId.Audio, data: [\n                    { id: EBMLId.SamplingFrequency, data: new EBMLFloat32(trackData.info.sampleRate) },\n                    { id: EBMLId.Channels, data: trackData.info.numberOfChannels },\n                    pcmInfo ? { id: EBMLId.BitDepth, data: 8 * pcmInfo.sampleSize } : null,\n                ] },\n        ];\n    }\n    subtitleSpecificTrackInfo(trackData) {\n        return [\n            { id: EBMLId.CodecPrivate, data: textEncoder.encode(trackData.info.config.description) },\n        ];\n    }\n    maybeCreateTags() {\n        const simpleTags = [];\n        const addSimpleTag = (key, value) => {\n            simpleTags.push({ id: EBMLId.SimpleTag, data: [\n                    { id: EBMLId.TagName, data: new EBMLUnicodeString(key) },\n                    typeof value === 'string'\n                        ? { id: EBMLId.TagString, data: new EBMLUnicodeString(value) }\n                        : { id: EBMLId.TagBinary, data: value },\n                ] });\n        };\n        const metadataTags = this.output._metadataTags;\n        const writtenTags = new Set();\n        for (const { key, value } of keyValueIterator(metadataTags)) {\n            switch (key) {\n                case 'title':\n                    {\n                        addSimpleTag('TITLE', value);\n                        writtenTags.add('TITLE');\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        addSimpleTag('DESCRIPTION', value);\n                        writtenTags.add('DESCRIPTION');\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        addSimpleTag('ARTIST', value);\n                        writtenTags.add('ARTIST');\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        addSimpleTag('ALBUM', value);\n                        writtenTags.add('ALBUM');\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                    {\n                        addSimpleTag('ALBUM_ARTIST', value);\n                        writtenTags.add('ALBUM_ARTIST');\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        addSimpleTag('GENRE', value);\n                        writtenTags.add('GENRE');\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        addSimpleTag('COMMENT', value);\n                        writtenTags.add('COMMENT');\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        addSimpleTag('LYRICS', value);\n                        writtenTags.add('LYRICS');\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        addSimpleTag('DATE', value.toISOString().slice(0, 10));\n                        writtenTags.add('DATE');\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        const string = metadataTags.tracksTotal !== undefined\n                            ? `${value}/${metadataTags.tracksTotal}`\n                            : value.toString();\n                        addSimpleTag('PART_NUMBER', string);\n                        writtenTags.add('PART_NUMBER');\n                    }\n                    ;\n                    break;\n                case 'discNumber':\n                    {\n                        const string = metadataTags.discsTotal !== undefined\n                            ? `${value}/${metadataTags.discsTotal}`\n                            : value.toString();\n                        addSimpleTag('DISC', string);\n                        writtenTags.add('DISC');\n                    }\n                    ;\n                    break;\n                case 'tracksTotal':\n                case 'discsTotal':\n                    {\n                        // Handled with trackNumber and discNumber respectively\n                    }\n                    ;\n                    break;\n                case 'images':\n                case 'raw':\n                    {\n                        // Handled elsewhere\n                    }\n                    ;\n                    break;\n                default: assertNever(key);\n            }\n        }\n        if (metadataTags.raw) {\n            for (const key in metadataTags.raw) {\n                const value = metadataTags.raw[key];\n                if (value == null || writtenTags.has(key)) {\n                    continue;\n                }\n                if (typeof value === 'string' || value instanceof Uint8Array) {\n                    addSimpleTag(key, value);\n                }\n            }\n        }\n        if (simpleTags.length === 0) {\n            return;\n        }\n        this.tagsElement = {\n            id: EBMLId.Tags,\n            data: [{ id: EBMLId.Tag, data: [\n                        { id: EBMLId.Targets, data: [\n                                { id: EBMLId.TargetTypeValue, data: 50 },\n                                { id: EBMLId.TargetType, data: 'MOVIE' },\n                            ] },\n                        ...simpleTags,\n                    ] }],\n        };\n    }\n    maybeCreateAttachments() {\n        const metadataTags = this.output._metadataTags;\n        const elements = [];\n        const existingFileUids = new Set();\n        const images = metadataTags.images ?? [];\n        for (const image of images) {\n            let imageName = image.name;\n            if (imageName === undefined) {\n                const baseName = image.kind === 'coverFront' ? 'cover' : image.kind === 'coverBack' ? 'back' : 'image';\n                imageName = baseName + (imageMimeTypeToExtension(image.mimeType) ?? '');\n            }\n            let fileUid;\n            while (true) {\n                // Generate a random 64-bit unsigned integer\n                fileUid = 0n;\n                for (let i = 0; i < 8; i++) {\n                    fileUid <<= 8n;\n                    fileUid |= BigInt(Math.floor(Math.random() * 256));\n                }\n                if (fileUid !== 0n && !existingFileUids.has(fileUid)) {\n                    break;\n                }\n            }\n            existingFileUids.add(fileUid);\n            elements.push({\n                id: EBMLId.AttachedFile,\n                data: [\n                    image.description !== undefined\n                        ? { id: EBMLId.FileDescription, data: new EBMLUnicodeString(image.description) }\n                        : null,\n                    { id: EBMLId.FileName, data: new EBMLUnicodeString(imageName) },\n                    { id: EBMLId.FileMediaType, data: image.mimeType },\n                    { id: EBMLId.FileData, data: image.data },\n                    { id: EBMLId.FileUID, data: fileUid },\n                ],\n            });\n        }\n        // Add all AttachedFiles from the raw metadata\n        for (const [key, value] of Object.entries(metadataTags.raw ?? {})) {\n            if (!(value instanceof AttachedFile)) {\n                continue;\n            }\n            const keyIsNumeric = /^\\d+$/.test(key);\n            if (!keyIsNumeric) {\n                continue;\n            }\n            if (images.find(x => x.mimeType === value.mimeType && uint8ArraysAreEqual(x.data, value.data))) {\n                // This attached file has very likely already been added as an image above\n                // (happens when remuxing Matroska)\n                continue;\n            }\n            elements.push({\n                id: EBMLId.AttachedFile,\n                data: [\n                    value.description !== undefined\n                        ? { id: EBMLId.FileDescription, data: new EBMLUnicodeString(value.description) }\n                        : null,\n                    { id: EBMLId.FileName, data: new EBMLUnicodeString(value.name ?? '') },\n                    { id: EBMLId.FileMediaType, data: value.mimeType ?? '' },\n                    { id: EBMLId.FileData, data: value.data },\n                    { id: EBMLId.FileUID, data: BigInt(key) },\n                ],\n            });\n        }\n        if (elements.length === 0) {\n            return;\n        }\n        this.attachmentsElement = { id: EBMLId.Attachments, data: elements };\n    }\n    createSegment() {\n        this.createTracks();\n        this.maybeCreateTags();\n        this.maybeCreateAttachments();\n        this.maybeCreateSeekHead(false);\n        const segment = {\n            id: EBMLId.Segment,\n            size: this.format._options.appendOnly ? -1 : SEGMENT_SIZE_BYTES,\n            data: [\n                this.seekHead, // null if append-only\n                this.segmentInfo,\n                this.tracksElement,\n                // Matroska spec says put this at the end of the file, but I think placing it before the first cluster\n                // makes more sense, and FFmpeg agrees (argumentum ad ffmpegum fallacy)\n                this.attachmentsElement,\n                this.tagsElement,\n            ],\n        };\n        this.segment = segment;\n        if (this.format._options.onSegmentHeader) {\n            this.writer.startTrackingWrites();\n        }\n        this.ebmlWriter.writeEBML(segment);\n        if (this.format._options.onSegmentHeader) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onSegmentHeader(data, start);\n        }\n    }\n    createCues() {\n        this.cues = { id: EBMLId.Cues, data: [] };\n    }\n    get segmentDataOffset() {\n        assert(this.segment);\n        return this.ebmlWriter.dataOffsets.get(this.segment);\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildMatroskaMimeType({\n            isWebM: this.format instanceof WebMOutputFormat,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        assert(meta.decoderConfig.codedWidth !== undefined);\n        assert(meta.decoderConfig.codedHeight !== undefined);\n        const newTrackData = {\n            track,\n            type: 'video',\n            info: {\n                width: meta.decoderConfig.codedWidth,\n                height: meta.decoderConfig.codedHeight,\n                decoderConfig: meta.decoderConfig,\n                alphaMode: !!packet.sideData.alpha, // The first packet determines if this track has alpha or not\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        if (track.source._codec === 'vp9') {\n            // https://www.webmproject.org/docs/container specifies that VP9 \"SHOULD\" make use of the CodecPrivate\n            // field. Since WebCodecs makes no use of the description field for VP9, we need to derive it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array(generateVp9CodecConfigurationFromCodecString(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        else if (track.source._codec === 'av1') {\n            // Per https://github.com/ietf-wg-cellar/matroska-specification/blob/master/codec/av1.md, AV1 requires\n            // CodecPrivate to be set, but WebCodecs makes no use of the description field for AV1. Thus, let's derive\n            // it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array(generateAv1CodecConfigurationFromCodecString(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            const isKeyFrame = packet.type === 'key';\n            let timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            let duration = packet.duration;\n            if (track.metadata.frameRate !== undefined) {\n                // Constrain the time values to the frame rate\n                timestamp = roundToMultiple(timestamp, 1 / track.metadata.frameRate);\n                duration = roundToMultiple(duration, 1 / track.metadata.frameRate);\n            }\n            const additions = trackData.info.alphaMode\n                ? packet.sideData.alpha ?? null\n                : null;\n            const videoChunk = this.createInternalChunk(packet.data, timestamp, duration, packet.type, additions);\n            if (track.source._codec === 'vp9')\n                this.fixVP9ColorSpace(trackData, videoChunk);\n            trackData.chunkQueue.push(videoChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const isKeyFrame = packet.type === 'key';\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            const audioChunk = this.createInternalChunk(packet.data, timestamp, packet.duration, packet.type);\n            trackData.chunkQueue.push(audioChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            let bodyText = cue.text;\n            const timestampMs = Math.round(timestamp * 1000);\n            // Replace in-body timestamps so that they're relative to the cue start time\n            inlineTimestampRegex.lastIndex = 0;\n            bodyText = bodyText.replace(inlineTimestampRegex, (match) => {\n                const time = parseSubtitleTimestamp(match.slice(1, -1));\n                const offsetTime = time - timestampMs;\n                return `<${formatSubtitleTimestamp(offsetTime)}>`;\n            });\n            const body = textEncoder.encode(bodyText);\n            const additions = `${cue.settings ?? ''}\\n${cue.identifier ?? ''}\\n${cue.notes ?? ''}`;\n            const subtitleChunk = this.createInternalChunk(body, timestamp, cue.duration, 'key', additions.trim() ? textEncoder.encode(additions) : null);\n            trackData.chunkQueue.push(subtitleChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async interleaveChunks(isFinalCall = false) {\n        if (!isFinalCall && !this.allTracksAreKnown()) {\n            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.chunkQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.chunkQueue.length > 0 && trackData.chunkQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.chunkQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const chunk = trackWithMinTimestamp.chunkQueue.shift();\n            this.writeBlock(trackWithMinTimestamp, chunk);\n        }\n        if (!isFinalCall) {\n            await this.writer.flush();\n        }\n    }\n    /**\n     * Due to [a bug in Chromium](https://bugs.chromium.org/p/chromium/issues/detail?id=1377842), VP9 streams often\n     * lack color space information. This method patches in that information.\n     */\n    fixVP9ColorSpace(trackData, chunk) {\n        // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n        if (chunk.type !== 'key')\n            return;\n        if (!trackData.info.decoderConfig.colorSpace || !trackData.info.decoderConfig.colorSpace.matrix)\n            return;\n        const bitstream = new Bitstream(chunk.data);\n        bitstream.skipBits(2);\n        const profileLowBit = bitstream.readBits(1);\n        const profileHighBit = bitstream.readBits(1);\n        const profile = (profileHighBit << 1) + profileLowBit;\n        if (profile === 3)\n            bitstream.skipBits(1);\n        const showExistingFrame = bitstream.readBits(1);\n        if (showExistingFrame)\n            return;\n        const frameType = bitstream.readBits(1);\n        if (frameType !== 0)\n            return; // Just to be sure\n        bitstream.skipBits(2);\n        const syncCode = bitstream.readBits(24);\n        if (syncCode !== 0x498342)\n            return;\n        if (profile >= 2)\n            bitstream.skipBits(1);\n        const colorSpaceID = {\n            rgb: 7,\n            bt709: 2,\n            bt470bg: 1,\n            smpte170m: 3,\n        }[trackData.info.decoderConfig.colorSpace.matrix];\n        // The bitstream position is now at the start of the color space bits.\n        // We can use the global writeBits function here as requested.\n        writeBits(chunk.data, bitstream.pos, bitstream.pos + 3, colorSpaceID);\n    }\n    /** Converts a read-only external chunk into an internal one for easier use. */\n    createInternalChunk(data, timestamp, duration, type, additions = null) {\n        const internalChunk = {\n            data,\n            type,\n            timestamp,\n            duration,\n            additions,\n        };\n        return internalChunk;\n    }\n    /** Writes a block containing media data to the file. */\n    writeBlock(trackData, chunk) {\n        // Due to the interlacing algorithm, this code will be run once we've seen one chunk from every media track.\n        if (!this.segment) {\n            this.createSegment();\n        }\n        const msTimestamp = Math.round(1000 * chunk.timestamp);\n        // We wanna only finalize this cluster (and begin a new one) if we know that each track will be able to\n        // start the new one with a key frame.\n        const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n            if (trackData === otherTrackData) {\n                return chunk.type === 'key';\n            }\n            const firstQueuedSample = otherTrackData.chunkQueue[0];\n            if (firstQueuedSample) {\n                return firstQueuedSample.type === 'key';\n            }\n            return otherTrackData.track.source._closed;\n        });\n        let shouldCreateNewCluster = false;\n        if (!this.currentCluster) {\n            shouldCreateNewCluster = true;\n        }\n        else {\n            assert(this.currentClusterStartMsTimestamp !== null);\n            assert(this.currentClusterMaxMsTimestamp !== null);\n            const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n            shouldCreateNewCluster = (keyFrameQueuedEverywhere\n                // This check is required because that means there is already a block with this timestamp in the\n                // CURRENT chunk, meaning that starting the next cluster at the same timestamp is forbidden (since\n                // the already-written block would belong into it instead).\n                && msTimestamp > this.currentClusterMaxMsTimestamp\n                && relativeTimestamp >= 1000 * (this.format._options.minimumClusterDuration ?? 1))\n                // The cluster would exceed its maximum allowed length. This puts us in an unfortunate position and forces\n                // us to begin the next cluster with a delta frame. Although this is undesirable, it is not forbidden by the\n                // spec and is supported by players.\n                || relativeTimestamp > MAX_CLUSTER_TIMESTAMP_MS;\n        }\n        if (shouldCreateNewCluster) {\n            this.createNewCluster(msTimestamp);\n        }\n        const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n        if (relativeTimestamp < MIN_CLUSTER_TIMESTAMP_MS) {\n            // The block lies too far in the past, it's not representable within this cluster\n            return;\n        }\n        const prelude = new Uint8Array(4);\n        const view = new DataView(prelude.buffer);\n        // 0x80 to indicate it's the last byte of a multi-byte number\n        view.setUint8(0, 0x80 | trackData.track.id);\n        view.setInt16(1, relativeTimestamp, false);\n        const msDuration = Math.round(1000 * chunk.duration);\n        if (!chunk.additions) {\n            // No additions, we can write out a SimpleBlock\n            view.setUint8(3, Number(chunk.type === 'key') << 7); // Flags (keyframe flag only present for SimpleBlock)\n            const simpleBlock = { id: EBMLId.SimpleBlock, data: [\n                    prelude,\n                    chunk.data,\n                ] };\n            this.ebmlWriter.writeEBML(simpleBlock);\n        }\n        else {\n            const blockGroup = { id: EBMLId.BlockGroup, data: [\n                    { id: EBMLId.Block, data: [\n                            prelude,\n                            chunk.data,\n                        ] },\n                    chunk.type === 'delta'\n                        ? {\n                            id: EBMLId.ReferenceBlock,\n                            data: new EBMLSignedInt(trackData.lastWrittenMsTimestamp - msTimestamp),\n                        }\n                        : null,\n                    chunk.additions\n                        ? { id: EBMLId.BlockAdditions, data: [\n                                { id: EBMLId.BlockMore, data: [\n                                        { id: EBMLId.BlockAddID, data: 1 }, // Some players expect BlockAddID to come first\n                                        { id: EBMLId.BlockAdditional, data: chunk.additions },\n                                    ] },\n                            ] }\n                        : null,\n                    msDuration > 0 ? { id: EBMLId.BlockDuration, data: msDuration } : null,\n                ] };\n            this.ebmlWriter.writeEBML(blockGroup);\n        }\n        this.duration = Math.max(this.duration, msTimestamp + msDuration);\n        trackData.lastWrittenMsTimestamp = msTimestamp;\n        if (!this.trackDatasInCurrentCluster.has(trackData)) {\n            this.trackDatasInCurrentCluster.set(trackData, {\n                firstMsTimestamp: msTimestamp,\n            });\n        }\n        this.currentClusterMaxMsTimestamp = Math.max(this.currentClusterMaxMsTimestamp, msTimestamp);\n    }\n    /** Creates a new Cluster element to contain media chunks. */\n    createNewCluster(msTimestamp) {\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        if (this.format._options.onCluster) {\n            this.writer.startTrackingWrites();\n        }\n        this.currentCluster = {\n            id: EBMLId.Cluster,\n            size: this.format._options.appendOnly ? -1 : CLUSTER_SIZE_BYTES,\n            data: [\n                { id: EBMLId.Timestamp, data: msTimestamp },\n            ],\n        };\n        this.ebmlWriter.writeEBML(this.currentCluster);\n        this.currentClusterStartMsTimestamp = msTimestamp;\n        this.currentClusterMaxMsTimestamp = msTimestamp;\n        this.trackDatasInCurrentCluster.clear();\n    }\n    finalizeCurrentCluster() {\n        assert(this.currentCluster);\n        if (!this.format._options.appendOnly) {\n            const clusterSize = this.writer.getPos() - this.ebmlWriter.dataOffsets.get(this.currentCluster);\n            const endPos = this.writer.getPos();\n            // Write the size now that we know it\n            this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster) + 4);\n            this.ebmlWriter.writeVarInt(clusterSize, CLUSTER_SIZE_BYTES);\n            this.writer.seek(endPos);\n        }\n        if (this.format._options.onCluster) {\n            assert(this.currentClusterStartMsTimestamp !== null);\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onCluster(data, start, this.currentClusterStartMsTimestamp / 1000);\n        }\n        const clusterOffsetFromSegment = this.ebmlWriter.offsets.get(this.currentCluster) - this.segmentDataOffset;\n        // Group tracks by their first timestamp and create a CuePoint for each unique timestamp\n        const groupedByTimestamp = new Map();\n        for (const [trackData, { firstMsTimestamp }] of this.trackDatasInCurrentCluster) {\n            if (!groupedByTimestamp.has(firstMsTimestamp)) {\n                groupedByTimestamp.set(firstMsTimestamp, []);\n            }\n            groupedByTimestamp.get(firstMsTimestamp).push(trackData);\n        }\n        const groupedAndSortedByTimestamp = [...groupedByTimestamp.entries()].sort((a, b) => a[0] - b[0]);\n        // Add CuePoints to the Cues element for better seeking\n        for (const [msTimestamp, trackDatas] of groupedAndSortedByTimestamp) {\n            assert(this.cues);\n            this.cues.data.push({ id: EBMLId.CuePoint, data: [\n                    { id: EBMLId.CueTime, data: msTimestamp },\n                    // Create CueTrackPositions for each track that starts at this timestamp\n                    ...trackDatas.map((trackData) => {\n                        return { id: EBMLId.CueTrackPositions, data: [\n                                { id: EBMLId.CueTrack, data: trackData.track.id },\n                                { id: EBMLId.CueClusterPosition, data: clusterOffsetFromSegment },\n                            ] };\n                    }),\n                ] });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose() {\n        const release = await this.mutex.acquire();\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        // Since a track is now closed, we may be able to write out chunks that were previously waiting\n        await this.interleaveChunks();\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all media chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        if (!this.segment) {\n            this.createSegment();\n        }\n        // Flush any remaining queued chunks to the file\n        await this.interleaveChunks(true);\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        assert(this.cues);\n        this.ebmlWriter.writeEBML(this.cues);\n        if (!this.format._options.appendOnly) {\n            const endPos = this.writer.getPos();\n            // Write the Segment size\n            const segmentSize = this.writer.getPos() - this.segmentDataOffset;\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segment) + 4);\n            this.ebmlWriter.writeVarInt(segmentSize, SEGMENT_SIZE_BYTES);\n            // Write the duration of the media to the Segment\n            this.segmentDuration.data = new EBMLFloat64(this.duration);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration));\n            this.ebmlWriter.writeEBML(this.segmentDuration);\n            // Fill in SeekHead position data and write it again\n            assert(this.seekHead);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead));\n            this.maybeCreateSeekHead(true);\n            this.ebmlWriter.writeEBML(this.seekHead);\n            this.writer.seek(endPos);\n        }\n        release();\n    }\n}\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildMatroskaMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isWebM ? 'webm' : 'x-matroska');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings.filter(Boolean))];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AdtsMuxer } from './adts/adts-muxer.js';\nimport { AUDIO_CODECS, NON_PCM_AUDIO_CODECS, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { FlacMuxer } from './flac/flac-muxer.js';\nimport { IsobmffMuxer } from './isobmff/isobmff-muxer.js';\nimport { MatroskaMuxer } from './matroska/matroska-muxer.js';\nimport { Mp3Muxer } from './mp3/mp3-muxer.js';\nimport { OggMuxer } from './ogg/ogg-muxer.js';\nimport { WaveMuxer } from './wave/wave-muxer.js';\n/**\n * Base class representing an output media file format.\n * @group Output formats\n * @public\n */\nexport class OutputFormat {\n    /** Returns a list of video codecs that this output format can contain. */\n    getSupportedVideoCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => VIDEO_CODECS.includes(codec));\n    }\n    /** Returns a list of audio codecs that this output format can contain. */\n    getSupportedAudioCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => AUDIO_CODECS.includes(codec));\n    }\n    /** Returns a list of subtitle codecs that this output format can contain. */\n    getSupportedSubtitleCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => SUBTITLE_CODECS.includes(codec));\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _codecUnsupportedHint(codec) {\n        return '';\n    }\n}\n/**\n * Format representing files compatible with the ISO base media file format (ISOBMFF), like MP4 or MOV files.\n * @group Output formats\n * @public\n */\nexport class IsobmffOutputFormat extends OutputFormat {\n    /** Internal constructor. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.fastStart !== undefined\n            && ![false, 'in-memory', 'reserve', 'fragmented'].includes(options.fastStart)) {\n            throw new TypeError('options.fastStart, when provided, must be false, \\'in-memory\\', \\'reserve\\', or \\'fragmented\\'.');\n        }\n        if (options.minimumFragmentDuration !== undefined\n            && (!Number.isFinite(options.minimumFragmentDuration) || options.minimumFragmentDuration < 0)) {\n            throw new TypeError('options.minimumFragmentDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onFtyp !== undefined && typeof options.onFtyp !== 'function') {\n            throw new TypeError('options.onFtyp, when provided, must be a function.');\n        }\n        if (options.onMoov !== undefined && typeof options.onMoov !== 'function') {\n            throw new TypeError('options.onMoov, when provided, must be a function.');\n        }\n        if (options.onMdat !== undefined && typeof options.onMdat !== 'function') {\n            throw new TypeError('options.onMdat, when provided, must be a function.');\n        }\n        if (options.onMoof !== undefined && typeof options.onMoof !== 'function') {\n            throw new TypeError('options.onMoof, when provided, must be a function.');\n        }\n        if (options.metadataFormat !== undefined\n            && !['mdir', 'mdta', 'udta', 'auto'].includes(options.metadataFormat)) {\n            throw new TypeError('options.metadataFormat, when provided, must be either \\'auto\\', \\'mdir\\', \\'mdta\\', or \\'udta\\'.');\n        }\n        super();\n        this._options = options;\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: Infinity },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: Infinity },\n            total: { min: 1, max: 2 ** 32 - 1 }, // Have fun reaching this one\n        };\n    }\n    get supportsVideoRotationMetadata() {\n        return true;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new IsobmffMuxer(output, this);\n    }\n}\n/**\n * MPEG-4 Part 14 (MP4) file format. Supports most codecs.\n * @group Output formats\n * @public\n */\nexport class Mp4OutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link Mp4OutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP4';\n    }\n    get fileExtension() {\n        return '.mp4';\n    }\n    get mimeType() {\n        return 'video/mp4';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            // These are supported via ISO/IEC 23003-5\n            'pcm-s16',\n            'pcm-s16be',\n            'pcm-s24',\n            'pcm-s24be',\n            'pcm-s32',\n            'pcm-s32be',\n            'pcm-f32',\n            'pcm-f32be',\n            'pcm-f64',\n            'pcm-f64be',\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MovOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MOV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * QuickTime File Format (QTFF), often called MOV. Supports all video and audio codecs, but not subtitle codecs.\n * @group Output formats\n * @public\n */\nexport class MovOutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link MovOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MOV';\n    }\n    get fileExtension() {\n        return '.mov';\n    }\n    get mimeType() {\n        return 'video/quicktime';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...AUDIO_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new Mp4OutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MP4 will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * Matroska file format.\n *\n * Supports writing transparent video. For a video track to be marked as transparent, the first packet added must\n * contain alpha side data.\n *\n * @group Output formats\n * @public\n */\nexport class MkvOutputFormat extends OutputFormat {\n    /** Creates a new {@link MkvOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.appendOnly !== undefined && typeof options.appendOnly !== 'boolean') {\n            throw new TypeError('options.appendOnly, when provided, must be a boolean.');\n        }\n        if (options.minimumClusterDuration !== undefined\n            && (!Number.isFinite(options.minimumClusterDuration) || options.minimumClusterDuration < 0)) {\n            throw new TypeError('options.minimumClusterDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onEbmlHeader !== undefined && typeof options.onEbmlHeader !== 'function') {\n            throw new TypeError('options.onEbmlHeader, when provided, must be a function.');\n        }\n        if (options.onSegmentHeader !== undefined && typeof options.onSegmentHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        if (options.onCluster !== undefined && typeof options.onCluster !== 'function') {\n            throw new TypeError('options.onCluster, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new MatroskaMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Matroska';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: Infinity },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: Infinity },\n            total: { min: 1, max: 127 },\n        };\n    }\n    get fileExtension() {\n        return '.mkv';\n    }\n    get mimeType() {\n        return 'video/x-matroska';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            ...PCM_AUDIO_CODECS.filter(codec => !['pcm-s8', 'pcm-f32be', 'pcm-f64be', 'ulaw', 'alaw'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        // While it technically does support it with ProjectionPoseRoll, many players appear to ignore this value\n        return false;\n    }\n}\n/**\n * WebM file format, based on Matroska.\n *\n * Supports writing transparent video. For a video track to be marked as transparent, the first packet added must\n * contain alpha side data.\n *\n * @group Output formats\n * @public\n */\nexport class WebMOutputFormat extends MkvOutputFormat {\n    /** Creates a new {@link WebMOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS.filter(codec => ['vp8', 'vp9', 'av1'].includes(codec)),\n            ...AUDIO_CODECS.filter(codec => ['opus', 'vorbis'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    get _name() {\n        return 'WebM';\n    }\n    get fileExtension() {\n        return '.webm';\n    }\n    get mimeType() {\n        return 'video/webm';\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MkvOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MKV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * MP3 file format.\n * @group Output formats\n * @public\n */\nexport class Mp3OutputFormat extends OutputFormat {\n    /** Creates a new {@link Mp3OutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.xingHeader !== undefined && typeof options.xingHeader !== 'boolean') {\n            throw new TypeError('options.xingHeader, when provided, must be a boolean.');\n        }\n        if (options.onXingFrame !== undefined && typeof options.onXingFrame !== 'function') {\n            throw new TypeError('options.onXingFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new Mp3Muxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP3';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.mp3';\n    }\n    get mimeType() {\n        return 'audio/mpeg';\n    }\n    getSupportedCodecs() {\n        return ['mp3'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * WAVE file format, based on RIFF.\n * @group Output formats\n * @public\n */\nexport class WavOutputFormat extends OutputFormat {\n    /** Creates a new {@link WavOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.large !== undefined && typeof options.large !== 'boolean') {\n            throw new TypeError('options.large, when provided, must be a boolean.');\n        }\n        if (options.metadataFormat !== undefined && !['info', 'id3'].includes(options.metadataFormat)) {\n            throw new TypeError('options.metadataFormat, when provided, must be either \\'info\\' or \\'id3\\'.');\n        }\n        if (options.onHeader !== undefined && typeof options.onHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new WaveMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'WAVE';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.wav';\n    }\n    get mimeType() {\n        return 'audio/wav';\n    }\n    getSupportedCodecs() {\n        return [\n            ...PCM_AUDIO_CODECS.filter(codec => ['pcm-s16', 'pcm-s24', 'pcm-s32', 'pcm-f32', 'pcm-u8', 'ulaw', 'alaw'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * Ogg file format.\n * @group Output formats\n * @public\n */\nexport class OggOutputFormat extends OutputFormat {\n    /** Creates a new {@link OggOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onPage !== undefined && typeof options.onPage !== 'function') {\n            throw new TypeError('options.onPage, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new OggMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Ogg';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 2 ** 32 },\n        };\n    }\n    get fileExtension() {\n        return '.ogg';\n    }\n    get mimeType() {\n        return 'application/ogg';\n    }\n    getSupportedCodecs() {\n        return [\n            ...AUDIO_CODECS.filter(codec => ['vorbis', 'opus'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * ADTS file format.\n * @group Output formats\n * @public\n */\nexport class AdtsOutputFormat extends OutputFormat {\n    /** Creates a new {@link AdtsOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onFrame !== undefined && typeof options.onFrame !== 'function') {\n            throw new TypeError('options.onFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new AdtsMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'ADTS';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.aac';\n    }\n    get mimeType() {\n        return 'audio/aac';\n    }\n    getSupportedCodecs() {\n        return ['aac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * FLAC file format.\n * @group Output formats\n * @public\n */\nexport class FlacOutputFormat extends OutputFormat {\n    /** Creates a new {@link FlacOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new FlacMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'FLAC';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.flac';\n    }\n    get mimeType() {\n        return 'audio/flac';\n    }\n    getSupportedCodecs() {\n        return ['flac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, buildAudioCodecString, buildVideoCodecString, getAudioEncoderConfigExtension, getVideoEncoderConfigExtension, inferCodecFromCodecString, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { customAudioEncoders, customVideoEncoders } from './custom-coder.js';\nexport const validateVideoEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!VIDEO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid video codec '${config.codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n    }\n    if (!(config.bitrate instanceof Quality) && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate must be a positive integer or a quality.');\n    }\n    if (config.keyFrameInterval !== undefined\n        && (!Number.isFinite(config.keyFrameInterval) || config.keyFrameInterval < 0)) {\n        throw new TypeError('config.keyFrameInterval, when provided, must be a non-negative number.');\n    }\n    if (config.sizeChangeBehavior !== undefined\n        && !['deny', 'passThrough', 'fill', 'contain', 'cover'].includes(config.sizeChangeBehavior)) {\n        throw new TypeError('config.sizeChangeBehavior, when provided, must be \\'deny\\', \\'passThrough\\', \\'fill\\', \\'contain\\''\n            + ' or \\'cover\\'.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateVideoEncodingAdditionalOptions(config.codec, config);\n};\nexport const validateVideoEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.alpha !== undefined && !['discard', 'keep'].includes(options.alpha)) {\n        throw new TypeError('options.alpha, when provided, must be \\'discard\\' or \\'keep\\'.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.latencyMode !== undefined && !['quality', 'realtime'].includes(options.latencyMode)) {\n        throw new TypeError('latencyMode, when provided, must be \\'quality\\' or \\'realtime\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && inferCodecFromCodecString(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n    if (options.hardwareAcceleration !== undefined\n        && !['no-preference', 'prefer-hardware', 'prefer-software'].includes(options.hardwareAcceleration)) {\n        throw new TypeError('hardwareAcceleration, when provided, must be \\'no-preference\\', \\'prefer-hardware\\' or'\n            + ' \\'prefer-software\\'.');\n    }\n    if (options.scalabilityMode !== undefined && typeof options.scalabilityMode !== 'string') {\n        throw new TypeError('scalabilityMode, when provided, must be a string.');\n    }\n    if (options.contentHint !== undefined && typeof options.contentHint !== 'string') {\n        throw new TypeError('contentHint, when provided, must be a string.');\n    }\n};\nexport const buildVideoEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toVideoBitrate(options.codec, options.width, options.height)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? buildVideoCodecString(options.codec, options.width, options.height, resolvedBitrate),\n        width: options.width,\n        height: options.height,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        alpha: options.alpha ?? 'discard',\n        framerate: options.framerate,\n        latencyMode: options.latencyMode,\n        hardwareAcceleration: options.hardwareAcceleration,\n        scalabilityMode: options.scalabilityMode,\n        contentHint: options.contentHint,\n        ...getVideoEncoderConfigExtension(options.codec),\n    };\n};\nexport const validateAudioEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!AUDIO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid audio codec '${config.codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n    }\n    if (config.bitrate === undefined\n        && (!PCM_AUDIO_CODECS.includes(config.codec) || config.codec === 'flac')) {\n        throw new TypeError('config.bitrate must be provided for compressed audio codecs.');\n    }\n    if (config.bitrate !== undefined\n        && !(config.bitrate instanceof Quality)\n        && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate, when provided, must be a positive integer or a quality.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateAudioEncodingAdditionalOptions(config.codec, config);\n};\nexport const validateAudioEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && inferCodecFromCodecString(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n};\nexport const buildAudioEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toAudioBitrate(options.codec)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? buildAudioCodecString(options.codec, options.numberOfChannels, options.sampleRate),\n        numberOfChannels: options.numberOfChannels,\n        sampleRate: options.sampleRate,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        ...getAudioEncoderConfigExtension(options.codec),\n    };\n};\n/**\n * Represents a subjective media quality level.\n * @group Encoding\n * @public\n */\nexport class Quality {\n    /** @internal */\n    constructor(factor) {\n        this._factor = factor;\n    }\n    /** @internal */\n    _toVideoBitrate(codec, width, height) {\n        const pixels = width * height;\n        const codecEfficiencyFactors = {\n            avc: 1.0, // H.264/AVC (baseline)\n            hevc: 0.6, // H.265/HEVC (~40% more efficient than AVC)\n            vp9: 0.6, // Similar to HEVC\n            av1: 0.4, // ~60% more efficient than AVC\n            vp8: 1.2, // Slightly less efficient than AVC\n        };\n        const referencePixels = 1920 * 1080;\n        const referenceBitrate = 3000000;\n        const scaleFactor = Math.pow(pixels / referencePixels, 0.95); // Slight non-linear scaling\n        const baseBitrate = referenceBitrate * scaleFactor;\n        const codecAdjustedBitrate = baseBitrate * codecEfficiencyFactors[codec];\n        const finalBitrate = codecAdjustedBitrate * this._factor;\n        return Math.ceil(finalBitrate / 1000) * 1000;\n    }\n    /** @internal */\n    _toAudioBitrate(codec) {\n        if (PCM_AUDIO_CODECS.includes(codec) || codec === 'flac') {\n            return undefined;\n        }\n        const baseRates = {\n            aac: 128000, // 128kbps base for AAC\n            opus: 64000, // 64kbps base for Opus\n            mp3: 160000, // 160kbps base for MP3\n            vorbis: 64000, // 64kbps base for Vorbis\n        };\n        const baseBitrate = baseRates[codec];\n        if (!baseBitrate) {\n            throw new Error(`Unhandled codec: ${codec}`);\n        }\n        let finalBitrate = baseBitrate * this._factor;\n        if (codec === 'aac') {\n            // AAC only works with specific bitrates, let's find the closest\n            const validRates = [96000, 128000, 160000, 192000];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        else if (codec === 'opus' || codec === 'vorbis') {\n            finalBitrate = Math.max(6000, finalBitrate);\n        }\n        else if (codec === 'mp3') {\n            const validRates = [\n                8000, 16000, 24000, 32000, 40000, 48000, 64000, 80000,\n                96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000,\n            ];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        return Math.round(finalBitrate / 1000) * 1000;\n    }\n}\n/**\n * Represents a very low media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_VERY_LOW = new Quality(0.3);\n/**\n * Represents a low media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_LOW = new Quality(0.6);\n/**\n * Represents a medium media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_MEDIUM = new Quality(1);\n/**\n * Represents a high media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_HIGH = new Quality(2);\n/**\n * Represents a very high media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_VERY_HIGH = new Quality(4);\n/**\n * Checks if the browser is able to encode the given codec.\n * @group Encoding\n * @public\n */\nexport const canEncode = (codec) => {\n    if (VIDEO_CODECS.includes(codec)) {\n        return canEncodeVideo(codec);\n    }\n    else if (AUDIO_CODECS.includes(codec)) {\n        return canEncodeAudio(codec);\n    }\n    else if (SUBTITLE_CODECS.includes(codec)) {\n        return canEncodeSubtitles(codec);\n    }\n    throw new TypeError(`Unknown codec '${codec}'.`);\n};\n/**\n * Checks if the browser is able to encode the given video codec with the given parameters.\n * @group Encoding\n * @public\n */\nexport const canEncodeVideo = async (codec, options = {}) => {\n    const { width = 1280, height = 720, bitrate = 1e6, ...restOptions } = options;\n    if (!VIDEO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(width) || width <= 0) {\n        throw new TypeError('width must be a positive integer.');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n        throw new TypeError('height must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer or a quality.');\n    }\n    validateVideoEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (customVideoEncoders.length > 0) {\n        encoderConfig ??= buildVideoEncoderConfig({\n            codec,\n            width,\n            height,\n            bitrate,\n            framerate: undefined,\n            ...restOptions,\n        });\n        if (customVideoEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (typeof VideoEncoder === 'undefined') {\n        return false;\n    }\n    const hasOddDimension = width % 2 === 1 || height % 2 === 1;\n    if (hasOddDimension\n        && (codec === 'avc' || codec === 'hevc')) {\n        // Disallow odd dimensions for certain codecs\n        return false;\n    }\n    encoderConfig ??= buildVideoEncoderConfig({\n        codec,\n        width,\n        height,\n        bitrate,\n        framerate: undefined,\n        ...restOptions,\n        alpha: 'discard', // Since we handle alpha ourselves\n    });\n    const support = await VideoEncoder.isConfigSupported(encoderConfig);\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given audio codec with the given parameters.\n * @group Encoding\n * @public\n */\nexport const canEncodeAudio = async (codec, options = {}) => {\n    const { numberOfChannels = 2, sampleRate = 48000, bitrate = 128e3, ...restOptions } = options;\n    if (!AUDIO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(numberOfChannels) || numberOfChannels <= 0) {\n        throw new TypeError('numberOfChannels must be a positive integer.');\n    }\n    if (!Number.isInteger(sampleRate) || sampleRate <= 0) {\n        throw new TypeError('sampleRate must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer.');\n    }\n    validateAudioEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (customAudioEncoders.length > 0) {\n        encoderConfig ??= buildAudioEncoderConfig({\n            codec,\n            numberOfChannels,\n            sampleRate,\n            bitrate,\n            ...restOptions,\n        });\n        if (customAudioEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (PCM_AUDIO_CODECS.includes(codec)) {\n        return true; // Because we encode these ourselves\n    }\n    if (typeof AudioEncoder === 'undefined') {\n        return false;\n    }\n    encoderConfig ??= buildAudioEncoderConfig({\n        codec,\n        numberOfChannels,\n        sampleRate,\n        bitrate,\n        ...restOptions,\n    });\n    const support = await AudioEncoder.isConfigSupported(encoderConfig);\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given subtitle codec.\n * @group Encoding\n * @public\n */\nexport const canEncodeSubtitles = async (codec) => {\n    if (!SUBTITLE_CODECS.includes(codec)) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the list of all media codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableCodecs = async () => {\n    const [videoCodecs, audioCodecs, subtitleCodecs] = await Promise.all([\n        getEncodableVideoCodecs(),\n        getEncodableAudioCodecs(),\n        getEncodableSubtitleCodecs(),\n    ]);\n    return [...videoCodecs, ...audioCodecs, ...subtitleCodecs];\n};\n/**\n * Returns the list of all video codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableVideoCodecs = async (checkedCodecs = VIDEO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeVideo(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all audio codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableAudioCodecs = async (checkedCodecs = AUDIO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeAudio(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all subtitle codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableSubtitleCodecs = async (checkedCodecs = SUBTITLE_CODECS) => {\n    const bools = await Promise.all(checkedCodecs.map(canEncodeSubtitles));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the first video codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableVideoCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeVideo(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first audio codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableAudioCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeAudio(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first subtitle codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableSubtitleCodec = async (checkedCodecs) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeSubtitles(codec)) {\n            return codec;\n        }\n    }\n    return null;\n};\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, parsePcmCodec, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { assert, assertNever, CallSerializer, clamp, isFirefox, promiseWithResolvers, setInt24, setUint24, } from './misc.js';\nimport { SubtitleParser } from './subtitles.js';\nimport { toAlaw, toUlaw } from './pcm.js';\nimport { customVideoEncoders, customAudioEncoders, } from './custom-coder.js';\nimport { EncodedPacket } from './packet.js';\nimport { AudioSample, VideoSample } from './sample.js';\nimport { buildAudioEncoderConfig, buildVideoEncoderConfig, validateAudioEncodingConfig, validateVideoEncodingConfig, } from './encode.js';\n/**\n * Base class for media sources. Media sources are used to add media samples to an output file.\n * @group Media sources\n * @public\n */\nexport class MediaSource {\n    constructor() {\n        /** @internal */\n        this._connectedTrack = null;\n        /** @internal */\n        this._closingPromise = null;\n        /** @internal */\n        this._closed = false;\n        /**\n         * @internal\n         * A time offset in seconds that is added to all timestamps generated by this source.\n         */\n        this._timestampOffset = 0;\n    }\n    /** @internal */\n    _ensureValidAdd() {\n        if (!this._connectedTrack) {\n            throw new Error('Source is not connected to an output track.');\n        }\n        if (this._connectedTrack.output.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._connectedTrack.output.state === 'finalizing' || this._connectedTrack.output.state === 'finalized') {\n            throw new Error('Output has been finalized.');\n        }\n        if (this._connectedTrack.output.state === 'pending') {\n            throw new Error('Output has not started.');\n        }\n        if (this._closed) {\n            throw new Error('Source is closed.');\n        }\n    }\n    /** @internal */\n    async _start() { }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async _flushAndClose(forceClose) { }\n    /**\n     * Closes this source. This prevents future samples from being added and signals to the output file that no further\n     * samples will come in for this track. Calling `.close()` is optional but recommended after adding the\n     * last sample - for improved performance and reduced memory usage.\n     */\n    close() {\n        if (this._closingPromise) {\n            return;\n        }\n        const connectedTrack = this._connectedTrack;\n        if (!connectedTrack) {\n            throw new Error('Cannot call close without connecting the source to an output track.');\n        }\n        if (connectedTrack.output.state === 'pending') {\n            throw new Error('Cannot call close before output has been started.');\n        }\n        this._closingPromise = (async () => {\n            await this._flushAndClose(false);\n            this._closed = true;\n            if (connectedTrack.output.state === 'finalizing' || connectedTrack.output.state === 'finalized') {\n                return;\n            }\n            connectedTrack.output._muxer.onTrackClose(connectedTrack);\n        })();\n    }\n    /** @internal */\n    async _flushOrWaitForOngoingClose(forceClose) {\n        if (this._closingPromise) {\n            // Since closing also flushes, we don't want to do it twice\n            return this._closingPromise;\n        }\n        else {\n            return this._flushAndClose(forceClose);\n        }\n    }\n}\n/**\n * Base class for video sources - sources for video tracks.\n * @group Media sources\n * @public\n */\nexport class VideoSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!VIDEO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid video codec '${codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic video source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nexport class EncodedVideoPacketSource extends VideoSource {\n    /** Creates a new {@link EncodedVideoPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output video track. Packets must be added in *decode order*, while a packet's\n     * timestamp must be its *presentation timestamp*. B-frames are handled automatically.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass VideoEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastMultipleOfKeyFrameInterval = -1;\n        this.codedWidth = null;\n        this.codedHeight = null;\n        this.resizeCanvas = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        // Alpha stuff\n        this.alphaEncoder = null;\n        this.splitter = null;\n        this.splitterCreationFailed = false;\n        this.alphaFrameQueue = [];\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.error = null;\n        this.errorNeedsNewStack = true;\n    }\n    async add(videoSample, shouldClose, encodeOptions) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure video sample size remains constant\n            if (this.codedWidth !== null && this.codedHeight !== null) {\n                if (videoSample.codedWidth !== this.codedWidth || videoSample.codedHeight !== this.codedHeight) {\n                    const sizeChangeBehavior = this.encodingConfig.sizeChangeBehavior ?? 'deny';\n                    if (sizeChangeBehavior === 'passThrough') {\n                        // Do nada\n                    }\n                    else if (sizeChangeBehavior === 'deny') {\n                        throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight},`\n                            + ` got ${videoSample.codedWidth}x${videoSample.codedHeight}. To allow the sample size to`\n                            + ` change over time, set \\`sizeChangeBehavior\\` to a value other than 'strict' in the`\n                            + ` encoding options.`);\n                    }\n                    else {\n                        let canvasIsNew = false;\n                        if (!this.resizeCanvas) {\n                            if (typeof document !== 'undefined') {\n                                // Prefer an HTMLCanvasElement\n                                this.resizeCanvas = document.createElement('canvas');\n                                this.resizeCanvas.width = this.codedWidth;\n                                this.resizeCanvas.height = this.codedHeight;\n                            }\n                            else {\n                                this.resizeCanvas = new OffscreenCanvas(this.codedWidth, this.codedHeight);\n                            }\n                            canvasIsNew = true;\n                        }\n                        const context = this.resizeCanvas.getContext('2d', {\n                            alpha: isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n                        });\n                        assert(context);\n                        if (!canvasIsNew) {\n                            if (isFirefox()) {\n                                context.fillStyle = 'black';\n                                context.fillRect(0, 0, this.codedWidth, this.codedHeight);\n                            }\n                            else {\n                                context.clearRect(0, 0, this.codedWidth, this.codedHeight);\n                            }\n                        }\n                        videoSample.drawWithFit(context, { fit: sizeChangeBehavior });\n                        if (shouldClose) {\n                            videoSample.close();\n                        }\n                        videoSample = new VideoSample(this.resizeCanvas, {\n                            timestamp: videoSample.timestamp,\n                            duration: videoSample.duration,\n                            rotation: videoSample.rotation,\n                        });\n                        shouldClose = true;\n                    }\n                }\n            }\n            else {\n                this.codedWidth = videoSample.codedWidth;\n                this.codedHeight = videoSample.codedHeight;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    this.ensureEncoder(videoSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            const keyFrameInterval = this.encodingConfig.keyFrameInterval ?? 5;\n            const multipleOfKeyFrameInterval = Math.floor(videoSample.timestamp / keyFrameInterval);\n            // Ensure a key frame every keyFrameInterval seconds. It is important that all video tracks follow the same\n            // \"key frame\" rhythm, because aligned key frames are required to start new fragments in ISOBMFF or clusters\n            // in Matroska (or at least desirable).\n            const finalEncodeOptions = {\n                ...encodeOptions,\n                keyFrame: encodeOptions?.keyFrame\n                    || keyFrameInterval === 0\n                    || multipleOfKeyFrameInterval !== this.lastMultipleOfKeyFrameInterval,\n            };\n            this.lastMultipleOfKeyFrameInterval = multipleOfKeyFrameInterval;\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = videoSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample, finalEncodeOptions))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.error ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `videoSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n            }\n            else {\n                assert(this.encoder);\n                const videoFrame = videoSample.toVideoFrame();\n                if (!this.alphaEncoder) {\n                    // No alpha encoder, simple case\n                    this.encoder.encode(videoFrame, finalEncodeOptions);\n                    videoFrame.close();\n                }\n                else {\n                    // We're expected to encode alpha as well\n                    const frameDefinitelyHasNoAlpha = !!videoFrame.format && !videoFrame.format.includes('A');\n                    if (frameDefinitelyHasNoAlpha || this.splitterCreationFailed) {\n                        this.alphaFrameQueue.push(null);\n                        this.encoder.encode(videoFrame, finalEncodeOptions);\n                        videoFrame.close();\n                    }\n                    else {\n                        const width = videoFrame.displayWidth;\n                        const height = videoFrame.displayHeight;\n                        if (!this.splitter) {\n                            try {\n                                this.splitter = new ColorAlphaSplitter(width, height);\n                            }\n                            catch (error) {\n                                console.error('Due to an error, only color data will be encoded.', error);\n                                this.splitterCreationFailed = true;\n                                this.alphaFrameQueue.push(null);\n                                this.encoder.encode(videoFrame, finalEncodeOptions);\n                                videoFrame.close();\n                            }\n                        }\n                        if (this.splitter) {\n                            const colorFrame = this.splitter.extractColor(videoFrame);\n                            const alphaFrame = this.splitter.extractAlpha(videoFrame);\n                            this.alphaFrameQueue.push(alphaFrame);\n                            this.encoder.encode(colorFrame, finalEncodeOptions);\n                            colorFrame.close();\n                            videoFrame.close();\n                        }\n                    }\n                }\n                if (shouldClose) {\n                    videoSample.close();\n                }\n                // We need to do this after sending the frame to the encoder as the frame otherwise might be closed\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n            }\n            await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                videoSample.close();\n            }\n        }\n    }\n    ensureEncoder(videoSample) {\n        const encoderError = new Error();\n        this.ensureEncoderPromise = (async () => {\n            const encoderConfig = buildVideoEncoderConfig({\n                width: videoSample.codedWidth,\n                height: videoSample.codedHeight,\n                ...this.encodingConfig,\n                framerate: this.source._connectedTrack?.metadata.frameRate,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customVideoEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class ü§ì\"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                await this.customEncoder.init();\n            }\n            else {\n                if (typeof VideoEncoder === 'undefined') {\n                    throw new Error('VideoEncoder is not supported by this browser.');\n                }\n                encoderConfig.alpha = 'discard'; // Since we handle alpha ourselves\n                if (this.encodingConfig.alpha === 'keep') {\n                    // Encoding alpha requires using two parallel encoders, so we need to make sure they stay in sync\n                    // and that neither of them drops frames. Setting latencyMode to 'quality' achieves this, because\n                    // \"User Agents MUST not drop frames to achieve the target bitrate and/or framerate.\"\n                    encoderConfig.latencyMode = 'quality';\n                }\n                const hasOddDimension = encoderConfig.width % 2 === 1 || encoderConfig.height % 2 === 1;\n                if (hasOddDimension\n                    && (this.encodingConfig.codec === 'avc' || this.encodingConfig.codec === 'hevc')) {\n                    // Throw a special error for this case as it gets hit often\n                    throw new Error(`The dimensions ${encoderConfig.width}x${encoderConfig.height} are not supported for codec`\n                        + ` '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to`\n                        + ` round your dimensions to the nearest even number.`);\n                }\n                const support = await VideoEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.width}x${encoderConfig.height}, hardware acceleration:`\n                        + ` ${encoderConfig.hardwareAcceleration ?? 'no-preference'}) is not supported by this browser.`\n                        + ` Consider using another codec or changing your video parameters.`);\n                }\n                /** Queue of color chunks waiting for their alpha counterpart. */\n                const colorChunkQueue = [];\n                /** Each value is the number of encoded alpha chunks at which a null alpha chunk should be added. */\n                const nullAlphaChunkQueue = [];\n                let encodedAlphaChunkCount = 0;\n                let alphaEncoderQueue = 0;\n                const addPacket = (colorChunk, alphaChunk, meta) => {\n                    const sideData = {};\n                    if (alphaChunk) {\n                        const alphaData = new Uint8Array(alphaChunk.byteLength);\n                        alphaChunk.copyTo(alphaData);\n                        sideData.alpha = alphaData;\n                    }\n                    const packet = EncodedPacket.fromEncodedChunk(colorChunk, sideData);\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                this.encoder = new VideoEncoder({\n                    output: (chunk, meta) => {\n                        if (!this.alphaEncoder) {\n                            // We're done\n                            addPacket(chunk, null, meta);\n                            return;\n                        }\n                        const alphaFrame = this.alphaFrameQueue.shift();\n                        assert(alphaFrame !== undefined);\n                        if (alphaFrame) {\n                            this.alphaEncoder.encode(alphaFrame, {\n                                // Crucial: The alpha frame is forced to be a key frame whenever the color frame\n                                // also is. Without this, playback can glitch and even crash in some browsers.\n                                // This is the reason why the two encoders are wired in series and not in parallel.\n                                keyFrame: chunk.type === 'key',\n                            });\n                            alphaEncoderQueue++;\n                            alphaFrame.close();\n                            colorChunkQueue.push({ chunk, meta });\n                        }\n                        else {\n                            // There was no alpha component for this frame\n                            if (alphaEncoderQueue === 0) {\n                                // No pending alpha encodes either, so we're done\n                                addPacket(chunk, null, meta);\n                            }\n                            else {\n                                // There are still alpha encodes pending, so we can't add the packet immediately since\n                                // we'd end up with out-of-order packets. Instead, let's queue a null alpha chunk to be\n                                // added in the future, after the current encoder workload has completed:\n                                nullAlphaChunkQueue.push(encodedAlphaChunkCount + alphaEncoderQueue);\n                                colorChunkQueue.push({ chunk, meta });\n                            }\n                        }\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.error ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n                if (this.encodingConfig.alpha === 'keep') {\n                    // We need to encode alpha as well, which we do with a separate encoder\n                    this.alphaEncoder = new VideoEncoder({\n                        // We ignore the alpha chunk's metadata\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        output: (chunk, meta) => {\n                            alphaEncoderQueue--;\n                            // There has to be a color chunk because the encoders are wired in series\n                            const colorChunk = colorChunkQueue.shift();\n                            assert(colorChunk !== undefined);\n                            addPacket(colorChunk.chunk, chunk, colorChunk.meta);\n                            // See if there are any null alpha chunks queued up\n                            encodedAlphaChunkCount++;\n                            while (nullAlphaChunkQueue.length > 0\n                                && nullAlphaChunkQueue[0] === encodedAlphaChunkCount) {\n                                nullAlphaChunkQueue.shift();\n                                const colorChunk = colorChunkQueue.shift();\n                                assert(colorChunk !== undefined);\n                                addPacket(colorChunk.chunk, null, colorChunk.meta);\n                            }\n                        },\n                        error: (error) => {\n                            error.stack = encoderError.stack; // Provide a more useful stack trace\n                            this.error ??= error;\n                        },\n                    });\n                    this.alphaEncoder.configure(encoderConfig);\n                }\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                // These are wired in series, therefore they must also be flushed in series\n                await this.encoder.flush();\n                await this.alphaEncoder?.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n            if (this.alphaEncoder && this.alphaEncoder.state !== 'closed') {\n                this.alphaEncoder.close();\n            }\n            this.alphaFrameQueue.forEach(x => x?.close());\n            this.splitter?.close();\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else {\n            // Because the color and alpha encoders are wired in series, there's no need to also include the alpha\n            // encoder's queue size here\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.error) {\n            if (this.errorNeedsNewStack) {\n                this.error.stack = new Error().stack; // Provide an even more useful stack trace\n            }\n            throw this.error;\n        }\n    }\n}\n/** Utility class for splitting a composite frame into separate color and alpha components. */\nclass ColorAlphaSplitter {\n    constructor(initialWidth, initialHeight) {\n        this.lastFrame = null;\n        if (typeof OffscreenCanvas !== 'undefined') {\n            this.canvas = new OffscreenCanvas(initialWidth, initialHeight);\n        }\n        else {\n            this.canvas = document.createElement('canvas');\n            this.canvas.width = initialWidth;\n            this.canvas.height = initialHeight;\n        }\n        const gl = this.canvas.getContext('webgl2', {\n            alpha: true, // Needed due to the YUV thing we do for alpha\n        }); // Casting because of some TypeScript weirdness\n        if (!gl) {\n            throw new Error('Couldn\\'t acquire WebGL 2 context.');\n        }\n        this.gl = gl;\n        this.colorProgram = this.createColorProgram();\n        this.alphaProgram = this.createAlphaProgram();\n        this.vao = this.createVAO();\n        this.sourceTexture = this.createTexture();\n        this.alphaResolutionLocation = this.gl.getUniformLocation(this.alphaProgram, 'u_resolution');\n        this.gl.useProgram(this.colorProgram);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram, 'u_sourceTexture'), 0);\n        this.gl.useProgram(this.alphaProgram);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram, 'u_sourceTexture'), 0);\n    }\n    createVertexShader() {\n        return this.createShader(this.gl.VERTEX_SHADER, `#version 300 es\n\t\t\tin vec2 a_position;\n\t\t\tin vec2 a_texCoord;\n\t\t\tout vec2 v_texCoord;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = vec4(a_position, 0.0, 1.0);\n\t\t\t\tv_texCoord = a_texCoord;\n\t\t\t}\n\t\t`);\n    }\n    createColorProgram() {\n        const vertexShader = this.createVertexShader();\n        // This shader is simple, simply copy the color information while setting alpha to 1\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tvec4 source = texture(u_sourceTexture, v_texCoord);\n\t\t\t\tfragColor = vec4(source.rgb, 1.0);\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createAlphaProgram() {\n        const vertexShader = this.createVertexShader();\n        // This shader's more complex. The main reason is that this shader writes data in I420 (yuv420) pixel format\n        // instead of regular RGBA. In other words, we use the shader to write out I420 data into an RGBA canvas, which\n        // we then later read out with JavaScript. The reason being that browsers weirdly encode canvases and mess up\n        // the color spaces, and the only way to have full control over the color space is by outputting YUV data\n        // directly (avoiding the RGB conversion). Doing this conversion in JS is painfully slow, so let's utlize the\n        // GPU since we're already calling it anyway.\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tuniform vec2 u_resolution; // The width and height of the canvas\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\n\t\t\t// This function determines the value for a single byte in the YUV stream\n\t\t\tfloat getByteValue(float byteOffset) {\n\t\t\t\tfloat width = u_resolution.x;\n\t\t\t\tfloat height = u_resolution.y;\n\n\t\t\t\tfloat yPlaneSize = width * height;\n\n\t\t\t\tif (byteOffset < yPlaneSize) {\n\t\t\t\t\t// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from\n\t\t\t\t\tfloat y = floor(byteOffset / width);\n\t\t\t\t\tfloat x = mod(byteOffset, width);\n\t\t\t\t\t\n\t\t\t\t\t// Add 0.5 to sample the center of the texel\n\t\t\t\t\tvec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;\n\t\t\t\t\t\n\t\t\t\t\t// The luma value is the alpha from the source texture\n\t\t\t\t\treturn texture(u_sourceTexture, sampleCoord).a;\n\t\t\t\t} else {\n\t\t\t\t\t// Write a fixed value for chroma and beyond\n\t\t\t\t\treturn 128.0 / 255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\t// Each fragment writes 4 bytes (R, G, B, A)\n\t\t\t\tfloat pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);\n\t\t\t\tfloat baseByteOffset = pixelIndex * 4.0;\n\n\t\t\t\tvec4 result;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tfloat currentByteOffset = baseByteOffset + float(i);\n\t\t\t\t\tresult[i] = getByteValue(currentByteOffset);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfragColor = result;\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createShader(type, source) {\n        const shader = this.gl.createShader(type);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));\n        }\n        return shader;\n    }\n    createVAO() {\n        const vao = this.gl.createVertexArray();\n        this.gl.bindVertexArray(vao);\n        const vertices = new Float32Array([\n            -1, -1, 0, 1,\n            1, -1, 1, 1,\n            -1, 1, 0, 0,\n            1, 1, 1, 0,\n        ]);\n        const buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);\n        const positionLocation = this.gl.getAttribLocation(this.colorProgram, 'a_position');\n        const texCoordLocation = this.gl.getAttribLocation(this.colorProgram, 'a_texCoord');\n        this.gl.enableVertexAttribArray(positionLocation);\n        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 16, 0);\n        this.gl.enableVertexAttribArray(texCoordLocation);\n        this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 16, 8);\n        return vao;\n    }\n    createTexture() {\n        const texture = this.gl.createTexture();\n        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n        return texture;\n    }\n    updateTexture(sourceFrame) {\n        if (this.lastFrame === sourceFrame) {\n            return;\n        }\n        if (sourceFrame.displayWidth !== this.canvas.width || sourceFrame.displayHeight !== this.canvas.height) {\n            this.canvas.width = sourceFrame.displayWidth;\n            this.canvas.height = sourceFrame.displayHeight;\n        }\n        this.gl.activeTexture(this.gl.TEXTURE0);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.sourceTexture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, sourceFrame);\n        this.lastFrame = sourceFrame;\n    }\n    extractColor(sourceFrame) {\n        this.updateTexture(sourceFrame);\n        this.gl.useProgram(this.colorProgram);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        return new VideoFrame(this.canvas, {\n            timestamp: sourceFrame.timestamp,\n            duration: sourceFrame.duration ?? undefined,\n            alpha: 'discard',\n        });\n    }\n    extractAlpha(sourceFrame) {\n        this.updateTexture(sourceFrame);\n        this.gl.useProgram(this.alphaProgram);\n        this.gl.uniform2f(this.alphaResolutionLocation, this.canvas.width, this.canvas.height);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        const { width, height } = this.canvas;\n        const chromaSamples = Math.ceil(width / 2) * Math.ceil(height / 2);\n        const yuvSize = width * height + chromaSamples * 2;\n        const requiredHeight = Math.ceil(yuvSize / (width * 4));\n        let yuv = new Uint8Array(4 * width * requiredHeight);\n        this.gl.readPixels(0, 0, width, requiredHeight, this.gl.RGBA, this.gl.UNSIGNED_BYTE, yuv);\n        yuv = yuv.subarray(0, yuvSize);\n        assert(yuv[width * height] === 128); // Where chroma data starts\n        assert(yuv[yuv.length - 1] === 128); // Assert the YUV data has been fully written\n        // Defining this separately because TypeScript doesn't know `transfer` and I can't be bothered to do declaration\n        // merging right now\n        const init = {\n            format: 'I420',\n            codedWidth: width,\n            codedHeight: height,\n            timestamp: sourceFrame.timestamp,\n            duration: sourceFrame.duration ?? undefined,\n            transfer: [yuv.buffer],\n        };\n        return new VideoFrame(yuv, init);\n    }\n    close() {\n        this.gl.getExtension('WEBGL_lose_context')?.loseContext();\n        this.gl = null;\n    }\n}\n/**\n * This source can be used to add raw, unencoded video samples (frames) to an output video track. These frames will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nexport class VideoSampleSource extends VideoSource {\n    /**\n     * Creates a new {@link VideoSampleSource} whose samples are encoded according to the specified\n     * {@link VideoEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes a video sample (frame) and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(videoSample, encodeOptions) {\n        if (!(videoSample instanceof VideoSample)) {\n            throw new TypeError('videoSample must be a VideoSample.');\n        }\n        return this._encoder.add(videoSample, false, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add video frames to the output track from a fixed canvas element. Since canvases are often\n * used for rendering, this source provides a convenient wrapper around {@link VideoSampleSource}.\n * @group Media sources\n * @public\n */\nexport class CanvasSource extends VideoSource {\n    /**\n     * Creates a new {@link CanvasSource} from a canvas element or `OffscreenCanvas` whose samples are encoded\n     * according to the specified {@link VideoEncodingConfig}.\n     */\n    constructor(canvas, encodingConfig) {\n        if (!(typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement)\n            && !(typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n            throw new TypeError('canvas must be an HTMLCanvasElement or OffscreenCanvas.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._canvas = canvas;\n    }\n    /**\n     * Captures the current canvas state as a video sample (frame), encodes it and adds it to the output.\n     *\n     * @param timestamp - The timestamp of the sample, in seconds.\n     * @param duration - The duration of the sample, in seconds.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(timestamp, duration = 0, encodeOptions) {\n        if (!Number.isFinite(timestamp) || timestamp < 0) {\n            throw new TypeError('timestamp must be a non-negative number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        const sample = new VideoSample(this._canvas, { timestamp, duration });\n        return this._encoder.add(sample, true, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Video source that encodes the frames of a\n * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes them into the\n * output. This is useful for capturing live or real-time data such as webcams or screen captures. Frames will\n * automatically start being captured once the connected {@link Output} is started, and will keep being captured until\n * the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nexport class MediaStreamVideoTrackSource extends VideoSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /**\n     * Creates a new {@link MediaStreamVideoTrackSource} from a\n     * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack), which will pull\n     * video samples from the stream in real time and encode them according to {@link VideoEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'video') {\n            throw new TypeError('track must be a video MediaStreamTrack.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        encodingConfig = {\n            ...encodingConfig,\n            latencyMode: 'realtime',\n        };\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._workerTrackId = null;\n        /** @internal */\n        this._workerListener = null;\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstVideoFrameTimestamp = null;\n        let errored = false;\n        const onVideoFrame = (videoFrame) => {\n            if (errored) {\n                videoFrame.close();\n                return;\n            }\n            if (firstVideoFrameTimestamp === null) {\n                firstVideoFrameTimestamp = videoFrame.timestamp / 1e6;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstVideoFrameTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstVideoFrameTimestamp;\n                }\n            }\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop frames if the encoder is overloaded\n                videoFrame.close();\n                return;\n            }\n            void this._encoder.add(new VideoSample(videoFrame), true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                if (this._workerTrackId !== null) {\n                    // Tell the worker to stop the track\n                    sendMessageToMediaStreamTrackProcessorWorker({\n                        type: 'stopTrack',\n                        trackId: this._workerTrackId,\n                    });\n                }\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // We can do it here directly, perfect\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({ write: onVideoFrame });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // It might still be supported in a worker, so let's check that\n            const supportedInWorker = await mediaStreamTrackProcessorIsSupportedInWorker();\n            if (supportedInWorker) {\n                this._workerTrackId = nextMediaStreamTrackProcessorWorkerId++;\n                sendMessageToMediaStreamTrackProcessorWorker({\n                    type: 'videoTrack',\n                    trackId: this._workerTrackId,\n                    track: this._track,\n                }, [this._track]);\n                this._workerListener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'videoFrame' && message.trackId === this._workerTrackId) {\n                        onVideoFrame(message.videoFrame);\n                    }\n                    else if (message.type === 'error' && message.trackId === this._workerTrackId) {\n                        this._promiseWithResolvers.reject(message.error);\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', this._workerListener);\n            }\n            else {\n                throw new Error('MediaStreamTrackProcessor is required but not supported by this browser.');\n            }\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._workerTrackId !== null) {\n            assert(this._workerListener);\n            sendMessageToMediaStreamTrackProcessorWorker({\n                type: 'stopTrack',\n                trackId: this._workerTrackId,\n            });\n            // Wait for the worker to stop the track\n            await new Promise((resolve) => {\n                const listener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'trackStopped' && message.trackId === this._workerTrackId) {\n                        assert(this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                        resolve();\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n            });\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Base class for audio sources - sources for audio tracks.\n * @group Media sources\n * @public\n */\nexport class AudioSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!AUDIO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid audio codec '${codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic audio source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nexport class EncodedAudioPacketSource extends AudioSource {\n    /** Creates a new {@link EncodedAudioPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output audio track. Packets must be added in *decode order*.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass AudioEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastNumberOfChannels = null;\n        this.lastSampleRate = null;\n        this.isPcmEncoder = false;\n        this.outputSampleSize = null;\n        this.writeOutputValue = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.error = null;\n        this.errorNeedsNewStack = true;\n    }\n    async add(audioSample, shouldClose) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure audio parameters remain constant\n            if (this.lastNumberOfChannels !== null && this.lastSampleRate !== null) {\n                if (audioSample.numberOfChannels !== this.lastNumberOfChannels\n                    || audioSample.sampleRate !== this.lastSampleRate) {\n                    throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at`\n                        + ` ${this.lastSampleRate} Hz, got ${audioSample.numberOfChannels} channels at`\n                        + ` ${audioSample.sampleRate} Hz.`);\n                }\n            }\n            else {\n                this.lastNumberOfChannels = audioSample.numberOfChannels;\n                this.lastSampleRate = audioSample.sampleRate;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    this.ensureEncoder(audioSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = audioSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.error ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `audioSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n            else if (this.isPcmEncoder) {\n                await this.doPcmEncoding(audioSample, shouldClose);\n            }\n            else {\n                assert(this.encoder);\n                const audioData = audioSample.toAudioData();\n                this.encoder.encode(audioData);\n                audioData.close();\n                if (shouldClose) {\n                    audioSample.close();\n                }\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                audioSample.close();\n            }\n        }\n    }\n    async doPcmEncoding(audioSample, shouldClose) {\n        assert(this.outputSampleSize);\n        assert(this.writeOutputValue);\n        // Need to extract data from the audio data before we close it\n        const { numberOfChannels, numberOfFrames, sampleRate, timestamp } = audioSample;\n        const CHUNK_SIZE = 2048;\n        const outputs = [];\n        // Prepare all of the output buffers, each being bounded by CHUNK_SIZE so we don't generate huge packets\n        for (let frame = 0; frame < numberOfFrames; frame += CHUNK_SIZE) {\n            const frameCount = Math.min(CHUNK_SIZE, audioSample.numberOfFrames - frame);\n            const outputSize = frameCount * numberOfChannels * this.outputSampleSize;\n            const outputBuffer = new ArrayBuffer(outputSize);\n            const outputView = new DataView(outputBuffer);\n            outputs.push({ frameCount, view: outputView });\n        }\n        const allocationSize = audioSample.allocationSize(({ planeIndex: 0, format: 'f32-planar' }));\n        const floats = new Float32Array(allocationSize / Float32Array.BYTES_PER_ELEMENT);\n        for (let i = 0; i < numberOfChannels; i++) {\n            audioSample.copyTo(floats, { planeIndex: i, format: 'f32-planar' });\n            for (let j = 0; j < outputs.length; j++) {\n                const { frameCount, view } = outputs[j];\n                for (let k = 0; k < frameCount; k++) {\n                    this.writeOutputValue(view, (k * numberOfChannels + i) * this.outputSampleSize, floats[j * CHUNK_SIZE + k]);\n                }\n            }\n        }\n        if (shouldClose) {\n            audioSample.close();\n        }\n        const meta = {\n            decoderConfig: {\n                codec: this.encodingConfig.codec,\n                numberOfChannels,\n                sampleRate,\n            },\n        };\n        for (let i = 0; i < outputs.length; i++) {\n            const { frameCount, view } = outputs[i];\n            const outputBuffer = view.buffer;\n            const startFrame = i * CHUNK_SIZE;\n            const packet = new EncodedPacket(new Uint8Array(outputBuffer), 'key', timestamp + startFrame / sampleRate, frameCount / sampleRate);\n            this.encodingConfig.onEncodedPacket?.(packet, meta);\n            await this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta); // With backpressure\n        }\n    }\n    ensureEncoder(audioSample) {\n        const encoderError = new Error();\n        this.ensureEncoderPromise = (async () => {\n            const { numberOfChannels, sampleRate } = audioSample;\n            const encoderConfig = buildAudioEncoderConfig({\n                numberOfChannels,\n                sampleRate,\n                ...this.encodingConfig,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customAudioEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class ü§ì\"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                await this.customEncoder.init();\n            }\n            else if (PCM_AUDIO_CODECS.includes(this.encodingConfig.codec)) {\n                this.initPcmEncoder();\n            }\n            else {\n                if (typeof AudioEncoder === 'undefined') {\n                    throw new Error('AudioEncoder is not supported by this browser.');\n                }\n                const support = await AudioEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.numberOfChannels} channels, ${encoderConfig.sampleRate} Hz) is not`\n                        + ` supported by this browser. Consider using another codec or changing your audio parameters.`);\n                }\n                this.encoder = new AudioEncoder({\n                    output: (chunk, meta) => {\n                        const packet = EncodedPacket.fromEncodedChunk(chunk);\n                        this.encodingConfig.onEncodedPacket?.(packet, meta);\n                        void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta)\n                            .catch((error) => {\n                            this.error ??= error;\n                            this.errorNeedsNewStack = false;\n                        });\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.error ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    initPcmEncoder() {\n        this.isPcmEncoder = true;\n        const codec = this.encodingConfig.codec;\n        const { dataType, sampleSize, littleEndian } = parsePcmCodec(codec);\n        this.outputSampleSize = sampleSize;\n        // All these functions receive a float sample as input and map it into the desired format\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, clamp((value + 1) * 127.5, 0, 255));\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            view.setInt8(byteOffset, clamp(Math.round(value * 128), -128, 127));\n                        };\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toUlaw(int16));\n                        };\n                    }\n                    else if (dataType === 'alaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toAlaw(int16));\n                        };\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint16(byteOffset, clamp((value + 1) * 32767.5, 0, 65535), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, clamp(Math.round(value * 32767), -32768, 32767), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => setUint24(view, byteOffset, clamp((value + 1) * 8388607.5, 0, 16777215), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => setInt24(view, byteOffset, clamp(Math.round(value * 8388607), -8388608, 8388607), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint32(byteOffset, clamp((value + 1) * 2147483647.5, 0, 4294967295), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat64(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                await this.encoder.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else if (this.isPcmEncoder) {\n            return 0;\n        }\n        else {\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.error) {\n            if (this.errorNeedsNewStack) {\n                this.error.stack = new Error().stack; // Provide an even more useful stack trace\n            }\n            throw this.error;\n        }\n    }\n}\n/**\n * This source can be used to add raw, unencoded audio samples to an output audio track. These samples will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nexport class AudioSampleSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioSampleSource} whose samples are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes an audio sample and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(audioSample) {\n        if (!(audioSample instanceof AudioSample)) {\n            throw new TypeError('audioSample must be an AudioSample.');\n        }\n        return this._encoder.add(audioSample, false);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add audio data from an AudioBuffer to the output track. This is useful when working with\n * the Web Audio API.\n * @group Media sources\n * @public\n */\nexport class AudioBufferSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioBufferSource} whose `AudioBuffer` instances are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._accumulatedTime = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Converts an AudioBuffer to audio samples, encodes them and adds them to the output. The first AudioBuffer will\n     * be played at timestamp 0, and any subsequent AudioBuffer will have a timestamp equal to the total duration of\n     * all previous AudioBuffers.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    async add(audioBuffer) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const iterator = AudioSample._fromAudioBuffer(audioBuffer, this._accumulatedTime);\n        this._accumulatedTime += audioBuffer.duration;\n        for (const audioSample of iterator) {\n            await this._encoder.add(audioSample, true);\n        }\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Audio source that encodes the data of a\n * [`MediaStreamAudioTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes it into the\n * output. This is useful for capturing live or real-time audio such as microphones or audio from other media elements.\n * Audio will automatically start being captured once the connected {@link Output} is started, and will keep being\n * captured until the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nexport class MediaStreamAudioTrackSource extends AudioSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /**\n     * Creates a new {@link MediaStreamAudioTrackSource} from a `MediaStreamAudioTrack`, which will pull audio samples\n     * from the stream in real time and encode them according to {@link AudioEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'audio') {\n            throw new TypeError('track must be an audio MediaStreamTrack.');\n        }\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._audioContext = null;\n        /** @internal */\n        this._scriptProcessorNode = null; // Deprecated but goated\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // Great, MediaStreamTrackProcessor is supported, this is the preferred way of doing things\n            let firstAudioDataTimestamp = null;\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({\n                write: (audioData) => {\n                    if (firstAudioDataTimestamp === null) {\n                        firstAudioDataTimestamp = audioData.timestamp / 1e6;\n                        const muxer = this._connectedTrack.output._muxer;\n                        if (muxer.firstMediaStreamTimestamp === null) {\n                            muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                            this._timestampOffset = -firstAudioDataTimestamp;\n                        }\n                        else {\n                            this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                                - firstAudioDataTimestamp;\n                        }\n                    }\n                    if (this._encoder.getQueueSize() >= 4) {\n                        // Drop data if the encoder is overloaded\n                        audioData.close();\n                        return;\n                    }\n                    void this._encoder.add(new AudioSample(audioData), true)\n                        .catch((error) => {\n                        this._abortController?.abort();\n                        this._promiseWithResolvers.reject(error);\n                    });\n                },\n            });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // Let's fall back to an AudioContext approach\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n            const AudioContext = window.AudioContext || window.webkitAudioContext;\n            this._audioContext = new AudioContext({ sampleRate: this._track.getSettings().sampleRate });\n            const sourceNode = this._audioContext.createMediaStreamSource(new MediaStream([this._track]));\n            this._scriptProcessorNode = this._audioContext.createScriptProcessor(4096);\n            if (this._audioContext.state === 'suspended') {\n                await this._audioContext.resume();\n            }\n            sourceNode.connect(this._scriptProcessorNode);\n            this._scriptProcessorNode.connect(this._audioContext.destination);\n            let audioReceived = false;\n            let totalDuration = 0;\n            this._scriptProcessorNode.onaudioprocess = (event) => {\n                const iterator = AudioSample._fromAudioBuffer(event.inputBuffer, totalDuration);\n                totalDuration += event.inputBuffer.duration;\n                for (const audioSample of iterator) {\n                    if (!audioReceived) {\n                        audioReceived = true;\n                        const muxer = this._connectedTrack.output._muxer;\n                        if (muxer.firstMediaStreamTimestamp === null) {\n                            muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                        }\n                        else {\n                            this._timestampOffset = performance.now() / 1000 - muxer.firstMediaStreamTimestamp;\n                        }\n                    }\n                    if (this._encoder.getQueueSize() >= 4) {\n                        // Drop data if the encoder is overloaded\n                        audioSample.close();\n                        continue;\n                    }\n                    void this._encoder.add(audioSample, true)\n                        .catch((error) => {\n                        void this._audioContext.suspend();\n                        this._promiseWithResolvers.reject(error);\n                    });\n                }\n            };\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._audioContext) {\n            assert(this._scriptProcessorNode);\n            this._scriptProcessorNode.disconnect();\n            await this._audioContext.suspend();\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\nconst mediaStreamTrackProcessorWorkerCode = () => {\n    const sendMessage = (message, transfer) => {\n        if (transfer) {\n            self.postMessage(message, { transfer });\n        }\n        else {\n            self.postMessage(message);\n        }\n    };\n    // Immediately send a message to the main thread, letting them know of the support\n    sendMessage({\n        type: 'support',\n        supported: typeof MediaStreamTrackProcessor !== 'undefined',\n    });\n    const abortControllers = new Map();\n    const stoppedTracks = new Set();\n    self.addEventListener('message', (event) => {\n        const message = event.data;\n        switch (message.type) {\n            case 'videoTrack':\n                {\n                    const processor = new MediaStreamTrackProcessor({ track: message.track });\n                    const consumer = new WritableStream({\n                        write: (videoFrame) => {\n                            if (stoppedTracks.has(message.trackId)) {\n                                videoFrame.close();\n                                return;\n                            }\n                            // Send it to the main thread\n                            sendMessage({\n                                type: 'videoFrame',\n                                trackId: message.trackId,\n                                videoFrame,\n                            }, [videoFrame]);\n                        },\n                    });\n                    const abortController = new AbortController();\n                    abortControllers.set(message.trackId, abortController);\n                    processor.readable.pipeTo(consumer, {\n                        signal: abortController.signal,\n                    }).catch((error) => {\n                        // Handle AbortError silently\n                        if (error instanceof DOMException && error.name === 'AbortError')\n                            return;\n                        sendMessage({\n                            type: 'error',\n                            trackId: message.trackId,\n                            error,\n                        });\n                    });\n                }\n                ;\n                break;\n            case 'stopTrack':\n                {\n                    const abortController = abortControllers.get(message.trackId);\n                    if (abortController) {\n                        abortController.abort();\n                        abortControllers.delete(message.trackId);\n                    }\n                    stoppedTracks.add(message.trackId);\n                    sendMessage({\n                        type: 'trackStopped',\n                        trackId: message.trackId,\n                    });\n                }\n                ;\n                break;\n            default: assertNever(message);\n        }\n    });\n};\nlet nextMediaStreamTrackProcessorWorkerId = 0;\nlet mediaStreamTrackProcessorWorker = null;\nconst initMediaStreamTrackProcessorWorker = () => {\n    const blob = new Blob([`(${mediaStreamTrackProcessorWorkerCode.toString()})()`], { type: 'application/javascript' });\n    const url = URL.createObjectURL(blob);\n    mediaStreamTrackProcessorWorker = new Worker(url);\n};\nlet mediaStreamTrackProcessorIsSupportedInWorkerCache = null;\nconst mediaStreamTrackProcessorIsSupportedInWorker = async () => {\n    if (mediaStreamTrackProcessorIsSupportedInWorkerCache !== null) {\n        return mediaStreamTrackProcessorIsSupportedInWorkerCache;\n    }\n    if (!mediaStreamTrackProcessorWorker) {\n        initMediaStreamTrackProcessorWorker();\n    }\n    return new Promise((resolve) => {\n        assert(mediaStreamTrackProcessorWorker);\n        const listener = (event) => {\n            const message = event.data;\n            if (message.type === 'support') {\n                mediaStreamTrackProcessorIsSupportedInWorkerCache = message.supported;\n                mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                resolve(message.supported);\n            }\n        };\n        mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n    });\n};\nconst sendMessageToMediaStreamTrackProcessorWorker = (message, transfer) => {\n    assert(mediaStreamTrackProcessorWorker);\n    if (transfer) {\n        mediaStreamTrackProcessorWorker.postMessage(message, transfer);\n    }\n    else {\n        mediaStreamTrackProcessorWorker.postMessage(message);\n    }\n};\n/**\n * Base class for subtitle sources - sources for subtitle tracks.\n * @group Media sources\n * @public\n */\nexport class SubtitleSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!SUBTITLE_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid subtitle codec '${codec}'. Must be one of: ${SUBTITLE_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * This source can be used to add subtitles from a subtitle text file.\n * @group Media sources\n * @public\n */\nexport class TextSubtitleSource extends SubtitleSource {\n    /** Creates a new {@link TextSubtitleSource} where added text chunks are in the specified `codec`. */\n    constructor(codec) {\n        super(codec);\n        /** @internal */\n        this._error = null;\n        this._parser = new SubtitleParser({\n            codec,\n            output: (cue, metadata) => {\n                void this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack, cue, metadata)\n                    .catch((error) => {\n                    this._error ??= error;\n                });\n            },\n        });\n    }\n    /**\n     * Parses the subtitle text according to the specified codec and adds it to the output track. You don't have to\n     * add the entire subtitle file at once here; you can provide it in chunks.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(text) {\n        if (typeof text !== 'string') {\n            throw new TypeError('text must be a string.');\n        }\n        this._checkForError();\n        this._ensureValidAdd();\n        this._parser.parse(text);\n        return this._connectedTrack.output._muxer.mutex.currentPromise;\n    }\n    /** @internal */\n    _checkForError() {\n        if (this._error) {\n            throw this._error;\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (!forceClose) {\n            this._checkForError();\n        }\n    }\n}\n","/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex, isIso639Dash2LanguageCode } from './misc.js';\nimport { validateMetadataTags } from './tags.js';\nimport { OutputFormat } from './output-format.js';\nimport { AudioSource, SubtitleSource, VideoSource } from './media-source.js';\nimport { Target } from './target.js';\n/**\n * List of all track types.\n * @group Miscellaneous\n * @public\n */\nexport const ALL_TRACK_TYPES = ['video', 'audio', 'subtitle'];\nconst validateBaseTrackMetadata = (metadata) => {\n    if (!metadata || typeof metadata !== 'object') {\n        throw new TypeError('metadata must be an object.');\n    }\n    if (metadata.languageCode !== undefined && !isIso639Dash2LanguageCode(metadata.languageCode)) {\n        throw new TypeError('metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.');\n    }\n    if (metadata.name !== undefined && typeof metadata.name !== 'string') {\n        throw new TypeError('metadata.name, when provided, must be a string.');\n    }\n    if (metadata.maximumPacketCount !== undefined\n        && (!Number.isInteger(metadata.maximumPacketCount) || metadata.maximumPacketCount < 0)) {\n        throw new TypeError('metadata.maximumPacketCount, when provided, must be a non-negative integer.');\n    }\n};\n/**\n * Main class orchestrating the creation of a new media file.\n * @group Output files\n * @public\n */\nexport class Output {\n    /**\n     * Creates a new instance of {@link Output} which can then be used to create a new media file according to the\n     * specified {@link OutputOptions}.\n     */\n    constructor(options) {\n        /** The current state of the output. */\n        this.state = 'pending';\n        /** @internal */\n        this._tracks = [];\n        /** @internal */\n        this._startPromise = null;\n        /** @internal */\n        this._cancelPromise = null;\n        /** @internal */\n        this._finalizePromise = null;\n        /** @internal */\n        this._mutex = new AsyncMutex();\n        /** @internal */\n        this._metadataTags = {};\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!(options.format instanceof OutputFormat)) {\n            throw new TypeError('options.format must be an OutputFormat.');\n        }\n        if (!(options.target instanceof Target)) {\n            throw new TypeError('options.target must be a Target.');\n        }\n        if (options.target._output) {\n            throw new Error('Target is already used for another output.');\n        }\n        options.target._output = this;\n        this.format = options.format;\n        this.target = options.target;\n        this._writer = options.target._createWriter();\n        this._muxer = options.format._createMuxer(this);\n    }\n    /** Adds a video track to the output with the given source. Can only be called before the output is started. */\n    addVideoTrack(source, metadata = {}) {\n        if (!(source instanceof VideoSource)) {\n            throw new TypeError('source must be a VideoSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        if (metadata.rotation !== undefined && ![0, 90, 180, 270].includes(metadata.rotation)) {\n            throw new TypeError(`Invalid video rotation: ${metadata.rotation}. Has to be 0, 90, 180 or 270.`);\n        }\n        if (!this.format.supportsVideoRotationMetadata && metadata.rotation) {\n            throw new Error(`${this.format._name} does not support video rotation metadata.`);\n        }\n        if (metadata.frameRate !== undefined\n            && (!Number.isFinite(metadata.frameRate) || metadata.frameRate <= 0)) {\n            throw new TypeError(`Invalid video frame rate: ${metadata.frameRate}. Must be a positive number.`);\n        }\n        this._addTrack('video', source, metadata);\n    }\n    /** Adds an audio track to the output with the given source. Can only be called before the output is started. */\n    addAudioTrack(source, metadata = {}) {\n        if (!(source instanceof AudioSource)) {\n            throw new TypeError('source must be an AudioSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('audio', source, metadata);\n    }\n    /** Adds a subtitle track to the output with the given source. Can only be called before the output is started. */\n    addSubtitleTrack(source, metadata = {}) {\n        if (!(source instanceof SubtitleSource)) {\n            throw new TypeError('source must be a SubtitleSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('subtitle', source, metadata);\n    }\n    /**\n     * Sets descriptive metadata tags about the media file, such as title, author, date, or cover art. When called\n     * multiple times, only the metadata from the last call will be used.\n     *\n     * Can only be called before the output is started.\n     */\n    setMetadataTags(tags) {\n        validateMetadataTags(tags);\n        if (this.state !== 'pending') {\n            throw new Error('Cannot set metadata tags after output has been started or canceled.');\n        }\n        this._metadataTags = tags;\n    }\n    /** @internal */\n    _addTrack(type, source, metadata) {\n        if (this.state !== 'pending') {\n            throw new Error('Cannot add track after output has been started or canceled.');\n        }\n        if (source._connectedTrack) {\n            throw new Error('Source is already used for a track.');\n        }\n        // Verify maximum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === type ? 1 : 0), 0);\n        const maxCount = supportedTrackCounts[type].max;\n        if (presentTracksOfThisType === maxCount) {\n            throw new Error(maxCount === 0\n                ? `${this.format._name} does not support ${type} tracks.`\n                : (`${this.format._name} does not support more than ${maxCount} ${type} track`\n                    + `${maxCount === 1 ? '' : 's'}.`));\n        }\n        const maxTotalCount = supportedTrackCounts.total.max;\n        if (this._tracks.length === maxTotalCount) {\n            throw new Error(`${this.format._name} does not support more than ${maxTotalCount} tracks`\n                + `${maxTotalCount === 1 ? '' : 's'} in total.`);\n        }\n        const track = {\n            id: this._tracks.length + 1,\n            output: this,\n            type,\n            source: source,\n            metadata,\n        };\n        if (track.type === 'video') {\n            const supportedVideoCodecs = this.format.getSupportedVideoCodecs();\n            if (supportedVideoCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support video tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedVideoCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` video codecs are: ${supportedVideoCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'audio') {\n            const supportedAudioCodecs = this.format.getSupportedAudioCodecs();\n            if (supportedAudioCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support audio tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedAudioCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` audio codecs are: ${supportedAudioCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'subtitle') {\n            const supportedSubtitleCodecs = this.format.getSupportedSubtitleCodecs();\n            if (supportedSubtitleCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support subtitle tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedSubtitleCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` subtitle codecs are: ${supportedSubtitleCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        this._tracks.push(track);\n        source._connectedTrack = track;\n    }\n    /**\n     * Starts the creation of the output file. This method should be called after all tracks have been added. Only after\n     * the output has started can media samples be added to the tracks.\n     *\n     * @returns A promise that resolves when the output has successfully started and is ready to receive media samples.\n     */\n    async start() {\n        // Verify minimum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        for (const trackType of ALL_TRACK_TYPES) {\n            const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === trackType ? 1 : 0), 0);\n            const minCount = supportedTrackCounts[trackType].min;\n            if (presentTracksOfThisType < minCount) {\n                throw new Error(minCount === supportedTrackCounts[trackType].max\n                    ? (`${this.format._name} requires exactly ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`)\n                    : (`${this.format._name} requires at least ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`));\n            }\n        }\n        const totalMinCount = supportedTrackCounts.total.min;\n        if (this._tracks.length < totalMinCount) {\n            throw new Error(totalMinCount === supportedTrackCounts.total.max\n                ? (`${this.format._name} requires exactly ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`)\n                : (`${this.format._name} requires at least ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`));\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._startPromise) {\n            console.warn('Output has already been started.');\n            return this._startPromise;\n        }\n        return this._startPromise = (async () => {\n            this.state = 'started';\n            this._writer.start();\n            const release = await this._mutex.acquire();\n            await this._muxer.start();\n            const promises = this._tracks.map(track => track.source._start());\n            await Promise.all(promises);\n            release();\n        })();\n    }\n    /**\n     * Resolves with the full MIME type of the output file, including track codecs.\n     *\n     * The returned promise will resolve only once the precise codec strings of all tracks are known.\n     */\n    getMimeType() {\n        return this._muxer.getMimeType();\n    }\n    /**\n     * Cancels the creation of the output file, releasing internal resources like encoders and preventing further\n     * samples from being added.\n     *\n     * @returns A promise that resolves once all internal resources have been released.\n     */\n    async cancel() {\n        if (this._cancelPromise) {\n            console.warn('Output has already been canceled.');\n            return this._cancelPromise;\n        }\n        else if (this.state === 'finalizing' || this.state === 'finalized') {\n            console.warn('Output has already been finalized.');\n            return;\n        }\n        return this._cancelPromise = (async () => {\n            this.state = 'canceled';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(true)); // Force close\n            await Promise.all(promises);\n            await this._writer.close();\n            release();\n        })();\n    }\n    /**\n     * Finalizes the output file. This method must be called after all media samples across all tracks have been added.\n     * Once the Promise returned by this method completes, the output file is ready.\n     */\n    async finalize() {\n        if (this.state === 'pending') {\n            throw new Error('Cannot finalize before starting.');\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Cannot finalize after canceling.');\n        }\n        if (this._finalizePromise) {\n            console.warn('Output has already been finalized.');\n            return this._finalizePromise;\n        }\n        return this._finalizePromise = (async () => {\n            this.state = 'finalizing';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(false));\n            await Promise.all(promises);\n            await this._muxer.finalize();\n            await this._writer.flush();\n            await this._writer.finalize();\n            this.state = 'finalized';\n            release();\n        })();\n    }\n}\n","/**\n * WebCodecs VP9 encoder wrapper using Mediabunny\n *\n * This encoder uses the native WebCodecs API for hardware-accelerated\n * VP9 encoding with high quality output. It provides a unified API\n * similar to webm-encoder-wrapper.js and mp4-h264 encoder.\n *\n * REQUIREMENTS:\n * - Modern browsers (WebCodecs API)\n * - Mediabunny library for WebM muxing (MPL-2.0 License)\n *   https://mediabunny.dev\n *\n * ADVANTAGES:\n * - Hardware accelerated encoding\n * - High quality output (better than webm-wasm realtime mode)\n * - Non-blocking (truly asynchronous)\n * - Direct canvas integration via VideoFrame\n */\n\n// @ts-ignore - mediabunny is an external module\nimport { Output, WebMOutputFormat, BufferTarget, CanvasSource, QUALITY_HIGH, QUALITY_VERY_HIGH } from 'mediabunny';\n\nexport class WebCodecsVP9Encoder {\n  constructor() {\n    this.output = null;\n    this.canvasSource = null;\n    this.canvas = null;\n    this.ctx = null;\n    this.frameCount = 0;\n    this.frameDuration = 0;\n    this.currentTimestamp = 0;\n    this.isFinalized = false;\n    this.isStarted = false;\n  }\n\n  /**\n     * Check if WebCodecs is supported in this browser\n     * @returns {boolean}\n     */\n  static isSupported() {\n    return typeof VideoEncoder !== 'undefined' &&\n               typeof VideoFrame !== 'undefined';\n  }\n\n  /**\n     * Create and initialize the encoder\n     * @param {Object} options - Configuration object\n     * @param {number} options.width - Video width in pixels\n     * @param {number} options.height - Video height in pixels\n     * @param {number} options.fps - Frames per second\n     * @param {number} options.bitrate - Bitrate in kbps\n     * @param {string} options.quality - Quality preset: 'medium', 'high', 'very-high'\n     * @param {string} options.latencyMode - Latency mode: 'quality' or 'realtime'\n     * @param {string} options.bitrateMode - Bitrate mode: 'variable' or 'constant'\n     * @param {number} options.keyFrameInterval - Frames between keyframes\n     * @param {string} options.contentHint - Content hint: '', 'motion', 'detail', 'text'\n     * @returns {Promise<WebCodecsVP9Encoder>} This instance\n     */\n  async create(options) {\n    const {\n      width,\n      height,\n      fps,\n      bitrate,\n      quality = 'high',\n      latencyMode = 'quality',\n      bitrateMode = 'variable',\n      keyFrameInterval = 120,\n      contentHint = ''\n    } = options;\n\n    if (!WebCodecsVP9Encoder.isSupported()) {\n      throw new Error('WebCodecs API not supported in this browser.');\n    }\n\n    console.log('[WebCodecs VP9] Initializing with:', {\n      width,\n      height,\n      fps,\n      bitrate: `${bitrate} kbps`,\n      quality,\n      latencyMode,\n      bitrateMode,\n      keyFrameInterval,\n      contentHint: contentHint || 'auto',\n      codec: 'VP9',\n      api: 'WebCodecs + Mediabunny'\n    });\n\n    // Store frame duration in seconds\n    this.frameDuration = 1 / fps;\n    this.keyFrameInterval = keyFrameInterval;\n    this.framesSinceKeyframe = 0;\n\n    // Create a temporary canvas for encoding\n    // We'll draw frames to this canvas and encode them\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.ctx = this.canvas.getContext('2d', {\n      willReadFrequently: false,\n      alpha: false\n    });\n\n    // Create Mediabunny output with WebM format\n    this.output = new Output({\n      format: new WebMOutputFormat(),\n      target: new BufferTarget()\n    });\n\n    // Map quality preset to Mediabunny Quality constant\n    let qualityConstant;\n    if (quality === 'very-high') {\n      qualityConstant = QUALITY_VERY_HIGH;\n      console.log('[WebCodecs VP9] Quality: VERY_HIGH');\n    } else if (quality === 'medium') {\n      qualityConstant = QUALITY_HIGH; // Use HIGH even for medium (good enough)\n      console.log('[WebCodecs VP9] Quality: MEDIUM (using HIGH)');\n    } else {\n      qualityConstant = QUALITY_HIGH; // default\n      console.log('[WebCodecs VP9] Quality: HIGH');\n    }\n\n    // Build CanvasSource config with all options\n    const canvasConfig = {\n      codec: 'vp9',\n      bitrate: qualityConstant,\n      latencyMode,\n      bitrateMode,\n      keyFrameInterval\n    };\n\n    // Add content hint if specified\n    if (contentHint) {\n      canvasConfig.contentHint = contentHint;\n    }\n\n    console.log('[WebCodecs VP9] Canvas config:', canvasConfig);\n\n    // Create canvas source with all options\n    this.canvasSource = new CanvasSource(this.canvas, canvasConfig);\n\n    // Add video track to output\n    this.output.addVideoTrack(this.canvasSource);\n\n    // Start the output (required before adding frames)\n    await this.output.start();\n    this.isStarted = true;\n\n    console.log('[WebCodecs VP9] Initialization complete, ready to receive frames');\n    return this;\n  }\n\n  /**\n     * Add an RGBA frame to the video\n     * @param {Uint8Array} rgbaBuffer - RGBA pixel data (width * height * 4 bytes)\n     */\n  async addFrame(rgbaBuffer) {\n    if (this.isFinalized) {\n      throw new Error('Cannot add frames after finalization');\n    }\n\n    if (!this.isStarted) {\n      throw new Error('Encoder not started - call create() first');\n    }\n\n    if (!this.canvas || !this.ctx) {\n      throw new Error('Canvas not initialized - call create() first');\n    }\n\n    this.frameCount++;\n\n    if (this.frameCount % 30 === 0) {\n      console.log(`[WebCodecs VP9] Encoding frame ${this.frameCount}`);\n    }\n\n    // Debug first frame\n    if (this.frameCount === 1) {\n      console.log(`[WebCodecs VP9] First frame - buffer size: ${rgbaBuffer.byteLength} bytes`);\n    }\n\n    // Convert RGBA buffer to ImageData\n    const imageData = new ImageData(\n      // @ts-ignore - rgbaBuffer.buffer can be SharedArrayBuffer which is compatible\n      new Uint8ClampedArray(rgbaBuffer.buffer || rgbaBuffer),\n      this.canvas.width,\n      this.canvas.height\n    );\n\n    // Draw to canvas\n    this.ctx.putImageData(imageData, 0, 0);\n\n    // Add frame to CanvasSource with timestamp and duration (in seconds)\n    // Mediabunny reads from the canvas automatically\n    await this.canvasSource.add(this.currentTimestamp, this.frameDuration);\n\n    // Increment timestamp for next frame\n    this.currentTimestamp += this.frameDuration;\n  }\n\n  /**\n     * Finalize encoding and get the WebM file\n     * @returns {Promise<ArrayBuffer>} The complete WebM video data\n     */\n  async end() {\n    if (this.isFinalized) {\n      throw new Error('Encoder already finalized');\n    }\n\n    console.log(`[WebCodecs VP9] Finalizing encoding (${this.frameCount} total frames, ${this.currentTimestamp.toFixed(2)}s duration)`);\n    this.isFinalized = true;\n\n    try {\n      // Finalize the output and get the video buffer\n      await this.output.finalize();\n\n      const videoBuffer = this.output.target.buffer;\n\n      if (!videoBuffer) {\n        throw new Error('No video buffer produced');\n      }\n\n      console.log(`[WebCodecs VP9] Successfully finalized video: ${videoBuffer.byteLength} bytes`);\n\n      return videoBuffer;\n    } catch (error) {\n      console.error('[WebCodecs VP9] Finalization error:', error);\n      throw new Error(`WebCodecs VP9 encoding failed: ${error.message || error}`);\n    }\n  }\n\n  /**\n     * Cleanup resources\n     */\n  destroy() {\n    console.log('[WebCodecs VP9] Destroying encoder');\n\n    if (this.canvasSource) {\n      // Mediabunny handles cleanup internally\n      this.canvasSource = null;\n    }\n\n    if (this.output) {\n      this.output = null;\n    }\n\n    if (this.canvas) {\n      this.canvas = null;\n    }\n\n    this.ctx = null;\n    this.frameCount = 0;\n    this.currentTimestamp = 0;\n    this.frameDuration = 0;\n    this.isFinalized = false;\n    this.isStarted = false;\n  }\n}\n"],"names":["calculateBearing","lng1","lat1","lng2","lat2","dLng","Math","PI","lat1Rad","lat2Rad","y","sin","cos","x","atan2","calculateDistance","dLat","a","sqrt","catmullRomPoint","p0","p1","p2","p3","t","tension","t2","t3","v0","v1","lng","w0","w1","resamplePath","coords","targetSpacingKm","length","resampled","accumulatedDistance","i","segmentDistance","newLng","newLat","push","lastOriginal","lastResampled","resamplePathCatmullRom","smoothCurve","max","min","j","point","getOptimalViewForWaypoints","map","waypoints","waypointArray","type","features","feature","center","geometry","coordinates","Array","isArray","zoom","getZoom","west","Infinity","south","east","north","forEach","wp","lat","centerLng","centerLat","bounds","canvas","getCanvas","padding","width","height","camera","cameraForBounds","top","bottom","left","right","sleep","ms","Promise","resolve","setTimeout","ROAD_QUERY_FILTER","CARDINAL_DIRECTIONS_8","angle","name","normalizeBearingDiff","diff","isValidCoordinate","coord","cleanupMap2AndDebugLayer","options","map2","remove","e","div2","parentNode","removeChild","getLayer","removeLayer","getSource","removeSource","segmentIntersection","p4","x1","y1","x2","y2","x3","y3","x4","y4","denom","abs","u","dx","dy","AnimationConstraints","constructor","this","maxBounds","minZoom","undefined","maxZoom","strictBounds","isWithinBounds","constrainCenter","constrainedLng","constrainedLat","toArray","isWithinZoomLimits","constrainZoom","applyCameraConstraints","constrained","calculateSafePath","fromCenter","toCenter","steps","path","fromLng","fromLat","toLng","toLat","validateCurrentView","issues","getCenter","valid","getSafeBounds","getBounds","getWest","getEast","getSouth","getNorth","wrapAnimation","animationFn","async","control","originalFlyTo","flyTo","bind","originalEaseTo","easeTo","originalJumpTo","jumpTo","flyToWaypoint","waypoint","transitionDuration","checkAbort","updateStatus","wpName","flyToOptions","duration","essential","bearing","pitch","jumpToOptions","once","rotatePanorama360","degreesPerStep","onStep","nextBearing","current","increment","next","totalSteps","msPerStep","currentBearing","getBearing","progress","currentPitch","from","to","easToOptions","easing","stepResult","capabilitiesCache","WeakMap","AnimationDirector","capabilities","_detectCapabilities","forceDetect","has","get","caps","hasTerrain","hasHillshade","has3DBuildings","hasRasterLayers","hasVectorLayers","hasRoads","hasRailways","hasWaterways","hasWater","hasPlaces","hasLanduse","hasGlyphs","hasSprites","maxZoomData","style","vectorSources","roads","sourceId","sourceLayer","railways","waterways","getStyle","sources","Object","values","source","maxzoom","glyphs","sprite","sourceLayers","Set","layers","layer","layerId","id","toLowerCase","add","includes","console","log","styleUrl","set","_positionHelperMapAhead","currentPos","searchRadius","radians","aheadLng","aheadLat","margin","minLng","maxLng","minLat","maxLat","fitBounds","linear","toFixed","error","_findInterestingPoints","points","ne","getNorthEast","sw","getSouthWest","samples","createAdaptiveAnimation","setup","animation","animations","_createOpeningShot","_createTerrainShowcase","_createBuildingFlythrough","_createExplorationSequence","_createCinematicSequence","_createClosingShot","timePerAnimation","currentZoom","overviewZoom","getTerrain","terrainSource","keys","find","s","setTerrain","exaggeration","stepDuration","startBearing","initialState","_extractMinimalStyle","warn","director","uniqueSources","info","size","filter","l","minimalSources","vectorSource","tiles","url","minzoom","attribution","minimalLayers","paint","minimalStyle","version","_findNearbyRoadInCardinalDirections","fromPoint","usedSegmentIds","roads2","prefer","preferredClasses","join","searchDirections","d","searchRadiusKm","bestRoad","bestScore","direction","searchLng","searchLat","road","roadStart","roadEnd","distStartFromActual","distEndFromActual","actualDist","distStart","distEnd","minDist","bearingDiff","score","roadClass","properties","class","shouldReverse","reverse","reversed","distance","isPreferred","PresetAnimations","orbit360","optimalView","zoomPulse","startZoom","figure8","spiralZoom","neighborhood","startPitch","getPitch","propertyShowcase","angles","panorama","exploreAround","offsetLng","offsetLat","pos","aerialSweep","initialZoom","initialPitch","terrainSafeZoom","latSpan","lngSpan","samplePoints","maxElevation","elevation","queryTerrainElevation","elevationKm","safetyMargin","log2","zoomOutLevel","descentProgress","droneShot","initialBearing","msPerAscentStep","bearingIncrement","msPerDescentStep","bearingProgress","orbitZoom","targetZoom","waveMotion","basePitch","waveProgress","pendulum","swing","swingAngle","spotlightScan","pulseProgress","butterfly","waypointTour","tour","totalDuration","totalPauseTime","reduce","sum","transitionTime","timePerTransition","createWaypointTour","msg","terrainFollowing","zoomBuffer","step","centerElevation","baseZoom","elevationAdjustment","shift","smoothedZoom","b","round","_followPathWithVehicleSetup","vehicleProfile","transportClasses","sourceId2","sourceLayer2","debugFeatures","styleInfo","existingDiv","document","getElementById","mainContainer","getContainer","offsetWidth","offsetHeight","createElement","cssText","body","appendChild","maplibregl","Map","container","preserveDrawingBuffer","interactive","availableRoads2","querySourceFeatures","closestIntersection","minIntersectionDistance","dir","angleRad","rayEnd","rayStart","roadSegStart","roadSegEnd","dist","closestRoad","minDistance","detectedClass","roadCoords","firstLng","firstLat","lastLng","lastLat","roadBearing","icon","targetPitch","firstPoint","initialPositionBearing","secondLng","secondLat","vehicleAltitude","altitude","cameraZoom","noMoveStart","delayEndEvents","animOptions","_followPathWithVehicle","supportsExploration","debugSourceId","debugLayerId","addSource","data","addLayer","layout","layerError","findNextSegment","lastPoint","secondLastPoint","usedIds","currentRoadName","currentSegmentCoords","roadName","currentRoadRef","roadRef","currentRoadClass","currentRoads2","bestNextSegment","candidateCount","connectionThreshold","dxStart","dyStart","distanceToStart","dxEnd","dyEnd","distanceToEnd","effectiveCoords","effectiveStart","effectiveSecond","nextSegmentBearing","isNaN","ref","isSameRef","isSameName","isSameClass","candidateLabel","priorityLabel","currentZoom2","zoomsToTry","zoomLevel","setZoom","retryRoads2","vehicleSpeedKmh","speedKmh","startTime","now","smoothPath","bufferSize","smoothing","currentSegmentIndex","segmentCount","totalPointsVisited","elapsed","isTimeFrozen","nextSegment","currentClass","stepDistance","maxSteps","foundRoad","intermediatePoints","straightAheadDistance","intermediateSteps","syntheticCoords","synthetic","clear","slice","segmentClass","segmentName","segmentRef","roadIdentity","distanceM","elapsedMs","segmentNum","parseFloat","numPoints","roadId","timestampMs","zoom2","debugSource","setData","currentPoint","moveDuration","nextLng","nextLat","prevLng","prevLat","percent","finalGeoJSON","JSON","stringify","tractorRoadTrip","preloadDistance","carRoadTrip","sportsCarRace","planeFlight","helicopterTour","droneFollow","birdsEyeRoad","trainRide","speedboat","sailboat","cruiseShip","freeFlight","initialCenter","currentLng","currentLat","bearingDrift","random","AnimationController","abortController","isRunning","initialPosition","run","cancel","cancelled","AbortController","_capturePosition","signal","aborted","DOMException","success","cleanup","abort","stop","running","createAbortChecker","waitForMove","movePromise","WebmEncoderWrapper","worker","resolveEnd","videoChunks","frameCount","realtimeMode","create","fps","bitrate","wasmUrl","workerUrl","realtime","validatedWorkerUrl","workerUrlObj","URL","window","location","href","origin","Error","pathname","endsWith","message","wrapperUrl","replace","Worker","onmessage","ArrayBuffer","byteLength","resolveReady","totalSize","chunk","finalVideo","Uint8Array","offset","buffer","onerror","postMessage","reject","timeout","clearTimeout","config","addFrame","rgbaBuffer","end","videoData","destroy","terminate","getDefaultFormat","VideoEncoder","VideoFrame","ANIMATION_PROFILES","smart","label","description","group","requires","func","orbit","_map","_control","_options","m","callbacks","opts","pulse","property","explore","aerial","spiral","ANIMATION_GROUPS","auto","loops","cinematic","VideoExportControl","static","resolution","speedMultiplier","waitForTiles","position","collapsed","compactPosition","loop","explorationLimitEnabled","explorationMaxDuration","showBoundsOverlay","format","encoderPath","encoderCdn","onStart","onProgress","onComplete","onError","err","_container","_animationController","_encoder","_encoderLoaded","_spriteIcons","_waypointMarkers","_isRecording","_savedWaypointsVisibility","_waypointsLayerId","_waypointsSourceId","_loadWaypoints","_spriteImage","_spriteData","_spritePngUrl","_iconSize","_availableFonts","_selectedFont","_showWaypointLabels","_recordingStartTime","onAdd","_checkMapLibreVersion","className","_createUI","isStyleLoaded","_checkMapCapabilities","_loadSpriteIcons","_addDefaultWaypointIcon","_createWaypointsLayer","_createWaypointMarkers","_updateWaypointsUI","onRemove","delete","mapContainer","_overlay","_panel","setNow","restoreNow","_generateAnimationOptions","groupedAnimations","entries","key","profile","html","groupKey","groupLabel","anim","selected","_loadSettings","saved","localStorage","getItem","parse","DEFAULT_SETTINGS","_applySettings","settings","value","parentId","selectEl","tagName","el","checked","dispatchEvent","Event","_saveSettings","querySelectorAll","setItem","_saveWaypoints","_loadSectionStates","defaults","movie","_saveSectionStates","_sectionStates","_toggleSection","sectionId","header","querySelector","content","indicator","isCollapsed","HTMLElement","display","textContent","_collapseSection","button","title","innerHTML","addEventListener","_togglePanel","_progressWidget","getComputedStyle","_initWaypointsIconSelect","_bindEvents","_updateAnimationDescription","_testAnimation","_startExploration","_startRecording","preventDefault","confirm","resetMessage","savedSettings","updateRecordingTime","recordingDuration","seconds","timeDisplay","target","_updateExplorationUI","resolutionSelect","resolutionCustomGroup","resolutionWidthInput","resolutionHeightInput","parseInt","durationSelect","durationCustomGroup","durationInput","realTimeDisplay","updateRealTimeDisplay","realTime","timeStr","mins","floor","secs","formatInfo","color","mp4Advanced","vp8Advanced","vp9Advanced","vp9Option","formatSelect","supportsWebCodecs","disabled","formatAdvancedToggle","formatAdvancedGroup","speedSelect","speedCustomGroup","speedCustomInput","bitrateSelect","bitrateCustomGroup","bitrateCustomInput","boundsCurrentBtn","minZoomInput","maxZoomInput","_updateBoundsFromUI","_updateBoundsOverlay","boundsWaypointsBtn","alert","padLng","padLat","westInput","eastInput","southInput","northInput","selector","input","_updateZoomLimitsFromUI","strictBoundsCheck","showBoundsCheck","_removeBoundsOverlay","showLabelsToggle","fontSelectContainer","_updateWaypointsLayer","fontSelect","iconSizeSlider","iconSizeValue","addWaypointBtn","_addWaypoint","importWaypointsBtn","_importWaypoints","exportWaypointsBtn","_exportWaypoints","all","_loadSpriteSheet","_loadFontstacks","_populateFontSelect","_updateIconAvailability","spriteUrl","pixelRatio","suffix","spriteData","spriteImage","jsonUrl","jsonResponse","fetch","ok","status","json","pngUrl","Image","crossOrigin","onload","src","_spritePixelRatio","glyphsUrl","baseUrl","fontstacksUrl","response","method","headers","Accept","fontstacks","fetchError","fonts","textFont","font","item","startsWith","sort","fontStatus","option","statusEl","iconSelect","searchInput","_allIcons","_fillIconSelect","removeEventListener","_handleIconSearch","_updateIconPreview","currentValue","defaultOption","iconsToShow","iconId","iconSelectCasted","some","opt","firstValidOption","previewDiv","selectedIcon","span","fontSize","div","alignItems","justifyContent","hasSpriteData","hasIconInData","hasSpriteUrl","hasSpriteImage","imageComplete","complete","iconData","pr","bgWidth","bgHeight","iconWidth","iconHeight","iconX","iconY","backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","maxWidth","maxHeight","_fillPopupIconSelect","index","_updatePopupIconPreview","naturalWidth","naturalHeight","dataUrl","encodeURIComponent","img","hasImage","addImage","_ensureDefaultWaypointIcon","_createMarkerElement","dataset","waypointIndex","String","displayWidth","displayHeight","bgPosX","bgPosY","scaledWidth","scaledHeight","_createMarkerPopupHTML","props","iconOptions","iconName","marker","searchTerm","iconLower","Marker","element","draggable","anchor","setLngLat","addTo","popupHTML","popup","Popup","closeButton","closeOnClick","setHTML","setPopup","originalCoords","on","cursor","lngLat","getLngLat","_validateWaypointCoordinates","waypointName","_attachPopupEventListeners","popupEl","getElement","cameraUpdateListener","field","iconValue","iconSearch","saveBtn","off","cancelBtn","deleteBtn","splice","lngField","latField","cameraToggle","zoomField","bearingField","pitchField","cameraToggleEl","zoomFieldEl","bearingFieldEl","pitchFieldEl","updateCameraFields","toString","inputEl","fieldId","numValue","_removeWaypointsLayer","_hideWaypointMarkers","_showWaypointMarkers","_createWaypointsWebGLLayer","geojsonWithIcons","visibility","_removeWaypointsWebGLLayer","lastMarker","togglePopup","_hidePanel","list","exportBtn","iconHTML","scale","iconContainer","nameSpan","setAttribute","moveUpBtn","moveDownBtn","btn","stopPropagation","getAttribute","_deleteWaypoint","_editWaypoint","editor","hasCamera","wpIndex","wpIcon","wpLng","wpLat","wpDuration","zoomInput","bearingInput","pitchInput","_saveWaypoint","_cancelWaypointEdit","accept","onchange","file","files","MAX_FILE_SIZE","reader","FileReader","event","geojson","outOfBoundsWaypoints","idx","waypointList","readAsText","click","blob","Blob","createObjectURL","download","Date","revokeObjectURL","requestAnimationFrame","_adjustPanelPosition","attributionControl","viewportHeight","innerHeight","bottomOffset","availableHeight","_updateStatus","_estimateFileSize","durationMs","baseSizeMB","_recordingParams","isHighQuality","_formatSize","mb","_updateProgress","totalFrames","statusSpan","percentSpan","framesSpan","sizeSpan","timeSpan","toLocaleString","estimatedMB","estimatedRemainingMs","ceil","minutes","hours","_hideProgress","_showFinalStats","stats","statusDiv","parentElement","percentDiv","sizeDiv","summaryDiv","videoSpan","realtimeSpan","speedSpan","videoDuration","faster","speedRatio","sizeMB","_collapseInterface","compactClass","classList","percentEl","sizeEl","constraintsGroup","waypointsGroup","resetDiv","explorationLimit","explorationDiv","closest","recordingTime","_expandInterface","customResGroup","customSpeedGroup","toggle","toggleBtn","sectionContent","_preloadEncoder","_detectEncoderSources","encoderUrl","simdUrl","mp4","encoderModule","import","_loadEncoder","default","simdModule","_simd","simd","_loadEncoderForFormat","_loadMp4Encoder","_loadWebmEncoder","webm","_loadWebCodecsVP9Encoder","speedEl","qpEl","gopEl","speed","qpMin","qpMax","gop","split","v","encoder","kbps","rgbFlipY","quantizationParameter","groupOfPictures","vp8BitrateEl","customBitrate","finalBitrate","wrapper","_WebCodecsVP9Encoder","module","then","webcodecsVp9Encoder","WebCodecsVP9Encoder","isSupported","qualityEl","latencyEl","bitrateModeEl","keyframeEl","contentHintEl","quality","latencyMode","bitrateMode","keyFrameInterval","contentHint","mp4PathsToTry","webmPathsToTry","pluginDir","substring","lastIndexOf","getPluginDirectory","customPath","mp4Source","webmSource","_readOptionsFromUI","animationSelect","customInput","fpsInput","widthInput","heightInput","cinematicBarsSelect","cinematicBars","waitTilesCheckbox","loopSelect","strictBoundsCheckbox","showBoundsCheckbox","explorationLimitCheckbox","_getAnimation","animObj","result","_addLoopToAnimation","originalAnimation","finalState","returnDuration","exploreBtn","explorationLimitContainer","descriptionDiv","descriptionSpan","animationName","_analyzeCapabilities","missing","required","optional","available","animKey","req","isOptional","capName","category","capabilityLabels","hasIt","hasOpenMapTiles","roadAnimationsGroup","_updateCapabilityFeedback","feedbackDiv","analysis","hasRequiredMissing","hasOptionalMissing","testBtn","recordBtn","_testProgressTimer","clearInterval","performance","setInterval","elapsedSeconds","durationSeconds","_exploreProgressTimer","_isExploring","isLimitEnabled","originalDuration","maxDuration","remainingSeconds","_doRecording","_ensureCameraWithinConstraints","currentCenter","needsCorrection","targetCenter","_applyCinematicBars","pixels","aspectRatio","targetRatio","visibleHeight","totalBarHeight","topBarHeight","bottomBarHeight","bytesPerRow","rowOffset","pixelOffset","realStartTime","toUpperCase","_getResolution","originalSize","originalCamera","resize","gl","painter","context","ptr","getRGBPointer","virtualTime","timeAdvance","waitForTilesLoaded","areTilesLoaded","triggerRepaint","targetFrames","animationComplete","catch","memory","subarray","readPixels","RGBA","UNSIGNED_BYTE","encodeRGBPointer","flipped","srcOffset","dstOffset","firstPixels","mimeType","extension","toISOString","realElapsedSeconds","videoDurationSeconds","resolutions","hd","fullhd","res","assert","last","arr","Bitstream","bytes","seekToByte","byteOffset","readBit","byteIndex","byte","bitIndex","bit","readBits","n","writeBits","readAlignedByte","skipBits","getBitsLeft","clone","toUint8Array","TextDecoder","textEncoder","TextEncoder","invertObject","object","fromEntries","COLOR_PRIMARIES_MAP","bt709","bt470bg","smpte170m","bt2020","smpte432","TRANSFER_CHARACTERISTICS_MAP","pq","hlg","MATRIX_COEFFICIENTS_MAP","rgb","colorSpaceIsComplete","colorSpace","primaries","transfer","matrix","fullRange","isAllowSharedBufferSource","SharedArrayBuffer","isView","AsyncMutex","currentPromise","acquire","resolver","nextPromise","currentPromiseAlias","assertNever","roundToMultiple","multiple","ISO_639_2_REGEX","SECOND_TO_MICROSECOND_FACTOR","Number","EPSILON","CallSerializer","call","fn","isFirefoxCache","isFirefox","navigator","userAgent","imageMimeTypeToExtension","uint8ArraysAreEqual","RichImageData","TypeError","AttachedFile","VIDEO_CODECS","PCM_AUDIO_CODECS","NON_PCM_AUDIO_CODECS","AUDIO_CODECS","SUBTITLE_CODECS","AVC_LEVEL_TABLE","maxMacroblocks","maxBitrate","level","HEVC_LEVEL_TABLE","maxPictureSize","tier","VP9_LEVEL_TABLE","AV1_LEVEL_TABLE","buildVideoCodecString","codec","profileIndication","totalMacroblocks","levelInfo","levelIndication","padStart","profilePrefix","profileIdc","compatibilityFlags","pictureSize","constraintFlags","bitDepth","generateVp9CodecConfigurationFromCodecString","codecString","parts","generateAv1CodecConfigurationFromCodecString","levelAndTier","PCM_CODEC_REGEX","VALID_VIDEO_CODEC_STRING_PREFIXES","AVC_CODEC_STRING_REGEX","HEVC_CODEC_STRING_REGEX","VP9_CODEC_STRING_REGEX","AV1_CODEC_STRING_REGEX","VALID_AUDIO_CODEC_STRING_PREFIXES","Muxer","output","mutex","firstMediaStreamTimestamp","trackTimestampInfo","onTrackClose","track","validateAndNormalizeTimestamp","timestampInSeconds","isKeyFrame","_timestampOffset","timestampInfo","maxTimestamp","maxTimestampBeforeLastKeyFrame","AvcNalUnitType","HevcNalUnitType","parseOpusIdentificationHeader","view","DataView","outputChannelCount","getUint8","preSkip","getUint16","inputSampleRate","getUint32","outputGain","getInt16","channelMappingFamily","channelMappingTable","FlacBlockType","customVideoEncoders","PLACEHOLDER_DATA","EncodedPacket","timestamp","sequenceNumber","sideData","isFinite","isInteger","alpha","alphaByteLength","isMetadataOnly","microsecondTimestamp","trunc","microsecondDuration","toEncodedVideoChunk","EncodedVideoChunk","alphaToEncodedVideoChunk","toEncodedAudioChunk","EncodedAudioChunk","fromEncodedChunk","copyTo","Symbol","dispose","VideoSample","rotation","codedWidth","codedHeight","hasAlpha","init","_closed","_data","VideoColorSpace","HTMLImageElement","SVGImageElement","ImageBitmap","HTMLVideoElement","HTMLCanvasElement","OffscreenCanvas","videoWidth","videoHeight","getContext","willReadFrequently","drawImage","isVideoFrame","close","allocationSize","destination","imageData","getImageData","toVideoFrame","draw","arg1","arg2","arg3","arg4","arg5","arg6","arg7","arg8","sx","sy","sWidth","sHeight","dWidth","dHeight","CanvasRenderingContext2D","OffscreenCanvasRenderingContext2D","_rotateSourceRegion","toCanvasImageSource","save","centerX","centerY","translate","rotate","aspectRatioChange","restore","drawWithFit","fit","crop","validateCropRectangle","canvasWidth","canvasHeight","rotatedWidth","rotatedHeight","newWidth","newHeight","clampCropRectangle","sampleWidth","sampleHeight","videoFrame","queueMicrotask","setRotation","newRotation","setTimestamp","newTimestamp","setDuration","newDuration","outerWidth","outerHeight","prefix","EBMLFloat32","EBMLFloat64","EBMLSignedInt","EBMLUnicodeString","EBMLId","EBML","Segment","SeekHead","Info","Cluster","Tracks","Cues","Attachments","Chapters","Tags","measureUnsignedInt","measureUnsignedBigInt","measureSignedInt","EBMLWriter","writer","helper","helperView","offsets","dataOffsets","writeByte","setUint8","write","writeFloat32","setFloat32","writeFloat64","setFloat64","writeUnsignedInt","writeUnsignedBigInt","BigInt","writeSignedInt","writeVarInt","measureVarInt","writeAsciiString","str","charCodeAt","writeEBML","elem","getPos","sizePos","sizeSize","seek","startPos","endPos","encode","CODEC_STRING_MAP","avc","hevc","vp8","vp9","av1","aac","mp3","opus","vorbis","flac","webvtt","inlineTimestampRegex","timestampRegex","Writer","ensureMonotonicity","trackedWrites","trackedStart","trackedEnd","start","maybeTrackWrites","neededSize","newLength","copy","startTrackingWrites","stopTrackingWrites","ARRAY_BUFFER_INITIAL_SIZE","ARRAY_BUFFER_MAX_SIZE","BufferTargetWriter","super","maxPos","supportsResize","maxByteLength","ensureSize","newBuffer","newBytes","onwrite","newPos","flush","finalize","getSlice","Target","_output","BufferTarget","arguments","_createWriter","APP_NAME","TRACK_TYPE_MAP","video","audio","subtitle","MatroskaMuxer","trackDatas","allTracksKnown","promise","rej","promiseWithResolvers","segment","segmentInfo","seekHead","tracksElement","tagsElement","attachmentsElement","segmentDuration","cues","currentCluster","currentClusterStartMsTimestamp","currentClusterMaxMsTimestamp","trackDatasInCurrentCluster","_writer","ebmlWriter","appendOnly","release","writeEBMLHeader","createSegmentInfo","createCues","onEbmlHeader","ebmlHeader","EBMLVersion","EBMLReadVersion","EBMLMaxIDLength","EBMLMaxSizeLength","DocType","WebMOutputFormat","DocTypeVersion","DocTypeReadVersion","maybeCreateSeekHead","writeOffsets","kaxCues","kaxInfo","kaxTracks","kaxAttachments","kaxTags","Seek","SeekID","SeekPosition","segmentDataOffset","Duration","TimestampScale","MuxingApp","WritingApp","createTracks","trackData","codecId","_codec","seekPreRollNs","decoderConfig","TrackEntry","TrackNumber","TrackUID","TrackType","FlagLacing","Language","metadata","languageCode","CodecID","CodecDelay","SeekPreRoll","Name","videoSpecificTrackInfo","audioSpecificTrackInfo","subtitleSpecificTrackInfo","frameRate","elements","CodecPrivate","DefaultDuration","flippedRotation","mappedRotation","normalizeRotation","videoElement","Video","PixelWidth","PixelHeight","alphaMode","AlphaMode","Colour","MatrixCoefficients","TransferCharacteristics","Primaries","Range","Projection","ProjectionType","ProjectionPoseRoll","pcmInfo","dataType","sampleSize","littleEndian","silentValue","match","exec","parsePcmCodec","Audio","SamplingFrequency","sampleRate","Channels","numberOfChannels","BitDepth","maybeCreateTags","simpleTags","addSimpleTag","SimpleTag","TagName","TagString","TagBinary","metadataTags","_metadataTags","writtenTags","keyValueIterator","tracksTotal","discsTotal","raw","Tag","Targets","TargetTypeValue","TargetType","maybeCreateAttachments","existingFileUids","images","image","fileUid","imageName","kind","FileDescription","FileName","FileMediaType","FileData","FileUID","test","createSegment","onSegmentHeader","allTracksAreKnown","_tracks","getMimeType","codecStrings","string","hasVideo","hasAudio","isWebM","Boolean","buildMatroskaMimeType","getVideoTrackData","packet","meta","existingTrackData","primariesValues","transferValues","matrixValues","validateVideoChunkMetadata","newTrackData","chunkQueue","lastWrittenMsTimestamp","getAudioTrackData","minDescriptionSize","validateAudioChunkMetadata","getSubtitleTrackData","validateSubtitleMetadata","addEncodedVideoPacket","additions","videoChunk","createInternalChunk","fixVP9ColorSpace","interleaveChunks","addEncodedAudioPacket","audioChunk","addSubtitleCue","cue","bodyText","text","lastIndex","milliseconds","formatSubtitleTimestamp","parseSubtitleTimestamp","identifier","notes","subtitleChunk","trim","isFinalCall","outer","trackWithMinTimestamp","minTimestamp","writeBlock","bitstream","profileLowBit","colorSpaceID","msTimestamp","keyFrameQueuedEverywhere","every","otherTrackData","firstQueuedSample","shouldCreateNewCluster","relativeTimestamp","minimumClusterDuration","createNewCluster","prelude","setInt16","msDuration","blockGroup","BlockGroup","Block","ReferenceBlock","BlockAdditions","BlockMore","BlockAddID","BlockAdditional","BlockDuration","simpleBlock","SimpleBlock","firstMsTimestamp","finalizeCurrentCluster","onCluster","Timestamp","clusterSize","clusterOffsetFromSegment","groupedByTimestamp","groupedAndSortedByTimestamp","CuePoint","CueTime","CueTrackPositions","CueTrack","CueClusterPosition","segmentSize","OutputFormat","getSupportedVideoCodecs","getSupportedCodecs","getSupportedAudioCodecs","getSupportedSubtitleCodecs","_codecUnsupportedHint","MkvOutputFormat","_createMuxer","_name","getSupportedTrackCounts","total","fileExtension","supportsVideoRotationMetadata","validateVideoEncodingAdditionalOptions","fullCodecString","hardwareAcceleration","scalabilityMode","Quality","factor","_factor","_toVideoBitrate","pow","_toAudioBitrate","baseBitrate","prev","curr","QUALITY_HIGH","QUALITY_VERY_HIGH","MediaSource","_connectedTrack","_closingPromise","_ensureValidAdd","state","_start","_flushAndClose","forceClose","connectedTrack","_muxer","_flushOrWaitForOngoingClose","VideoSource","VideoEncoderWrapper","encodingConfig","ensureEncoderPromise","encoderInitialized","muxer","lastMultipleOfKeyFrameInterval","resizeCanvas","customEncoder","customEncoderCallSerializer","customEncoderQueueSize","alphaEncoder","splitter","splitterCreationFailed","alphaFrameQueue","errorNeedsNewStack","videoSample","shouldClose","encodeOptions","checkForEncoderError","sizeChangeBehavior","canvasIsNew","fillStyle","fillRect","clearRect","ensureEncoder","multipleOfKeyFrameInterval","finalEncodeOptions","keyFrame","clonedSample","finally","ColorAlphaSplitter","colorFrame","extractColor","alphaFrame","extractAlpha","encodeQueueSize","encoderError","encoderConfig","resolvedBitrate","framerate","buildVideoEncoderConfig","onEncoderConfig","MatchingCustomEncoder","supports","onPacket","onEncodedPacket","isConfigSupported","supported","colorChunkQueue","nullAlphaChunkQueue","encodedAlphaChunkCount","alphaEncoderQueue","addPacket","colorChunk","alphaChunk","alphaData","stack","configure","flushAndClose","getQueueSize","initialWidth","initialHeight","lastFrame","colorProgram","createColorProgram","alphaProgram","createAlphaProgram","vao","createVAO","sourceTexture","createTexture","alphaResolutionLocation","getUniformLocation","useProgram","uniform1i","createVertexShader","createShader","VERTEX_SHADER","vertexShader","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","createVertexArray","bindVertexArray","vertices","Float32Array","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","positionLocation","getAttribLocation","texCoordLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","texture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","updateTexture","sourceFrame","activeTexture","TEXTURE0","texImage2D","viewport","COLOR_BUFFER_BIT","drawArrays","TRIANGLE_STRIP","uniform2f","yuvSize","requiredHeight","yuv","getExtension","loseContext","CanvasSource","validateVideoEncodingConfig","_canvas","sample","AudioSource","SubtitleSource","ALL_TRACK_TYPES","validateBaseTrackMetadata","maximumPacketCount","Output","_startPromise","_cancelPromise","_finalizePromise","_mutex","addVideoTrack","_addTrack","addAudioTrack","addSubtitleTrack","setMetadataTags","tags","artist","album","albumArtist","trackNumber","discNumber","genre","date","getTime","lyrics","comment","validateMetadataTags","supportedTrackCounts","presentTracksOfThisType","count","maxCount","maxTotalCount","supportedVideoCodecs","supportedAudioCodecs","supportedSubtitleCodecs","trackType","minCount","totalMinCount","promises","canvasSource","ctx","frameDuration","currentTimestamp","isFinalized","isStarted","qualityConstant","api","framesSinceKeyframe","canvasConfig","ImageData","Uint8ClampedArray","putImageData","videoBuffer"],"mappings":"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","x_google_ignoreList":[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]}